
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/kubeslice/kubeslice-controller/service/access_control_service.go (0.0%)</option>
				
				<option value="file1">github.com/kubeslice/kubeslice-controller/service/bootstrap.go (0.0%)</option>
				
				<option value="file2">github.com/kubeslice/kubeslice-controller/service/cluster_service.go (0.0%)</option>
				
				<option value="file3">github.com/kubeslice/kubeslice-controller/service/cluster_webhook_validation.go (0.0%)</option>
				
				<option value="file4">github.com/kubeslice/kubeslice-controller/service/default_slice_service.go (0.0%)</option>
				
				<option value="file5">github.com/kubeslice/kubeslice-controller/service/job_service.go (0.0%)</option>
				
				<option value="file6">github.com/kubeslice/kubeslice-controller/service/kube_slice_resource_names.go (0.0%)</option>
				
				<option value="file7">github.com/kubeslice/kubeslice-controller/service/namespace_service.go (0.0%)</option>
				
				<option value="file8">github.com/kubeslice/kubeslice-controller/service/project_service.go (0.0%)</option>
				
				<option value="file9">github.com/kubeslice/kubeslice-controller/service/project_webhook_validation.go (0.0%)</option>
				
				<option value="file10">github.com/kubeslice/kubeslice-controller/service/secret_service.go (0.0%)</option>
				
				<option value="file11">github.com/kubeslice/kubeslice-controller/service/service_export_config_service.go (0.0%)</option>
				
				<option value="file12">github.com/kubeslice/kubeslice-controller/service/service_export_config_webhook_validation.go (0.0%)</option>
				
				<option value="file13">github.com/kubeslice/kubeslice-controller/service/service_helper.go (0.0%)</option>
				
				<option value="file14">github.com/kubeslice/kubeslice-controller/service/slice_config_service.go (30.6%)</option>
				
				<option value="file15">github.com/kubeslice/kubeslice-controller/service/slice_config_webhook_validation.go (7.7%)</option>
				
				<option value="file16">github.com/kubeslice/kubeslice-controller/service/slice_qos_config_service.go (0.0%)</option>
				
				<option value="file17">github.com/kubeslice/kubeslice-controller/service/slice_qos_config_webhook_validation.go (0.0%)</option>
				
				<option value="file18">github.com/kubeslice/kubeslice-controller/service/vpn_key_rotation_service.go (0.0%)</option>
				
				<option value="file19">github.com/kubeslice/kubeslice-controller/service/vpn_key_rotation_webhook_validation.go (0.0%)</option>
				
				<option value="file20">github.com/kubeslice/kubeslice-controller/service/worker_service_import_service.go (0.0%)</option>
				
				<option value="file21">github.com/kubeslice/kubeslice-controller/service/worker_slice_config_service.go (0.0%)</option>
				
				<option value="file22">github.com/kubeslice/kubeslice-controller/service/worker_slice_config_webhook_validation.go (0.0%)</option>
				
				<option value="file23">github.com/kubeslice/kubeslice-controller/service/worker_slice_gateway_recycler_service.go (0.0%)</option>
				
				<option value="file24">github.com/kubeslice/kubeslice-controller/service/worker_slice_gateway_service.go (0.0%)</option>
				
				<option value="file25">github.com/kubeslice/kubeslice-controller/service/worker_slice_gateway_webhook_validation.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"
        "github.com/kubeslice/kubeslice-controller/metrics"
        "reflect"
        "strings"

        "github.com/kubeslice/kubeslice-controller/events"

        "github.com/kubeslice/kubeslice-controller/util"
        "go.uber.org/zap"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type IAccessControlService interface {
        ReconcileWorkerClusterRole(ctx context.Context, namespace string, owner client.Object) (ctrl.Result, error)
        ReconcileReadOnlyRole(ctx context.Context, namespace string, owner client.Object) (ctrl.Result, error)
        ReconcileReadWriteRole(ctx context.Context, namespace string, owner client.Object) (ctrl.Result, error)
        ReconcileReadOnlyUserServiceAccountAndRoleBindings(ctx context.Context, namespace string,
                names []string, owner client.Object) (ctrl.Result, error)
        ReconcileReadWriteUserServiceAccountAndRoleBindings(ctx context.Context, namespace string,
                names []string, owner client.Object) (ctrl.Result, error)
        ReconcileWorkerClusterServiceAccountAndRoleBindings(ctx context.Context, clusterName,
                namespace string, owner client.Object) (ctrl.Result, error)
        RemoveWorkerClusterServiceAccountAndRoleBindings(ctx context.Context, clusterName,
                namespace string, owner client.Object) (ctrl.Result, error)
}

// activeRoleBinding gives the active status of rolebinding
type activeRoleBinding struct {
        object rbacv1.RoleBinding
        active bool
}

// activeServiceAccount gives the active status of Service account
type activeServiceAccount struct {
        object corev1.ServiceAccount
        active bool
}

type AccessControlService struct {
        ruleProvider IAccessControlRuleProvider
        mf           metrics.IMetricRecorder
}

// ReconcileWorkerClusterRole reconciles the worker cluster role
func (a *AccessControlService) ReconcileWorkerClusterRole(ctx context.Context,
        namespace string, owner client.Object) (ctrl.Result, error) <span class="cov0" title="0">{
        namespacedName := client.ObjectKey{
                Namespace: namespace,
                Name:      roleWorkerCluster,
        }
        completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(owner), owner.GetName())
        labels := util.GetOwnerLabel(completeResourceName)
        expectedRole := &amp;rbacv1.Role{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      namespacedName.Name,
                        Namespace: namespacedName.Namespace,
                        Labels:    labels,
                },
                Rules: a.ruleProvider.WorkerClusterRoleRules(),
        }
        actualRole := &amp;rbacv1.Role{}
        found, err := util.GetResourceIfExist(ctx, namespacedName, actualRole)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        //Load Event Recorder with project name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).WithProject(util.GetProjectName(namespace)).WithNamespace(namespace)

        // Load metrics with project name and namespace
        a.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace)

        if !found </span><span class="cov0" title="0">{
                err = util.CreateResource(ctx, expectedRole)
                if err != nil </span><span class="cov0" title="0">{
                        util.RecordEvent(ctx, eventRecorder, expectedRole, nil, events.EventWorkerClusterRoleCreationFailed)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "creation_failed",
                                        "event":       string(events.EventWorkerClusterRoleCreationFailed),
                                        "object_name": expectedRole.Name,
                                        "object_kind": metricKindRole,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, expectedRole, nil, events.EventWorkerClusterRoleCreated)
                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "created",
                                "event":       string(events.EventWorkerClusterRoleCreated),
                                "object_name": expectedRole.Name,
                                "object_kind": metricKindRole,
                        },
                )</span>
        } else<span class="cov0" title="0"> {
                err = util.UpdateResource(ctx, expectedRole)
                if err != nil </span><span class="cov0" title="0">{
                        util.RecordEvent(ctx, eventRecorder, expectedRole, nil, events.EventWorkerClusterRoleUpdateFailed)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "update_failed",
                                        "event":       string(events.EventWorkerClusterRoleUpdateFailed),
                                        "object_name": expectedRole.Name,
                                        "object_kind": metricKindRole,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, expectedRole, nil, events.EventWorkerClusterRoleUpdated)
                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "updated",
                                "event":       string(events.EventWorkerClusterRoleUpdated),
                                "object_name": expectedRole.Name,
                                "object_kind": metricKindRole,
                        },
                )</span>
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// ReconcileReadOnlyRole reconciles the read only role for the project users
func (a *AccessControlService) ReconcileReadOnlyRole(ctx context.Context, namespace string, owner client.Object) (ctrl.Result,
        error) <span class="cov0" title="0">{
        namespacedName := client.ObjectKey{
                Namespace: namespace,
                Name:      roleSharedReadOnly,
        }
        completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(owner), owner.GetName())
        labels := util.GetOwnerLabel(completeResourceName)
        expectedRole := &amp;rbacv1.Role{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      namespacedName.Name,
                        Namespace: namespacedName.Namespace,
                        Labels:    labels,
                },
                Rules: a.ruleProvider.ReadOnlyRoleRules(),
        }
        actualRole := &amp;rbacv1.Role{}
        found, err := util.GetResourceIfExist(ctx, namespacedName, actualRole)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        //Load Event Recorder with project name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).WithProject(util.GetProjectName(namespace)).WithNamespace(namespace)

        // Load metrics with project name and namespace
        a.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace)

        if !found </span><span class="cov0" title="0">{
                err = util.CreateResource(ctx, expectedRole)
                if err != nil </span><span class="cov0" title="0">{
                        util.RecordEvent(ctx, eventRecorder, expectedRole, nil, events.EventReadOnlyRoleCreationFailed)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "creation_failed",
                                        "event":       string(events.EventReadOnlyRoleCreationFailed),
                                        "object_name": expectedRole.Name,
                                        "object_kind": metricKindRole,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, expectedRole, nil, events.EventReadOnlyRoleCreated)
                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "created",
                                "event":       string(events.EventReadOnlyRoleCreated),
                                "object_name": expectedRole.Name,
                                "object_kind": metricKindRole,
                        },
                )</span>
        } else<span class="cov0" title="0"> {
                err = util.UpdateResource(ctx, expectedRole)
                if err != nil </span><span class="cov0" title="0">{
                        util.RecordEvent(ctx, eventRecorder, expectedRole, nil, events.EventReadOnlyRoleUpdateFailed)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "update_failed",
                                        "event":       string(events.EventReadOnlyRoleUpdateFailed),
                                        "object_name": expectedRole.Name,
                                        "object_kind": metricKindRole,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, expectedRole, nil, events.EventReadOnlyRoleUpdated)
                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "updated",
                                "event":       string(events.EventReadOnlyRoleUpdated),
                                "object_name": expectedRole.Name,
                                "object_kind": metricKindRole,
                        },
                )</span>
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// ReconcileReadWriteRole reconciles the read write role binding for project users
func (a *AccessControlService) ReconcileReadWriteRole(ctx context.Context,
        namespace string, owner client.Object) (ctrl.Result, error) <span class="cov0" title="0">{
        namespacedName := client.ObjectKey{
                Namespace: namespace,
                Name:      roleSharedReadWrite,
        }
        completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(owner), owner.GetName())
        labels := util.GetOwnerLabel(completeResourceName)
        expectedRole := &amp;rbacv1.Role{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      namespacedName.Name,
                        Namespace: namespacedName.Namespace,
                        Labels:    labels,
                },
                Rules: a.ruleProvider.ReadWriteRoleRules(),
        }
        actualRole := &amp;rbacv1.Role{}
        found, err := util.GetResourceIfExist(ctx, namespacedName, actualRole)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        //Load Event Recorder with project name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).WithProject(util.GetProjectName(namespace)).WithNamespace(namespace)

        // Load metrics with project name and namespace
        a.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace)

        if !found </span><span class="cov0" title="0">{
                err = util.CreateResource(ctx, expectedRole)
                if err != nil </span><span class="cov0" title="0">{
                        util.RecordEvent(ctx, eventRecorder, expectedRole, nil, events.EventReadWriteRoleCreationFailed)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "creation_failed",
                                        "event":       string(events.EventReadWriteRoleCreationFailed),
                                        "object_name": expectedRole.Name,
                                        "object_kind": metricKindRole,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, expectedRole, nil, events.EventReadWriteRoleCreated)
                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "created",
                                "event":       string(events.EventReadWriteRoleCreated),
                                "object_name": expectedRole.Name,
                                "object_kind": metricKindRole,
                        },
                )</span>
        } else<span class="cov0" title="0"> {
                err = util.UpdateResource(ctx, expectedRole)
                if err != nil </span><span class="cov0" title="0">{
                        util.RecordEvent(ctx, eventRecorder, expectedRole, nil, events.EventReadWriteRoleUpdateFailed)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "update_failed",
                                        "event":       string(events.EventReadWriteRoleUpdateFailed),
                                        "object_name": expectedRole.Name,
                                        "object_kind": metricKindRole,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, expectedRole, nil, events.EventReadWriteRoleUpdated)
                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "updated",
                                "event":       string(events.EventReadWriteRoleUpdated),
                                "object_name": expectedRole.Name,
                                "object_kind": metricKindRole,
                        },
                )</span>
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// ReconcileReadOnlyUserServiceAccountAndRoleBindings reconciles the service account and role bindings for read only users
func (a *AccessControlService) ReconcileReadOnlyUserServiceAccountAndRoleBindings(ctx context.Context, namespace string,
        names []string, owner client.Object) (ctrl.Result, error) <span class="cov0" title="0">{
        // Cleanup obsolete service accounts and role binding
        if shouldReturn, reconResult, reconErr := util.IsReconciled(a.cleanupObsoleteServiceAccountsAndRoleBindings(ctx,
                namespace, names, ServiceAccountReadOnlyUser, RoleBindingReadOnlyUser, AccessTypeReadOnly, owner)); shouldReturn </span><span class="cov0" title="0">{
                return reconResult, reconErr
        }</span>
        // Create or update required service accounts and role bindings
        <span class="cov0" title="0">if shouldReturn, reconResult, reconErr := util.IsReconciled(a.createOrUpdateServiceAccountsAndRoleBindings(ctx, namespace,
                names, ServiceAccountReadOnlyUser, RoleBindingReadOnlyUser, AccessTypeReadOnly, roleSharedReadOnly, owner)); shouldReturn </span><span class="cov0" title="0">{
                return reconResult, reconErr
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// ReconcileReadWriteUserServiceAccountAndRoleBindings reconciles the service account and role bindings for read write users
func (a *AccessControlService) ReconcileReadWriteUserServiceAccountAndRoleBindings(ctx context.Context,
        namespace string, names []string, owner client.Object) (ctrl.Result, error) <span class="cov0" title="0">{
        // Cleanup obsolete service accounts and role binding
        if shouldReturn, reconResult, reconErr := util.IsReconciled(a.cleanupObsoleteServiceAccountsAndRoleBindings(ctx, namespace, names,
                ServiceAccountReadWriteUser, RoleBindingReadWriteUser, AccessTypeReadWrite, owner)); shouldReturn </span><span class="cov0" title="0">{
                return reconResult, reconErr
        }</span>

        // Create or update required service accounts and role bindings
        <span class="cov0" title="0">if shouldReturn, reconResult, reconErr := util.IsReconciled(a.createOrUpdateServiceAccountsAndRoleBindings(ctx, namespace, names,
                ServiceAccountReadWriteUser, RoleBindingReadWriteUser, AccessTypeReadWrite, roleSharedReadWrite, owner)); shouldReturn </span><span class="cov0" title="0">{
                return reconResult, reconErr
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// ReconcileWorkerClusterServiceAccountAndRoleBindings reconciles the service account and role bindings for worker cluster
func (a *AccessControlService) ReconcileWorkerClusterServiceAccountAndRoleBindings(ctx context.Context, clusterName,
        namespace string, owner client.Object) (ctrl.Result, error) <span class="cov0" title="0">{
        names := []string{clusterName}
        if shouldReturn, reconResult, reconErr := util.IsReconciled(a.cleanupObsoleteServiceAccountsAndRoleBindings(ctx,
                namespace, names, ServiceAccountWorkerCluster, RoleBindingWorkerCluster, AccessTypeClusterReadWrite, owner)); shouldReturn </span><span class="cov0" title="0">{
                return reconResult, reconErr
        }</span>
        // Create or update required service accounts and role bindings
        <span class="cov0" title="0">if shouldReturn, reconResult, reconErr := util.IsReconciled(a.createOrUpdateServiceAccountsAndRoleBindings(ctx,
                namespace, names, ServiceAccountWorkerCluster, RoleBindingWorkerCluster, AccessTypeClusterReadWrite, roleWorkerCluster, owner)); shouldReturn </span><span class="cov0" title="0">{
                return reconResult, reconErr
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// RemoveWorkerClusterServiceAccountAndRoleBindings remove the service account and role bindings for worker cluster
func (a *AccessControlService) RemoveWorkerClusterServiceAccountAndRoleBindings(ctx context.Context, clusterName,
        namespace string, owner client.Object) (ctrl.Result, error) <span class="cov0" title="0">{
        names := []string{clusterName}
        if shouldReturn, reconResult, reconErr := util.IsReconciled(a.removeServiceAccountsAndRoleBindingsByLabel(ctx,
                namespace, names, owner)); shouldReturn </span><span class="cov0" title="0">{
                return reconResult, reconErr
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// createOrUpdateServiceAccountsAndRoleBindings creates or updates service accounts and role bindings for the given project names
func (a *AccessControlService) createOrUpdateServiceAccountsAndRoleBindings(ctx context.Context, namespace string,
        names []string, svcAccNamePattern string, roleBindingNamePatterns string, accessType string, roleName string, owner client.Object) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := util.CtxLogger(ctx)
        //Load Event Recorder with project name and namespace
        eventRecorder := util.CtxEventRecorder(ctx).WithProject(util.GetProjectName(namespace)).WithNamespace(namespace)

        // Load metrics with project name and namespace
        a.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace)

        for _, name := range names </span><span class="cov0" title="0">{
                // Create or update service account
                serviceAccountNamespacedName := client.ObjectKey{
                        Namespace: namespace,
                        Name:      fmt.Sprintf(svcAccNamePattern, strings.ToLower(name)),
                }
                completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(owner), owner.GetName())
                labels := util.GetOwnerLabel(completeResourceName)
                expectedServiceAccount := &amp;corev1.ServiceAccount{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      serviceAccountNamespacedName.Name,
                                Namespace: serviceAccountNamespacedName.Namespace,
                                Labels:    labels,
                                Annotations: map[string]string{
                                        fmt.Sprintf("%s/%s", annotationKubeSliceControllers, AccessTypeAnnotationLabel): accessType,
                                },
                        },
                        Secrets: []corev1.ObjectReference{
                                {
                                        Name: serviceAccountNamespacedName.Name,
                                },
                        },
                }
                actualServiceAccount := &amp;corev1.ServiceAccount{}
                foundSa, err := util.GetResourceIfExist(ctx, serviceAccountNamespacedName, actualServiceAccount)
                if err != nil </span><span class="cov0" title="0">{
                        logger.With(zap.Error(err)).Errorf("Couldnt fetch serviceaccoubt")
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">if !foundSa </span><span class="cov0" title="0">{
                        // create service account
                        err = util.CreateResource(ctx, expectedServiceAccount)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.With(zap.Error(err)).Errorf("Couldnt create serviceaccount")
                                util.RecordEvent(ctx, eventRecorder, expectedServiceAccount, nil, events.EventServiceAccountCreationFailed)
                                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "creation_failed",
                                                "event":       string(events.EventServiceAccountCreationFailed),
                                                "object_name": expectedServiceAccount.Name,
                                                "object_kind": metricKindServiceAccount,
                                        },
                                )
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, expectedServiceAccount, nil, events.EventServiceAccountCreated)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "created",
                                        "event":       string(events.EventServiceAccountCreated),
                                        "object_name": expectedServiceAccount.Name,
                                        "object_kind": metricKindServiceAccount,
                                },
                        )
                        // create secret for the service account
                        secret := corev1.Secret{
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:        expectedServiceAccount.Name,
                                        Annotations: map[string]string{"kubernetes.io/service-account.name": expectedServiceAccount.Name},
                                        Namespace:   namespace,
                                },
                                Type: "kubernetes.io/service-account-token",
                        }
                        err = util.CreateResource(ctx, &amp;secret)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.With(zap.Error(err)).Errorf("Couldnt create secret")
                                util.RecordEvent(ctx, eventRecorder, &amp;secret, nil, events.EventServiceAccountSecretCreationFailed)
                                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "creation_failed",
                                                "event":       string(events.EventServiceAccountSecretCreationFailed),
                                                "object_name": secret.Name,
                                                "object_kind": metricKindSecret,
                                        },
                                )
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;secret, nil, events.EventServiceAccountSecretCreated)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "created",
                                        "event":       string(events.EventServiceAccountSecretCreated),
                                        "object_name": secret.Name,
                                        "object_kind": metricKindSecret,
                                },
                        )</span>
                }
        }
        <span class="cov0" title="0">for _, name := range names </span><span class="cov0" title="0">{
                // Create or update role binding
                roleBindingNamespacedName := client.ObjectKey{
                        Namespace: namespace,
                        Name:      fmt.Sprintf(roleBindingNamePatterns, strings.ToLower(name)),
                }
                completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(owner), owner.GetName())
                labels := util.GetOwnerLabel(completeResourceName)
                expectedRoleBinding := &amp;rbacv1.RoleBinding{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      roleBindingNamespacedName.Name,
                                Namespace: roleBindingNamespacedName.Namespace,
                                Labels:    labels,
                                Annotations: map[string]string{
                                        fmt.Sprintf("%s/%s", annotationKubeSliceControllers, AccessTypeAnnotationLabel): accessType,
                                },
                        },
                        RoleRef: rbacv1.RoleRef{
                                Name: roleName,
                                Kind: "Role",
                        },
                        Subjects: []rbacv1.Subject{
                                {
                                        Name:      fmt.Sprintf(svcAccNamePattern, strings.ToLower(name)),
                                        Namespace: namespace,
                                        Kind:      "ServiceAccount",
                                },
                        },
                }
                actualRoleBinding := &amp;rbacv1.RoleBinding{}
                foundRb, err := util.GetResourceIfExist(ctx, roleBindingNamespacedName, actualRoleBinding)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">if !foundRb </span><span class="cov0" title="0">{
                        err = util.CreateResource(ctx, expectedRoleBinding)
                        if err != nil </span><span class="cov0" title="0">{
                                util.RecordEvent(ctx, eventRecorder, expectedRoleBinding, nil, events.EventDefaultRoleBindingCreationFailed)
                                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "creation_failed",
                                                "event":       string(events.EventDefaultRoleBindingCreationFailed),
                                                "object_name": expectedRoleBinding.Name,
                                                "object_kind": metricKindRoleBinding,
                                        },
                                )
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, expectedRoleBinding, nil, events.EventDefaultRoleBindingCreated)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "created",
                                        "event":       string(events.EventDefaultRoleBindingCreated),
                                        "object_name": expectedRoleBinding.Name,
                                        "object_kind": metricKindRoleBinding,
                                },
                        )</span>
                } else<span class="cov0" title="0"> {
                        err = util.UpdateResource(ctx, expectedRoleBinding)
                        if err != nil </span><span class="cov0" title="0">{
                                util.RecordEvent(ctx, eventRecorder, expectedRoleBinding, nil, events.EventDefaultRoleBindingUpdateFailed)
                                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "update_failed",
                                                "event":       string(events.EventDefaultRoleBindingUpdateFailed),
                                                "object_name": expectedRoleBinding.Name,
                                                "object_kind": metricKindRoleBinding,
                                        },
                                )
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">if !reflect.DeepEqual(expectedRoleBinding.RoleRef, actualRoleBinding.RoleRef) ||
                                !reflect.DeepEqual(expectedRoleBinding.Subjects, actualRoleBinding.Subjects) </span><span class="cov0" title="0">{
                                util.RecordEvent(ctx, eventRecorder, expectedRoleBinding, nil, events.EventDefaultRoleBindingUpdated)
                                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "updated",
                                                "event":       string(events.EventDefaultRoleBindingUpdated),
                                                "object_name": expectedRoleBinding.Name,
                                                "object_kind": metricKindRoleBinding,
                                        },
                                )
                        }</span>
                }
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// cleanupObsoleteServiceAccountsAndRoleBindings deletes service accounts and role bindings for the given project names
func (a *AccessControlService) cleanupObsoleteServiceAccountsAndRoleBindings(ctx context.Context, namespace string,
        names []string, svcAccNamePattern string, roleBindingNamePatterns string, accessType string, owner client.Object) (ctrl.Result, error) <span class="cov0" title="0">{
        // Fetch existing RoleBindings and assume them for deletion
        activeRoleBindings := map[string]activeRoleBinding{}
        roleBindings := &amp;rbacv1.RoleBindingList{}

        completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(owner), owner.GetName())
        labels := util.GetOwnerLabel(completeResourceName)
        err := util.ListResources(ctx, roleBindings, client.MatchingLabels(labels), client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                util.CtxLogger(ctx).With(zap.Error(err)).Errorf("Could not list resources")
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if roleBindings.Items != nil &amp;&amp; len(roleBindings.Items) &gt; 0 </span><span class="cov0" title="0">{
                for _, role := range roleBindings.Items </span><span class="cov0" title="0">{
                        if role.Annotations[fmt.Sprintf("%s/%s", annotationKubeSliceControllers, AccessTypeAnnotationLabel)] == accessType </span><span class="cov0" title="0">{
                                activeRoleBindings[role.Name] = activeRoleBinding{active: false, object: role}
                        }</span>
                }
        }

        // Fetch existing ServiceAccounts and assume them for deletions
        <span class="cov0" title="0">activeServiceAccounts := map[string]activeServiceAccount{}
        serviceAccounts := &amp;corev1.ServiceAccountList{}
        err = util.ListResources(ctx, serviceAccounts, client.MatchingLabels(labels), client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if serviceAccounts != nil &amp;&amp; len(serviceAccounts.Items) &gt; 0 </span><span class="cov0" title="0">{
                for _, sa := range serviceAccounts.Items </span><span class="cov0" title="0">{
                        if sa.Annotations[fmt.Sprintf("%s/%s", annotationKubeSliceControllers, AccessTypeAnnotationLabel)] == accessType </span><span class="cov0" title="0">{
                                activeServiceAccounts[sa.Name] = activeServiceAccount{active: false, object: sa}
                        }</span>
                }
        }

        // Mark current names as active
        <span class="cov0" title="0">for _, name := range names </span><span class="cov0" title="0">{
                activeServiceAccounts[fmt.Sprintf(svcAccNamePattern, strings.ToLower(name))] = activeServiceAccount{active: true}
                activeRoleBindings[fmt.Sprintf(roleBindingNamePatterns, strings.ToLower(name))] = activeRoleBinding{active: true}
        }</span>

        //Load Event Recorder with project name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).WithProject(util.GetProjectName(namespace)).WithNamespace(namespace)

        // Load metrics with project name and namespace
        a.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace)

        // Delete additional role bindings
        for _, activeObj := range activeRoleBindings </span><span class="cov0" title="0">{
                if !activeObj.active </span><span class="cov0" title="0">{
                        err = util.DeleteResource(ctx, &amp;activeObj.object)
                        if err != nil </span><span class="cov0" title="0">{
                                util.RecordEvent(ctx, eventRecorder, &amp;activeObj.object, nil, events.EventInactiveRoleBindingDeletionFailed)
                                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deletion_failed",
                                                "event":       string(events.EventInactiveRoleBindingDeletionFailed),
                                                "object_name": activeObj.object.Name,
                                                "object_kind": metricKindRoleBinding,
                                        },
                                )
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;activeObj.object, nil, events.EventInactiveRoleBindingDeleted)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deleted",
                                        "event":       string(events.EventInactiveRoleBindingDeleted),
                                        "object_name": activeObj.object.Name,
                                        "object_kind": metricKindRoleBinding,
                                },
                        )</span>
                }
        }

        // Delete additional service accounts
        <span class="cov0" title="0">for _, activeObj := range activeServiceAccounts </span><span class="cov0" title="0">{
                if !activeObj.active </span><span class="cov0" title="0">{
                        err = util.DeleteResource(ctx, &amp;activeObj.object)
                        if err != nil </span><span class="cov0" title="0">{
                                util.RecordEvent(ctx, eventRecorder, &amp;activeObj.object, nil, events.EventInactiveServiceAccountDeletionFailed)
                                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deletion_failed",
                                                "event":       string(events.EventInactiveServiceAccountDeletionFailed),
                                                "object_name": activeObj.object.Name,
                                                "object_kind": metricKindServiceAccount,
                                        },
                                )
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;activeObj.object, nil, events.EventInactiveServiceAccountDeleted)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deleted",
                                        "event":       string(events.EventInactiveServiceAccountDeleted),
                                        "object_name": activeObj.object.Name,
                                        "object_kind": metricKindServiceAccount,
                                },
                        )</span>
                }
        }
        <span class="cov0" title="0">return ctrl.Result{}, err</span>
}

// removeServiceAccountsAndRoleBindingsByLabel removes service accounts and role bindings by label
func (a *AccessControlService) removeServiceAccountsAndRoleBindingsByLabel(ctx context.Context, namespace string,
        names []string, owner client.Object) (ctrl.Result, error) <span class="cov0" title="0">{
        // Fetch existing RoleBindings and assume them for deletion
        roleBindings := &amp;rbacv1.RoleBindingList{}
        completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(owner), owner.GetName())
        labels := util.GetOwnerLabel(completeResourceName)
        err := util.ListResources(ctx, roleBindings, client.MatchingLabels(labels), client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                util.CtxLogger(ctx).With(zap.Error(err)).Errorf("Could not list resources")
                return ctrl.Result{}, err
        }</span>

        // Fetch existing ServiceAccounts and assume them for deletions
        <span class="cov0" title="0">serviceAccounts := &amp;corev1.ServiceAccountList{}
        err = util.ListResources(ctx, serviceAccounts, client.MatchingLabels(labels), client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        //Load Event Recorder with project name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).WithProject(util.GetProjectName(namespace)).WithNamespace(namespace)

        // Load metrics with project name and namespace
        a.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace)

        // Delete role bindings
        if len(roleBindings.Items) &gt; 0 </span><span class="cov0" title="0">{
                for _, rb := range roleBindings.Items </span><span class="cov0" title="0">{
                        err = util.DeleteResource(ctx, &amp;rb)
                        if err != nil </span><span class="cov0" title="0">{
                                util.RecordEvent(ctx, eventRecorder, &amp;rb, nil, events.EventDefaultRoleBindingDeletionFailed)
                                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deletion_failed",
                                                "event":       string(events.EventDefaultRoleBindingDeletionFailed),
                                                "object_name": rb.Name,
                                                "object_kind": metricKindRoleBinding,
                                        },
                                )
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;rb, nil, events.EventDefaultRoleBindingDeleted)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deleted",
                                        "event":       string(events.EventDefaultRoleBindingDeleted),
                                        "object_name": rb.Name,
                                        "object_kind": metricKindRoleBinding,
                                },
                        )</span>
                }
        }

        // Delete service accounts
        <span class="cov0" title="0">if len(serviceAccounts.Items) &gt; 0 </span><span class="cov0" title="0">{
                for _, sa := range serviceAccounts.Items </span><span class="cov0" title="0">{
                        err = util.DeleteResource(ctx, &amp;sa)
                        if err != nil </span><span class="cov0" title="0">{
                                util.RecordEvent(ctx, eventRecorder, &amp;sa, nil, events.EventServiceAccountDeletionFailed)
                                a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deletion_failed",
                                                "event":       string(events.EventServiceAccountDeletionFailed),
                                                "object_name": sa.Name,
                                                "object_kind": metricKindServiceAccount,
                                        },
                                )
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;sa, nil, events.EventServiceAccountDeleted)
                        a.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deleted",
                                        "event":       string(events.EventServiceAccountDeleted),
                                        "object_name": sa.Name,
                                        "object_kind": metricKindServiceAccount,
                                },
                        )</span>
                }
        }
        <span class="cov0" title="0">return ctrl.Result{}, err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import "github.com/kubeslice/kubeslice-controller/metrics"

type Services struct {
        ProjectService                    IProjectService
        ClusterService                    IClusterService
        SliceConfigService                ISliceConfigService
        ServiceExportConfigService        IServiceExportConfigService
        WorkerSliceConfigService          IWorkerSliceConfigService
        WorkerSliceGatewayService         IWorkerSliceGatewayService
        WorkerServiceImportService        IWorkerServiceImportService
        SliceQoSConfigService             ISliceQoSConfigService
        WorkerSliceGatewayRecyclerService IWorkerSliceGatewayRecyclerService
        VpnKeyRotationService             IVpnKeyRotationService
}

// bootstrapping Services
func WithServices(
        wscs IWorkerSliceConfigService,
        ps IProjectService,
        cs IClusterService,
        scs ISliceConfigService,
        secs IServiceExportConfigService,
        wsgs IWorkerSliceGatewayService,
        wsis IWorkerServiceImportService,
        sqcs ISliceQoSConfigService,
        wsgrs IWorkerSliceGatewayRecyclerService,
        vpn IVpnKeyRotationService,
) *Services <span class="cov0" title="0">{
        return &amp;Services{
                ProjectService:                    ps,
                ClusterService:                    cs,
                SliceConfigService:                scs,
                ServiceExportConfigService:        secs,
                WorkerSliceConfigService:          wscs,
                WorkerSliceGatewayService:         wsgs,
                WorkerServiceImportService:        wsis,
                SliceQoSConfigService:             sqcs,
                WorkerSliceGatewayRecyclerService: wsgrs,
                VpnKeyRotationService:             vpn,
        }
}</span>

// bootstrapping Project services
func WithProjectService(
        ns INamespaceService,
        acs IAccessControlService,
        c IClusterService,
        sc ISliceConfigService,
        se IServiceExportConfigService,
        q ISliceQoSConfigService,
        mf metrics.IMetricRecorder,
) IProjectService <span class="cov0" title="0">{
        return &amp;ProjectService{
                ns:  ns,
                acs: acs,
                c:   c,
                sc:  sc,
                se:  se,
                q:   q,
                mf:  mf,
        }
}</span>

// bootstrapping cluster service
func WithClusterService(
        ns INamespaceService,
        acs IAccessControlService,
        sgws IWorkerSliceGatewayService,
        mf metrics.IMetricRecorder,
) IClusterService <span class="cov0" title="0">{
        return &amp;ClusterService{
                ns:   ns,
                acs:  acs,
                sgws: sgws,
                mf:   mf,
        }
}</span>

// bootstrapping slice config service
func WithSliceConfigService(
        ns INamespaceService,
        acs IAccessControlService,
        sgs IWorkerSliceGatewayService,
        ms IWorkerSliceConfigService,
        si IWorkerServiceImportService,
        se IServiceExportConfigService,
        wsgrs IWorkerSliceGatewayRecyclerService,
        mf metrics.IMetricRecorder,
        vpn IVpnKeyRotationService,
) ISliceConfigService <span class="cov0" title="0">{
        return &amp;SliceConfigService{
                ns:    ns,
                acs:   acs,
                sgs:   sgs,
                ms:    ms,
                si:    si,
                se:    se,
                wsgrs: wsgrs,
                mf:    mf,
                vpn:   vpn,
        }
}</span>

// bootstrapping service export config service
func WithServiceExportConfigService(ses IWorkerServiceImportService,
        mf metrics.IMetricRecorder) IServiceExportConfigService <span class="cov0" title="0">{
        return &amp;ServiceExportConfigService{
                ses: ses,
                mf:  mf,
        }
}</span>

// bootstrapping namespace service
func WithNameSpaceService(mf metrics.IMetricRecorder) INamespaceService <span class="cov0" title="0">{
        return &amp;NamespaceService{
                mf: mf,
        }
}</span>

// bootstrapping accesscontrol service
func WithAccessControlService(ruleProvider IAccessControlRuleProvider, mf metrics.IMetricRecorder) IAccessControlService <span class="cov0" title="0">{
        return &amp;AccessControlService{
                ruleProvider: ruleProvider,
                mf:           mf,
        }
}</span>

// bootstrapping secret service
func WithSecretService(mf metrics.IMetricRecorder) ISecretService <span class="cov0" title="0">{
        return &amp;SecretService{
                mf: mf,
        }
}</span>

// bootstrapping slice gateway service
func WithWorkerSliceGatewayService(
        js IJobService,
        sscs IWorkerSliceConfigService,
        sc ISecretService,
        mf metrics.IMetricRecorder,
) IWorkerSliceGatewayService <span class="cov0" title="0">{
        return &amp;WorkerSliceGatewayService{
                js:   js,
                sscs: sscs,
                sc:   sc,
                mf:   mf,
        }
}</span>

// WithWorkerSliceGatewayRecyclerService bootstraps slice gateway_recycler service
func WithWorkerSliceGatewayRecyclerService() IWorkerSliceGatewayRecyclerService <span class="cov0" title="0">{
        return &amp;WorkerSliceGatewayRecyclerService{}
}</span>

// bootstrapping job service
func WithJobService() IJobService <span class="cov0" title="0">{
        return &amp;JobService{}
}</span>

func WithAccessControlRuleProvider() IAccessControlRuleProvider <span class="cov0" title="0">{
        return &amp;AccessControlRuleProvider{}
}</span>

// bootstrapping worker slice config service
func WithWorkerSliceConfigService(mf metrics.IMetricRecorder) IWorkerSliceConfigService <span class="cov0" title="0">{
        return &amp;WorkerSliceConfigService{
                mf: mf,
        }
}</span>

// bootstrapping worker service import service
func WithWorkerServiceImportService(mf metrics.IMetricRecorder) IWorkerServiceImportService <span class="cov0" title="0">{
        return &amp;WorkerServiceImportService{
                mf: mf,
        }
}</span>

// bootstrapping slice qos config service
func WithSliceQoSConfigService(wsc IWorkerSliceConfigService, mf metrics.IMetricRecorder) ISliceQoSConfigService <span class="cov0" title="0">{
        return &amp;SliceQoSConfigService{
                wsc: wsc,
                mf:  mf,
        }
}</span>

func WithMetricsRecorder() metrics.IMetricRecorder <span class="cov0" title="0">{
        return &amp;metrics.MetricRecorder{}
}</span>

// bootstrapping Vpn Key Rotation service
func WithVpnKeyRotationService(w IWorkerSliceGatewayService, ws IWorkerSliceConfigService) IVpnKeyRotationService <span class="cov0" title="0">{
        return &amp;VpnKeyRotationService{
                wsgs: w,
                wscs: ws,
        }
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"
        "time"

        "github.com/kubeslice/kubeslice-controller/metrics"

        "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/events"
        "github.com/kubeslice/kubeslice-controller/util"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type IClusterService interface {
        ReconcileCluster(ctx context.Context, req ctrl.Request) (ctrl.Result, error)
        DeleteClusters(ctx context.Context, namespace string) (ctrl.Result, error)
}

// ClusterService struct implements different service interfaces
type ClusterService struct {
        ns   INamespaceService
        acs  IAccessControlService
        sgws IWorkerSliceGatewayService
        mf   metrics.IMetricRecorder
}

// ReconcileCluster is function to reconcile cluster
func (c *ClusterService) ReconcileCluster(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        // Step 0: Get cluster resource
        logger := util.CtxLogger(ctx)
        logger.Infof("Starting Reconcilation of Cluster %v", req.NamespacedName)
        cluster := &amp;controllerv1alpha1.Cluster{}
        found, err := util.GetResourceIfExist(ctx, req.NamespacedName, cluster)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                logger.Infof("cluster %v not found, returning from reconciler loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>
        // Load Event Recorder with project name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).WithProject(util.GetProjectName(cluster.Namespace)).WithNamespace(cluster.Namespace)

        // Load metrics with project name and namespace
        c.mf.WithProject(util.GetProjectName(cluster.Namespace)).
                WithNamespace(cluster.Namespace)

        // Step 0: check if cluster is in project namespace
        projectNs := &amp;corev1.Namespace{}
        found, err = util.GetResourceIfExist(ctx, client.ObjectKey{
                Name: req.Namespace,
        }, projectNs)
        if !found || !c.checkForProjectNamespace(projectNs) </span><span class="cov0" title="0">{
                logger.Infof("Created Cluster %v is not in project namespace. Returning from reconciliation loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>
        // Step 1: Finalizers
        <span class="cov0" title="0">if cluster.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                logger.Debugf("Not deleting")
                if !util.ContainsString(cluster.GetFinalizers(), ClusterFinalizer) </span><span class="cov0" title="0">{
                        if shouldRequeue, result, reconErr := util.IsReconciled(util.AddFinalizer(ctx, cluster, ClusterFinalizer)); shouldRequeue </span><span class="cov0" title="0">{
                                return result, reconErr
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                logger.Debug("starting delete for cluster", req.NamespacedName)
                if shouldRequeue, result, reconErr := util.IsReconciled(DeregisterClusterFromDefaultSlice(ctx, req, logger, req.Name)); shouldRequeue </span><span class="cov0" title="0">{
                        return result, reconErr
                }</span>

                //  Check if ClusterDeregisterFinalizer is added by worker cluster.
                <span class="cov0" title="0">if !util.ContainsString(cluster.GetFinalizers(), ClusterDeregisterFinalizer) </span><span class="cov0" title="0">{
                        if shouldRequeue, result, reconErr := util.IsReconciled(c.cleanUpClusterResources(ctx, req, cluster)); shouldRequeue </span><span class="cov0" title="0">{
                                return result, reconErr
                        }</span>

                        <span class="cov0" title="0">if shouldRequeue, result, reconErr := util.IsReconciled(util.RemoveFinalizer(ctx, cluster, ClusterFinalizer)); shouldRequeue </span><span class="cov0" title="0">{
                                // Register an event for cluster deletion fail
                                util.RecordEvent(ctx, eventRecorder, cluster, nil, events.EventClusterDeletionFailed)
                                c.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deletion_failed",
                                                "event":       string(events.EventClusterDeletionFailed),
                                                "object_name": cluster.Name,
                                                "object_kind": metricKindCluster,
                                        },
                                )
                                return result, reconErr
                        }</span>
                        // Register an event for cluster deletion
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, cluster, nil, events.EventClusterDeleted)
                        c.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deleted",
                                        "event":       string(events.EventClusterDeleted),
                                        "object_name": cluster.Name,
                                        "object_kind": metricKindCluster,
                                },
                        )
                        return ctrl.Result{}, err</span>
                } else<span class="cov0" title="0"> {
                        // If ClusterDeregisterFinalizer is added by worker cluster, then wait for 10 mins for worker cluster to remove it.
                        // If not removed even after 10 mins, remove it.
                        // This is to handle the case where worker cluster is not reachable.
                        // For the condtion of Deregister success, the finalizer will be removed by the worker cluster after waiting for a few seconds.
                        // This is to ensure an event is registered for successful deregistration.
                        // For the condition of Deregister failure, the finalizer will be removed by the worker cluster after waiting for 10 mins.
                        // An event will also be registered for deregistration failure.

                        // Wait until ClusterDeregisterFinalizer is removed by the worker cluster. If not removed even after 10 mins, remove it.
                        if cluster.ObjectMeta.DeletionTimestamp.Add(10 * time.Minute).Before(time.Now()) </span><span class="cov0" title="0">{
                                if shouldRequeue, result, reconErr := util.IsReconciled(util.RemoveFinalizer(ctx, cluster, ClusterDeregisterFinalizer)); shouldRequeue </span><span class="cov0" title="0">{
                                        // Register an event for cluster deletion fail
                                        util.RecordEvent(ctx, eventRecorder, cluster, nil, events.EventClusterDeletionFailed)
                                        c.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                                map[string]string{
                                                        "action":      "deletion_failed",
                                                        "event":       string(events.EventClusterDeletionFailed),
                                                        "object_name": cluster.Name,
                                                        "object_kind": metricKindCluster,
                                                },
                                        )
                                        return result, reconErr
                                }</span>
                                <span class="cov0" title="0">logger.Info("Timed out waiting for worker-operator chart uninstallation")
                                // Event for worker-operator chart uninstallation timeout [ClusterDeregisterTimeout]
                                util.RecordEvent(ctx, eventRecorder, cluster, nil, events.EventClusterDeregisterTimeout)
                                c.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deregister_timeout",
                                                "event":       string(events.EventClusterDeregisterTimeout),
                                                "object_name": cluster.Name,
                                                "object_kind": metricKindCluster,
                                        },
                                )
                                return ctrl.Result{Requeue: true}, err</span>
                        } else<span class="cov0" title="0"> {
                                if cluster.Status.RegistrationStatus == v1alpha1.RegistrationStatusDeregisterFailed </span><span class="cov0" title="0">{
                                        logger.Info("Worker-operator charts failed to uninstall")
                                        // Event for worker-operator chart uninstallation failure [ClusterDeregisterFailed]
                                        util.RecordEvent(ctx, eventRecorder, cluster, nil, events.EventClusterDeregisterFailed)
                                        c.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                                map[string]string{
                                                        "action":      "deregister_failed",
                                                        "event":       string(events.EventClusterDeregisterFailed),
                                                        "object_name": cluster.Name,
                                                        "object_kind": metricKindCluster,
                                                },
                                        )
                                        return ctrl.Result{}, nil
                                }</span> else<span class="cov0" title="0"> if cluster.Status.RegistrationStatus == v1alpha1.RegistrationStatusDeregistered </span><span class="cov0" title="0">{
                                        logger.Info("Worker-operator charts uninstalled successfully")
                                        // Event for worker-operator chart uninstallation success [ClusterDeregistered]
                                        util.RecordEvent(ctx, eventRecorder, cluster, nil, events.EventClusterDeregistered)
                                        c.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                                map[string]string{
                                                        "action":      "deregistered",
                                                        "event":       string(events.EventClusterDeregistered),
                                                        "object_name": cluster.Name,
                                                        "object_kind": metricKindCluster,
                                                },
                                        )
                                        return ctrl.Result{}, nil
                                }</span> else<span class="cov0" title="0"> if !cluster.Status.IsDeregisterInProgress </span><span class="cov0" title="0">{
                                        logger.Info("Waiting for worker-operator charts to uninstall")
                                        // setting IsDeregisterInProgress to true to avoid requeuing
                                        cluster.Status.IsDeregisterInProgress = true
                                        util.UpdateStatus(ctx, cluster)
                                        // Event for worker-operator chart uninstallation in progress [ClusterDeregistrationInProgress]
                                        util.RecordEvent(ctx, eventRecorder, cluster, nil, events.EventClusterDeregistrationInProgress)
                                        c.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                                map[string]string{
                                                        "action":      "deregister_in_progress",
                                                        "event":       string(events.EventClusterDeregistrationInProgress),
                                                        "object_name": cluster.Name,
                                                        "object_kind": metricKindCluster,
                                                },
                                        )
                                        // requeuing after ~10 mins
                                        return ctrl.Result{RequeueAfter: 610 * time.Second}, nil
                                }</span> else<span class="cov0" title="0"> {
                                        return ctrl.Result{}, nil
                                }</span>
                        }
                }
        }

        // Step 2: Apply ProjectNS labels/annotations
        <span class="cov0" title="0">isUpdateRequired := false
        if !util.CompareLabels(cluster.Labels, util.FilterLabelsAndAnnotations(projectNs.GetLabels())) </span><span class="cov0" title="0">{
                if cluster.Labels == nil </span><span class="cov0" title="0">{
                        cluster.Labels = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for key, value := range util.FilterLabelsAndAnnotations(projectNs.GetLabels()) </span><span class="cov0" title="0">{
                        cluster.Labels[key] = value
                }</span>
                <span class="cov0" title="0">isUpdateRequired = true</span>
        }
        <span class="cov0" title="0">if !util.CompareAnnotations(cluster.Annotations, util.FilterLabelsAndAnnotations(projectNs.GetAnnotations())) </span><span class="cov0" title="0">{
                if cluster.Annotations == nil </span><span class="cov0" title="0">{
                        cluster.Annotations = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for key, value := range util.FilterLabelsAndAnnotations(projectNs.GetAnnotations()) </span><span class="cov0" title="0">{
                        cluster.Annotations[key] = value
                }</span>
                <span class="cov0" title="0">isUpdateRequired = true</span>
        }
        <span class="cov0" title="0">if isUpdateRequired </span><span class="cov0" title="0">{
                err := util.UpdateResource(ctx, cluster)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        }

        // Step 3: Get ServiceAccount
        <span class="cov0" title="0">serviceAccount := &amp;corev1.ServiceAccount{}
        _, err = util.GetResourceIfExist(ctx, types.NamespacedName{Name: fmt.Sprintf(ServiceAccountWorkerCluster, cluster.Name), Namespace: req.Namespace}, serviceAccount)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        // Step 3: Create ServiceAccount &amp; Reconcile
        <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(c.acs.ReconcileWorkerClusterServiceAccountAndRoleBindings(ctx, req.Name, req.Namespace, cluster)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>

        <span class="cov0" title="0">if serviceAccount.Secrets == nil </span><span class="cov0" title="0">{
                logger.Infof("Service Account Token not populated. Requeuing")
                return ctrl.Result{Requeue: true, RequeueAfter: RequeueTime}, nil
        }</span>
        // Step 4: Get Secret
        <span class="cov0" title="0">secret := corev1.Secret{}
        serviceAccountSecretNamespacedName := types.NamespacedName{
                Namespace: req.Namespace,
                Name:      serviceAccount.Secrets[0].Name,
        }
        found, err = util.GetResourceIfExist(ctx, serviceAccountSecretNamespacedName, &amp;secret)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                err = fmt.Errorf("could not find secret")
                logger.Errorf(err.Error())
                return ctrl.Result{}, err
        }</span>

        // Step 5: Update Cluster with Secret
        <span class="cov0" title="0">cluster.Status.SecretName = secret.Name
        err = util.UpdateStatus(ctx, cluster)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if secret.Data == nil </span><span class="cov0" title="0">{
                secret.Data = make(map[string][]byte)
        }</span>
        <span class="cov0" title="0">secret.Data["controllerEndpoint"] = []byte(ControllerEndpoint)
        secret.Data["clusterName"] = []byte(cluster.Name)
        err = util.UpdateResource(ctx, &amp;secret)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // This logic is to set NodeIPs to nil, if an empty string is set in the first index.
        <span class="cov0" title="0">if len(cluster.Spec.NodeIPs) &gt; 0 &amp;&amp; cluster.Spec.NodeIPs[0] == "" </span><span class="cov0" title="0">{
                cluster.Spec.NodeIPs = nil
                err = util.UpdateResource(ctx, cluster)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        }

        // this logic is for backward compatibility- check crds for more.
        <span class="cov0" title="0">if len(cluster.Spec.NodeIPs) &lt; 2 &amp;&amp; len(cluster.Spec.NodeIP) != 0 </span><span class="cov0" title="0">{
                if len(cluster.Spec.NodeIPs) == 0 </span><span class="cov0" title="0">{
                        cluster.Spec.NodeIPs = make([]string, 1)
                }</span>
                <span class="cov0" title="0">cluster.Spec.NodeIPs[0] = cluster.Spec.NodeIP

                err = util.UpdateResource(ctx, cluster)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        }

        // Step 6: NodeIP Reconciliation to WorkerSliceGateways
        // Should be only done if Network componets are present
        <span class="cov0" title="0">if cluster.Status.NetworkPresent </span><span class="cov0" title="0">{
                err = c.sgws.NodeIpReconciliationOfWorkerSliceGateways(ctx, cluster, req.Namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        }

        <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(DefaultSliceOperations(ctx,
                req, logger, cluster)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">logger.Infof("cluster %v reconciled", req.NamespacedName)
        return ctrl.Result{}, nil</span>
}

// cleanUpClusterResources is function to clean/remove resources- servie account and role binding of clusters
func (c *ClusterService) cleanUpClusterResources(ctx context.Context, req ctrl.Request, owner client.Object) (ctrl.Result, error) <span class="cov0" title="0">{
        if shouldReturn, result, reconErr := util.IsReconciled(c.acs.RemoveWorkerClusterServiceAccountAndRoleBindings(ctx,
                req.Name, req.Namespace, owner)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// checkForProjectNamespace is function to check the project if the namespace is in proper format
func (c *ClusterService) checkForProjectNamespace(namespace *corev1.Namespace) bool <span class="cov0" title="0">{
        return namespace.Labels[util.LabelName] == fmt.Sprintf(util.LabelValue, "Project", namespace.Name)
}</span>

// DeleteClusters is function to delete the clusters
func (c *ClusterService) DeleteClusters(ctx context.Context, namespace string) (ctrl.Result, error) <span class="cov0" title="0">{
        clusters := &amp;controllerv1alpha1.ClusterList{}
        err := util.ListResources(ctx, clusters, client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">for _, cluster := range clusters.Items </span><span class="cov0" title="0">{
                err = util.DeleteResource(ctx, &amp;cluster)
                // Load Event Recorder with project name and namespace
                eventRecorder := util.CtxEventRecorder(ctx).WithProject(util.GetProjectName(cluster.Namespace)).WithNamespace(cluster.Namespace)

                // Load metrics with project name and namespace
                c.mf.WithProject(util.GetProjectName(cluster.Namespace)).
                        WithNamespace(cluster.Namespace)

                if err != nil </span><span class="cov0" title="0">{
                        // Register an event for cluster deletion fail
                        util.RecordEvent(ctx, eventRecorder, &amp;cluster, nil, events.EventClusterDeletionFailed)
                        c.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventClusterDeletionFailed),
                                        "object_name": cluster.Name,
                                        "object_kind": metricKindCluster,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                // Register an event for cluster deletion
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;cluster, nil, events.EventClusterDeleted)
                c.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventClusterDeleted),
                                "object_name": cluster.Name,
                                "object_kind": metricKindCluster,
                        },
                )</span>
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        "k8s.io/apimachinery/pkg/runtime"

        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        workerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/worker/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/util"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/validation"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// ValidateClusterCreate is a function to validate the creation of cluster
func ValidateClusterCreate(ctx context.Context, c *controllerv1alpha1.Cluster) (warnings admission.Warnings, err error) <span class="cov0" title="0">{
        if err := validateAppliedInProjectNamespace(ctx, c); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Cluster"}, c.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateGeolocation(c); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Cluster"}, c.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if errs := validateNodeIPs(c); len(errs) != 0 </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Cluster"}, c.Name, errs)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// ValidateClusterUpdate is a function to validate to the update of specification of cluster
func ValidateClusterUpdate(ctx context.Context, c *controllerv1alpha1.Cluster, old runtime.Object) (warnings admission.Warnings, err error) <span class="cov0" title="0">{
        if err := validateGeolocation(c); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Cluster"}, c.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if errs := validateNodeIPs(c); len(errs) != 0 </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Cluster"}, c.Name, errs)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// ValidateClusterDelete is a function to validate the deletion of cluster
func ValidateClusterDelete(ctx context.Context, c *controllerv1alpha1.Cluster) (warnings admission.Warnings, err error) <span class="cov0" title="0">{
        if err := validateClusterInAnySlice(ctx, c); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Cluster"}, c.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// validateAppliedInProjectNamespace is a function to validate the if the cluster is applied in project namespace or not
func validateAppliedInProjectNamespace(ctx context.Context, c *controllerv1alpha1.Cluster) *field.Error <span class="cov0" title="0">{
        namespace := &amp;corev1.Namespace{}
        exist, _ := util.GetResourceIfExist(ctx, client.ObjectKey{Name: c.Namespace}, namespace)
        if !exist || !util.CheckForProjectNamespace(namespace) </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("metadata").Child("namespace"), c.Namespace, "cluster must be applied on project namespace")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateClusterInAnySlice is a function to check if the cluster is in any slice
func validateClusterInAnySlice(ctx context.Context, c *controllerv1alpha1.Cluster) *field.Error <span class="cov0" title="0">{
        workerSlice := &amp;workerv1alpha1.WorkerSliceConfigList{}
        label := map[string]string{"worker-cluster": c.Name}
        err := util.ListResources(ctx, workerSlice, client.MatchingLabels(label), client.InNamespace(c.Namespace))

        workerSliceCount := len(workerSlice.Items)
        defaultWorkerSliceCount := 0
        for _, slice := range workerSlice.Items </span><span class="cov0" title="0">{
                projectNamespace := slice.Labels["project-namespace"]
                originalSliceName := slice.Labels["original-slice-name"]
                projectName := util.GetProjectName(projectNamespace)
                defaultSliceName := fmt.Sprintf(util.DefaultProjectSliceName, projectName)
                if defaultSliceName == originalSliceName </span><span class="cov0" title="0">{
                        defaultWorkerSliceCount++
                }</span>
        }
        // if all the workerslice are default workeslice, then allow cluster deletion
        <span class="cov0" title="0">if err == nil &amp;&amp; workerSliceCount == defaultWorkerSliceCount </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err == nil &amp;&amp; len(workerSlice.Items) &gt; 0 </span><span class="cov0" title="0">{
                return field.Forbidden(field.NewPath("Cluster"), "The cluster cannot be deleted which is participating in slice config")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateGeolocation(c *controllerv1alpha1.Cluster) *field.Error <span class="cov0" title="0">{
        if len(c.Spec.ClusterProperty.GeoLocation.Latitude) == 0 &amp;&amp; len(c.Spec.ClusterProperty.GeoLocation.Longitude) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">latitude := c.Spec.ClusterProperty.GeoLocation.Latitude
        longitude := c.Spec.ClusterProperty.GeoLocation.Longitude
        err := util.ValidateCoOrdinates(latitude, longitude)
        if err == true </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("spec").Child("clusterProperty.geoLocation"), util.ArrayToString([]string{latitude, longitude}), "Latitude and longitude are not valid")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateNodeIPs(c *controllerv1alpha1.Cluster) field.ErrorList <span class="cov0" title="0">{
        if len(c.Spec.NodeIPs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">var errors field.ErrorList
        for _, ip := range c.Spec.NodeIPs </span><span class="cov0" title="0">{
                ipErrs := validation.IsValidIP(field.NewPath("spec").Child("nodeIPs"), ip)
                if len(ipErrs) &gt; 0 </span><span class="cov0" title="0">{
                        errors = append(errors, ipErrs...)
                }</span>
        }
        <span class="cov0" title="0">return errors</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package service

import (
        "context"
        "fmt"

        "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/util"
        "go.uber.org/zap"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
)

func DefaultSliceOperations(ctx context.Context, req ctrl.Request, logger *zap.SugaredLogger, cluster *controllerv1alpha1.Cluster) (ctrl.Result, error) <span class="cov0" title="0">{
        if cluster.Status.IsDeregisterInProgress || !cluster.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                logger.Info("cluster is in deregistration state or already deleted, skipping default slice operations")
                return ctrl.Result{}, nil
        }</span>

        <span class="cov0" title="0">projectName := util.GetProjectName(req.Namespace)
        project := &amp;controllerv1alpha1.Project{}
        present, err := util.GetResourceIfExist(ctx, types.NamespacedName{
                Name:      projectName,
                Namespace: ControllerNamespace,
        }, project)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error while getting project %v", projectName)
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">defaultSliceName := fmt.Sprintf(util.DefaultProjectSliceName, projectName)
        // also check for defaultSliceCreation flag
        if present &amp;&amp; project.Spec.DefaultSliceCreation </span><span class="cov0" title="0">{
                // create default slice if not present
                defaultProjectSlice := &amp;controllerv1alpha1.SliceConfig{}
                defaultSliceNamespacedName := types.NamespacedName{
                        Namespace: req.Namespace,
                        Name:      defaultSliceName,
                }
                foundDefaultSlice, err := util.GetResourceIfExist(ctx, defaultSliceNamespacedName, defaultProjectSlice)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error while getting default slice %v", defaultSliceName)
                        return ctrl.Result{}, err
                }</span>
                // if not found, create with all namespace of cluster
                <span class="cov0" title="0">if !foundDefaultSlice </span><span class="cov0" title="0">{
                        appns := []controllerv1alpha1.SliceNamespaceSelection{}
                        for _, ns := range cluster.Status.Namespaces </span><span class="cov0" title="0">{
                                if ns.SliceName == "" </span><span class="cov0" title="0">{
                                        appns = append(appns, controllerv1alpha1.SliceNamespaceSelection{
                                                Namespace: ns.Name,
                                                Clusters:  []string{cluster.Name},
                                        })
                                }</span>
                        }
                        <span class="cov0" title="0">defaultSliceDesc := fmt.Sprintf("This is the default slice created for project %s", projectName)
                        defaultProjectSlice = &amp;controllerv1alpha1.SliceConfig{
                                ObjectMeta: metav1.ObjectMeta{
                                        Annotations: map[string]string{"slice-managed-by": projectName, "desc": defaultSliceDesc},
                                        Name:        defaultSliceName,
                                        Namespace:   req.Namespace,
                                },
                                Spec: controllerv1alpha1.SliceConfigSpec{
                                        OverlayNetworkDeploymentMode: v1alpha1.NONET,
                                        Clusters:                     []string{req.Name},
                                        NamespaceIsolationProfile: controllerv1alpha1.NamespaceIsolationProfile{
                                                ApplicationNamespaces: appns,
                                        },
                                        MaxClusters: 8,
                                },
                        }
                        err := util.CreateResource(ctx, defaultProjectSlice)
                        if err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">logger.Infof("successfully created default slice %s", defaultSliceName)</span>
                } else<span class="cov0" title="0"> {

                        logger.Infof("default slice %s already present", defaultSliceName)
                        // if default slice is already present, either the cluster is new or there is some change in cluster
                        // check if cluster is already registered
                        isNewCluster := true
                        for _, cluster := range defaultProjectSlice.Spec.Clusters </span><span class="cov0" title="0">{
                                if cluster == req.Name </span><span class="cov0" title="0">{
                                        isNewCluster = false
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if isNewCluster </span><span class="cov0" title="0">{
                                defaultProjectSlice.Spec.Clusters = append(defaultProjectSlice.Spec.Clusters, req.Name)
                        }</span>

                        // create map for easy look up
                        <span class="cov0" title="0">namespaceToClusterMap := make(map[string]struct{})
                        mapKeyFormat := "namespace=%s&amp;cluster=%s"
                        namespaceIndexMap := make(map[string]int)

                        for index, appns := range defaultProjectSlice.Spec.NamespaceIsolationProfile.ApplicationNamespaces </span><span class="cov0" title="0">{
                                namespaceIndexMap[appns.Namespace] = index
                                for _, cluster := range appns.Clusters </span><span class="cov0" title="0">{
                                        mapKey := fmt.Sprintf(mapKeyFormat, appns.Namespace, cluster)
                                        namespaceToClusterMap[mapKey] = struct{}{}
                                }</span>
                        }

                        // if any namespace is added to cluster, add it to default slice
                        <span class="cov0" title="0">isNamespaceAddedToCluster := false
                        for _, ns := range cluster.Status.Namespaces </span><span class="cov0" title="0">{
                                if ns.SliceName != "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">mapKey := fmt.Sprintf(mapKeyFormat, ns.Name, cluster.Name)
                                if _, ok := namespaceToClusterMap[mapKey]; ok </span><span class="cov0" title="0">{
                                        logger.Info("already present namespace and cluster, skipping operations...")
                                }</span> else<span class="cov0" title="0"> {
                                        isNamespaceAddedToCluster = true
                                        // check if namespace is already present
                                        if nsIndex, ok := namespaceIndexMap[ns.Name]; ok </span><span class="cov0" title="0">{
                                                // not handling same namespace in multiple cluster for now
                                                prevData := defaultProjectSlice.Spec.NamespaceIsolationProfile.ApplicationNamespaces[nsIndex]
                                                modifiedData := controllerv1alpha1.SliceNamespaceSelection{
                                                        Namespace: prevData.Namespace,
                                                        Clusters:  append(prevData.Clusters, cluster.Name),
                                                }
                                                defaultProjectSlice.Spec.NamespaceIsolationProfile.ApplicationNamespaces[nsIndex] = modifiedData
                                        }</span> else<span class="cov0" title="0"> {
                                                // if namespace is not present, add another entry
                                                defaultProjectSlice.Spec.NamespaceIsolationProfile.ApplicationNamespaces = append(defaultProjectSlice.Spec.NamespaceIsolationProfile.ApplicationNamespaces, controllerv1alpha1.SliceNamespaceSelection{
                                                        Namespace: ns.Name,
                                                        Clusters:  []string{cluster.Name},
                                                })
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">if isNamespaceAddedToCluster </span><span class="cov0" title="0">{
                                logger.Infof("handling ns addition cluster %v slice %v", cluster.Name, defaultProjectSlice)
                                err := util.UpdateResource(ctx, defaultProjectSlice)
                                if err != nil </span><span class="cov0" title="0">{
                                        return ctrl.Result{}, err
                                }</span>
                                <span class="cov0" title="0">return ctrl.Result{}, nil</span>
                        }

                        // if any namespace is removed from cluster that is still present in default slice, remove it
                        <span class="cov0" title="0">isNamespaceRemovedFromCluster := false
                        namespacesInCluster := make(map[string]struct{})
                        for _, ns := range cluster.Status.Namespaces </span><span class="cov0" title="0">{
                                if ns.SliceName == defaultSliceName </span><span class="cov0" title="0">{
                                        namespacesInCluster[ns.Name] = struct{}{}
                                }</span>
                        }

                        <span class="cov0" title="0">modifiedDefaultSliceApplicationNamespace := []controllerv1alpha1.SliceNamespaceSelection{}
                        for _, appns := range defaultProjectSlice.Spec.NamespaceIsolationProfile.ApplicationNamespaces </span><span class="cov0" title="0">{
                                foundClusterName := false
                                for _, clusterName := range appns.Clusters </span><span class="cov0" title="0">{
                                        if clusterName == req.Name </span><span class="cov0" title="0">{
                                                foundClusterName = true
                                                if _, ok := namespacesInCluster[appns.Namespace]; !ok </span><span class="cov0" title="0">{
                                                        isNamespaceRemovedFromCluster = true
                                                        if len(appns.Clusters) &gt; 1 </span><span class="cov0" title="0">{
                                                                appns.Clusters = util.RemoveElementFromArray(appns.Clusters, cluster.Name)
                                                                modifiedDefaultSliceApplicationNamespace = append(modifiedDefaultSliceApplicationNamespace, appns)
                                                        }</span> else<span class="cov0" title="0"> {
                                                                continue</span>
                                                        }
                                                } else<span class="cov0" title="0"> {
                                                        modifiedDefaultSliceApplicationNamespace = append(modifiedDefaultSliceApplicationNamespace, appns)
                                                }</span>
                                        }
                                }
                                <span class="cov0" title="0">if !foundClusterName </span><span class="cov0" title="0">{
                                        modifiedDefaultSliceApplicationNamespace = append(modifiedDefaultSliceApplicationNamespace, appns)
                                }</span>
                        }

                        <span class="cov0" title="0">defaultProjectSlice.Spec.NamespaceIsolationProfile.ApplicationNamespaces = modifiedDefaultSliceApplicationNamespace
                        if isNamespaceRemovedFromCluster &amp;&amp; !isNamespaceAddedToCluster </span><span class="cov0" title="0">{
                                err := util.UpdateResource(ctx, defaultProjectSlice)
                                if err != nil </span><span class="cov0" title="0">{
                                        return ctrl.Result{}, err
                                }</span>
                                <span class="cov0" title="0">logger.Infof("successfully updated default slice with removed namespaces %s", defaultSliceName)
                                return ctrl.Result{}, nil</span>
                        }
                }

        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

func DeregisterClusterFromDefaultSlice(ctx context.Context, req ctrl.Request, logger *zap.SugaredLogger, clusterName string) (ctrl.Result, error) <span class="cov0" title="0">{
        projectName := util.GetProjectName(req.Namespace)
        project := &amp;controllerv1alpha1.Project{}
        present, err := util.GetResourceIfExist(ctx, types.NamespacedName{
                Name:      projectName,
                Namespace: ControllerNamespace,
        }, project)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error while getting project %v", projectName)
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">defaultSliceName := fmt.Sprintf(util.DefaultProjectSliceName, projectName)
        if present &amp;&amp; project.Spec.DefaultSliceCreation </span><span class="cov0" title="0">{
                // create default slice if not present
                defaultProjectSlice := &amp;controllerv1alpha1.SliceConfig{}
                defaultSliceNamespacedName := types.NamespacedName{
                        Namespace: req.Namespace,
                        Name:      defaultSliceName,
                }
                foundDefaultSlice, err := util.GetResourceIfExist(ctx, defaultSliceNamespacedName, defaultProjectSlice)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("error while getting default slice %v", defaultSliceName)
                        return ctrl.Result{}, err
                }</span>

                <span class="cov0" title="0">if !foundDefaultSlice </span><span class="cov0" title="0">{
                        logger.Info("default slice not found %s", defaultSliceName)
                        return ctrl.Result{}, nil
                }</span>

                <span class="cov0" title="0">foundWorkerCluster := false
                for _, onboardedCluster := range defaultProjectSlice.Spec.Clusters </span><span class="cov0" title="0">{
                        if onboardedCluster == clusterName </span><span class="cov0" title="0">{
                                foundWorkerCluster = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !foundWorkerCluster </span><span class="cov0" title="0">{
                        logger.Info("worker %s is not present in default slice %s, returning without update....", clusterName, defaultSliceName)
                        return ctrl.Result{}, nil
                }</span>

                // to deregisterCluster from default, assume it doesn't have any namespace, so every namespace attach to this clusterName will be removed
                <span class="cov0" title="0">cluster := controllerv1alpha1.Cluster{
                        ObjectMeta: metav1.ObjectMeta{
                                Name: clusterName,
                        },
                }

                // if any namespace is removed from cluster that is still present in default slice, remove it
                isNamespaceRemovedFromCluster := false
                namespacesInCluster := make(map[string]struct{})

                modifiedDefaultSliceApplicationNamespace := []controllerv1alpha1.SliceNamespaceSelection{}
                for _, appns := range defaultProjectSlice.Spec.NamespaceIsolationProfile.ApplicationNamespaces </span><span class="cov0" title="0">{
                        foundClusterName := false
                        for _, clusterName := range appns.Clusters </span><span class="cov0" title="0">{
                                if clusterName == req.Name </span><span class="cov0" title="0">{
                                        foundClusterName = true
                                        if _, ok := namespacesInCluster[appns.Namespace]; !ok </span><span class="cov0" title="0">{
                                                isNamespaceRemovedFromCluster = true
                                                if len(appns.Clusters) &gt; 1 </span><span class="cov0" title="0">{
                                                        appns.Clusters = util.RemoveElementFromArray(appns.Clusters, clusterName)
                                                        modifiedDefaultSliceApplicationNamespace = append(modifiedDefaultSliceApplicationNamespace, appns)
                                                }</span> else<span class="cov0" title="0"> {
                                                        continue</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                modifiedDefaultSliceApplicationNamespace = append(modifiedDefaultSliceApplicationNamespace, appns)
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">if !foundClusterName </span><span class="cov0" title="0">{
                                modifiedDefaultSliceApplicationNamespace = append(modifiedDefaultSliceApplicationNamespace, appns)
                        }</span>
                }

                <span class="cov0" title="0">defaultProjectSlice.Spec.NamespaceIsolationProfile.ApplicationNamespaces = modifiedDefaultSliceApplicationNamespace
                if isNamespaceRemovedFromCluster </span><span class="cov0" title="0">{
                        defaultProjectSlice.Spec.Clusters = util.RemoveElementFromArray(defaultProjectSlice.Spec.Clusters, cluster.Name)
                        err := util.UpdateResource(ctx, defaultProjectSlice)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Errorf("could not remove cluster %s from default slice %s", clusterName, defaultSliceName)
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">logger.Infof("successfully removed cluster %s from default slice %s", clusterName, defaultSliceName)
                        return ctrl.Result{}, nil</span>
                }

        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"

        "github.com/kubeslice/kubeslice-controller/util"
        batchv1 "k8s.io/api/batch/v1"
        v1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/util/uuid"
        ctrl "sigs.k8s.io/controller-runtime"
)

type IJobService interface {
        CreateJob(ctx context.Context, namespace string, jobImage string, environment map[string]string) (ctrl.Result, error)
}

type JobService struct{}

// CreateJob is function to create the job in k8s
func (j *JobService) CreateJob(ctx context.Context, namespace string, jobImage string, environment map[string]string) (ctrl.Result, error) <span class="cov0" title="0">{
        name := fmt.Sprintf("%s-%s", "open-cert", uuid.NewUUID()[:8])
        tTLSecondsAfterFinished := int32(60 * 60 * 24)
        backoffLimit := int32(2)
        envValues := make([]v1.EnvVar, 0, len(environment))
        for key, value := range environment </span><span class="cov0" title="0">{
                envValue := v1.EnvVar{
                        Name:  key,
                        Value: value,
                }
                envValues = append(envValues, envValue)
        }</span>

        <span class="cov0" title="0">logEnv := v1.EnvVar{
                Name:  "LOG_LEVEL",
                Value: util.LoglevelString,
        }
        envValues = append(envValues, logEnv)

        job := &amp;batchv1.Job{
                TypeMeta: metav1.TypeMeta{
                        Kind:       "Job",
                        APIVersion: "batch/v1",
                },
                ObjectMeta: metav1.ObjectMeta{
                        Name:      name,
                        Namespace: namespace,
                        Labels: map[string]string{
                                "SLICE_NAME": environment["SLICE_NAME"],
                        },
                },
                Spec: batchv1.JobSpec{
                        TTLSecondsAfterFinished: &amp;tTLSecondsAfterFinished,
                        BackoffLimit:            &amp;backoffLimit,
                        Template: v1.PodTemplateSpec{
                                ObjectMeta: metav1.ObjectMeta{
                                        Labels: map[string]string{
                                                "app": "ovpn-cert-generator",
                                        },
                                        Name:      "ovpn-cert-job-pod",
                                        Namespace: namespace,
                                },
                                Spec: v1.PodSpec{
                                        RestartPolicy: "Never",
                                        Containers: []v1.Container{
                                                {
                                                        Name:  "ovpn-cert-generator",
                                                        Image: jobImage,
                                                        Env:   envValues,
                                                },
                                        },
                                        ServiceAccountName: JobServiceAccount,
                                },
                        },
                },
                Status: batchv1.JobStatus{},
        }
        if JobCredential != "" </span><span class="cov0" title="0">{
                job.Spec.Template.Spec.ImagePullSecrets = append(job.Spec.Template.Spec.ImagePullSecrets, v1.LocalObjectReference{
                        Name: JobCredential,
                })
        }</span>
        <span class="cov0" title="0">err := util.CreateResource(ctx, job)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "os"
        "time"

        rbacv1 "k8s.io/api/rbac/v1"
)

// Api Groups
const (
        apiGroupKubeSliceControllers = "controller.kubeslice.io"
        apiGroupKubeSliceWorker      = "worker.kubeslice.io"
)

// ControllerNamespace Controller Namespace
const (
        ControllerNamespace = "kubeslice-controller"
)

// Resources
const (
        resourceProjects              = "projects"
        resourceCluster               = "clusters"
        resourceSliceConfig           = "sliceconfigs"
        resourceSliceQoSConfig        = "sliceqosconfigs"
        resourceWorkerSliceConfig     = "workersliceconfigs"
        resourceWorkerSliceGateways   = "workerslicegateways"
        resourceServiceExportConfigs  = "serviceexportconfigs"
        resourceWorkerServiceImport   = "workerserviceimports"
        resourceWorkerSliceGwRecycler = "workerslicegwrecyclers"
        resourceSecrets               = "secrets"
        resourceEvents                = "events"
        ResourceStatusSuffix          = "/status"
        resourceVpnKeyRotationConfigs = "vpnkeyrotations"
)

// metric kind
const (
        metricKindRole                = "role"
        metricKindServiceAccount      = "service_account"
        metricKindSecret              = "secret"
        metricKindRoleBinding         = "role_binding"
        metricKindCluster             = "cluster"
        metricKindNamespace           = "namespace"
        metricKindProject             = "project"
        metricKindServiceExportConfig = "service_export_config"
        metricKindSliceConfig         = "slice_config"
        metricKindSliceQoSConfig      = "slice_qos_config"
        metricKindWorkerServiceImport = "worker_service_import"
        metricKindWorkerSliceConfig   = "worker_slice_config"
        metricKindWorkerSliceGateway  = "worker_slice_gateway"
)

var MetricPort = "18080"

// Verbs
const (
        verbCreate = "create"
        verbDelete = "delete"
        verbUpdate = "update"
        verbPatch  = "patch"
        verbGet    = "get"
        verbList   = "list"
        verbWatch  = "watch"
)

// Annotation Prefix
const (
        annotationKubeSliceControllers = "controller.kubeslice.io"
)

// Role Names
const (
        roleWorkerCluster   = "kubeslice-worker-cluster"
        roleSharedReadOnly  = "kubeslice-read-only"
        roleSharedReadWrite = "kubeslice-read-write"
)

// rbacResourcePrefix

var RbacResourcePrefix = "kubeslice"

// RoleBinding Names
var (
        RoleBindingWorkerCluster = "kubeslice-worker-%s"
        RoleBindingReadOnlyUser  = "kubeslice-ro-%s"
        RoleBindingReadWriteUser = "kubeslice-rw-%s"
)

// ServiceAccount Names
var (
        ServiceAccountWorkerCluster = "kubeslice-worker-%s"
        ServiceAccountReadOnlyUser  = "kubeslice-ro-%s"
        ServiceAccountReadWriteUser = "kubeslice-rw-%s"
)

// Access Types
const (
        AccessTypeAnnotationLabel  = "access-type"
        AccessTypeClusterReadWrite = "cluster-read-write"
        AccessTypeReadOnly         = "read-only"
        AccessTypeReadWrite        = "read-write"
)

// Request Timeout
const (
        RequeueTime = time.Duration(30000000000)
)

// Finalizers
const (
        ProjectFinalizer              = "controller.kubeslice.io/project-finalizer"
        ClusterFinalizer              = "controller.kubeslice.io/cluster-finalizer"
        ClusterDeregisterFinalizer    = "worker.kubeslice.io/cluster-deregister-finalizer"
        SliceConfigFinalizer          = "controller.kubeslice.io/slice-configuration-finalizer"
        serviceExportConfigFinalizer  = "controller.kubeslice.io/service-export-finalizer"
        WorkerSliceConfigFinalizer    = "worker.kubeslice.io/worker-slice-configuration-finalizer"
        WorkerSliceGatewayFinalizer   = "worker.kubeslice.io/worker-slice-gateway-finalizer"
        WorkerServiceImportFinalizer  = "worker.kubeslice.io/worker-service-import-finalizer"
        SliceQoSConfigFinalizer       = "controller.kubeslice.io/slice-qos-config-finalizer"
        VPNKeyRotationConfigFinalizer = "controller.kubeslice.io/vpn-key-rotation-config-finalizer"
)

// ControllerEndpoint
var (
        ControllerEndpoint = "https://controller.cisco.com:6443/"
)

// Project Namespace prefix. Customer can over ride this.
var (
        ProjectNamespacePrefix = "kubeslice-controller-project-"
)

const (
        serverGateway                      = "Server"
        clientGateway                      = "Client"
        workerSliceGatewayType             = "OpenVPN"
        defaultSliceGatewayServiceType     = "NodePort"
        defaultSliceGatewayServiceProtocol = "UDP"
)

var (
        // Job namespace
        jobNamespace = os.Getenv("KUBESLICE_CONTROLLER_MANAGER_NAMESPACE")

        // Job Image
        JobImage          = "aveshasystems/gateway-certs-generator:latest"
        JobCredential     = ""
        JobServiceAccount = "kubeslice-controller-ovpn-manager"
)

const (
        KubesliceWorkerDeleteRequeueTime = 3
)

// StandardQoSProfileLabel name
const (
        StandardQoSProfileLabel = "standard-qos-profile"
)

type IAccessControlRuleProvider interface {
        WorkerClusterRoleRules() []rbacv1.PolicyRule
        ReadOnlyRoleRules() []rbacv1.PolicyRule
        ReadWriteRoleRules() []rbacv1.PolicyRule
}

type AccessControlRuleProvider struct{}

func (k *AccessControlRuleProvider) WorkerClusterRoleRules() []rbacv1.PolicyRule <span class="cov0" title="0">{
        return workerClusterRoleRules
}</span>

func (k *AccessControlRuleProvider) ReadOnlyRoleRules() []rbacv1.PolicyRule <span class="cov0" title="0">{
        return readOnlyRoleRules
}</span>

func (k *AccessControlRuleProvider) ReadWriteRoleRules() []rbacv1.PolicyRule <span class="cov0" title="0">{
        return readWriteRoleRules
}</span>

// Rules

var workerClusterRoleRules = []rbacv1.PolicyRule{
        {
                Verbs:     []string{verbCreate, verbDelete, verbUpdate, verbPatch, verbGet, verbList, verbWatch},
                APIGroups: []string{apiGroupKubeSliceControllers},
                Resources: []string{resourceServiceExportConfigs},
        },
        {
                Verbs:     []string{verbUpdate, verbPatch, verbGet, verbList, verbWatch},
                APIGroups: []string{apiGroupKubeSliceControllers},
                Resources: []string{resourceCluster},
        },
        {
                Verbs:     []string{verbUpdate, verbPatch, verbGet, verbList, verbWatch, verbCreate, verbDelete},
                APIGroups: []string{apiGroupKubeSliceWorker},
                Resources: []string{resourceWorkerSliceGwRecycler},
        },
        {
                Verbs:     []string{verbUpdate, verbPatch, verbGet, verbList, verbWatch},
                APIGroups: []string{apiGroupKubeSliceControllers},
                Resources: []string{resourceVpnKeyRotationConfigs},
        },
        {
                Verbs:     []string{verbUpdate, verbPatch, verbGet, verbList, verbWatch},
                APIGroups: []string{apiGroupKubeSliceWorker},
                Resources: []string{resourceWorkerSliceConfig, resourceWorkerSliceGateways, resourceWorkerServiceImport},
        },
        {
                Verbs:     []string{verbUpdate, verbPatch, verbGet},
                APIGroups: []string{apiGroupKubeSliceControllers},
                Resources: []string{resourceCluster + ResourceStatusSuffix, resourceVpnKeyRotationConfigs + ResourceStatusSuffix},
        },
        {
                Verbs:     []string{verbUpdate, verbPatch, verbGet},
                APIGroups: []string{apiGroupKubeSliceWorker},
                Resources: []string{resourceWorkerSliceConfig + ResourceStatusSuffix, resourceWorkerSliceGateways + ResourceStatusSuffix, resourceWorkerServiceImport + ResourceStatusSuffix, resourceWorkerSliceGwRecycler + ResourceStatusSuffix},
        },
        {
                Verbs:     []string{verbGet, verbList, verbWatch, verbCreate, verbUpdate, verbPatch},
                APIGroups: []string{""},
                Resources: []string{resourceSecrets},
        },
        {
                Verbs:     []string{verbCreate, verbPatch},
                APIGroups: []string{""},
                Resources: []string{resourceEvents},
        },
}

var readOnlyRoleRules = []rbacv1.PolicyRule{
        {
                Verbs:     []string{verbGet, verbList, verbWatch},
                APIGroups: []string{apiGroupKubeSliceControllers},
                Resources: []string{resourceCluster, resourceSliceConfig, resourceSliceQoSConfig, resourceServiceExportConfigs},
        },
        {
                Verbs:     []string{verbGet, verbList, verbWatch},
                APIGroups: []string{apiGroupKubeSliceWorker},
                Resources: []string{resourceWorkerSliceConfig, resourceWorkerSliceGateways, resourceWorkerServiceImport},
        },
        {
                Verbs:     []string{verbGet},
                APIGroups: []string{apiGroupKubeSliceControllers},
                Resources: []string{resourceCluster + ResourceStatusSuffix, resourceSliceConfig + ResourceStatusSuffix, resourceServiceExportConfigs + ResourceStatusSuffix},
        },
        {
                Verbs:     []string{verbGet},
                APIGroups: []string{apiGroupKubeSliceWorker},
                Resources: []string{resourceWorkerSliceConfig + ResourceStatusSuffix, resourceWorkerSliceGateways + ResourceStatusSuffix, resourceWorkerServiceImport + ResourceStatusSuffix},
        },
        {
                Verbs:     []string{verbGet, verbList, verbWatch},
                APIGroups: []string{""},
                Resources: []string{resourceSecrets, resourceEvents},
        },
}

var readWriteRoleRules = []rbacv1.PolicyRule{
        {
                Verbs:     []string{verbCreate, verbDelete, verbUpdate, verbPatch, verbGet, verbList, verbWatch},
                APIGroups: []string{apiGroupKubeSliceControllers},
                Resources: []string{resourceCluster, resourceSliceConfig, resourceSliceQoSConfig, resourceServiceExportConfigs},
        },
        {
                Verbs:     []string{verbGet, verbList, verbWatch},
                APIGroups: []string{apiGroupKubeSliceWorker},
                Resources: []string{resourceWorkerSliceConfig, resourceWorkerSliceGateways, resourceWorkerServiceImport},
        },
        {
                Verbs:     []string{verbUpdate, verbPatch, verbGet},
                APIGroups: []string{apiGroupKubeSliceControllers},
                Resources: []string{resourceCluster + ResourceStatusSuffix, resourceSliceConfig + ResourceStatusSuffix, resourceServiceExportConfigs + ResourceStatusSuffix},
        },
        {
                Verbs:     []string{verbUpdate, verbPatch, verbGet},
                APIGroups: []string{apiGroupKubeSliceWorker},
                Resources: []string{resourceWorkerSliceConfig + ResourceStatusSuffix, resourceWorkerSliceGateways + ResourceStatusSuffix, resourceWorkerServiceImport + ResourceStatusSuffix},
        },
        {
                Verbs:     []string{verbGet, verbList, verbWatch},
                APIGroups: []string{""},
                Resources: []string{resourceSecrets, resourceEvents},
        },
}
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"

        "github.com/kubeslice/kubeslice-controller/metrics"

        "github.com/kubeslice/kubeslice-controller/events"
        "github.com/kubeslice/kubeslice-controller/util"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type INamespaceService interface {
        ReconcileProjectNamespace(ctx context.Context, namespace string, owner client.Object) (ctrl.Result, error)
        DeleteNamespace(ctx context.Context, namespace string) (ctrl.Result, error)
}

type NamespaceService struct {
        mf metrics.IMetricRecorder
}

// ReconcileProjectNamespace is a function to reconcile project namespace
func (n *NamespaceService) ReconcileProjectNamespace(ctx context.Context, namespace string, owner client.Object) (ctrl.Result, error) <span class="cov0" title="0">{
        nsResource := &amp;corev1.Namespace{}
        found, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                Name: namespace,
        }, nsResource)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        //Load Event Recorder with project name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).WithProject(util.GetProjectName(namespace)).WithNamespace(ControllerNamespace)

        // Load metrics with project name and namespace
        n.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(ControllerNamespace)

        if !found </span><span class="cov0" title="0">{
                expectedNS := &amp;corev1.Namespace{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:   namespace,
                                Labels: n.getResourceLabel(namespace, owner),
                        },
                }
                //append additional labels
                for key, value := range util.FilterLabelsAndAnnotations(owner.GetLabels()) </span><span class="cov0" title="0">{
                        expectedNS.Labels[key] = value
                }</span>
                <span class="cov0" title="0">if expectedNS.Annotations == nil </span><span class="cov0" title="0">{
                        expectedNS.Annotations = make(map[string]string)
                }</span>
                //append additional annotations
                <span class="cov0" title="0">for key, value := range util.FilterLabelsAndAnnotations(owner.GetAnnotations()) </span><span class="cov0" title="0">{
                        expectedNS.Annotations[key] = value
                }</span>
                <span class="cov0" title="0">err := util.CreateResource(ctx, expectedNS)
                expectedNS.Namespace = ControllerNamespace
                if err != nil </span><span class="cov0" title="0">{
                        util.RecordEvent(ctx, eventRecorder, expectedNS, nil, events.EventNamespaceCreationFailed)
                        n.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "creation_failed",
                                        "event":       string(events.EventNamespaceCreationFailed),
                                        "object_name": expectedNS.Name,
                                        "object_kind": metricKindNamespace,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, expectedNS, nil, events.EventNamespaceCreated)
                n.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "created",
                                "event":       string(events.EventNamespaceCreated),
                                "object_name": expectedNS.Name,
                                "object_kind": metricKindNamespace,
                        },
                )</span>
        } else<span class="cov0" title="0"> {
                // check if the namespace has the correct labels
                if !util.CompareLabels(nsResource.Labels, n.getResourceLabel(namespace, owner)) </span><span class="cov0" title="0">{
                        // append missing labels
                        for key, value := range n.getResourceLabel(namespace, owner) </span><span class="cov0" title="0">{
                                if nsResource.Labels[key] != value </span><span class="cov0" title="0">{
                                        nsResource.Labels[key] = value
                                }</span>
                        }
                        // append additional labels
                        <span class="cov0" title="0">for key, value := range util.FilterLabelsAndAnnotations(owner.GetLabels()) </span><span class="cov0" title="0">{
                                nsResource.Labels[key] = value
                        }</span>
                        <span class="cov0" title="0">if nsResource.Annotations == nil </span><span class="cov0" title="0">{
                                nsResource.Annotations = make(map[string]string)
                        }</span>
                        //  append additional annotations
                        <span class="cov0" title="0">for key, value := range util.FilterLabelsAndAnnotations(owner.GetAnnotations()) </span><span class="cov0" title="0">{
                                nsResource.Annotations[key] = value
                        }</span>
                        <span class="cov0" title="0">err := util.UpdateResource(ctx, nsResource)
                        nsResource.Namespace = ControllerNamespace
                        if err != nil </span><span class="cov0" title="0">{
                                util.RecordEvent(ctx, eventRecorder, nsResource, nil, events.EventNamespaceUpdateFailed)
                                n.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "update_failed",
                                                "event":       string(events.EventNamespaceUpdateFailed),
                                                "object_name": nsResource.Name,
                                                "object_kind": metricKindNamespace,
                                        },
                                )
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, nsResource, nil, events.EventNamespaceUpdated)
                        n.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "updated",
                                        "event":       string(events.EventNamespaceUpdated),
                                        "object_name": nsResource.Name,
                                        "object_kind": metricKindNamespace,
                                },
                        )</span>
                }
                // check if the namespace has the correct annotations
                <span class="cov0" title="0">if !util.CompareAnnotations(nsResource.Annotations, util.FilterLabelsAndAnnotations(owner.GetAnnotations())) </span><span class="cov0" title="0">{
                        if nsResource.Annotations == nil </span><span class="cov0" title="0">{
                                nsResource.Annotations = make(map[string]string)
                        }</span>
                        // append missing annotations
                        <span class="cov0" title="0">for key, value := range util.FilterLabelsAndAnnotations(owner.GetAnnotations()) </span><span class="cov0" title="0">{
                                if nsResource.Annotations[key] != value </span><span class="cov0" title="0">{
                                        nsResource.Annotations[key] = value
                                }</span>
                        }
                        <span class="cov0" title="0">err := util.UpdateResource(ctx, nsResource)
                        nsResource.Namespace = ControllerNamespace
                        if err != nil </span><span class="cov0" title="0">{
                                util.RecordEvent(ctx, eventRecorder, nsResource, nil, events.EventNamespaceUpdateFailed)
                                n.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "update_failed",
                                                "event":       string(events.EventNamespaceUpdateFailed),
                                                "object_name": nsResource.Name,
                                                "object_kind": metricKindNamespace,
                                        },
                                )
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, nsResource, nil, events.EventNamespaceUpdated)
                        n.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "updated",
                                        "event":       string(events.EventNamespaceUpdated),
                                        "object_name": nsResource.Name,
                                        "object_kind": metricKindNamespace,
                                },
                        )</span>
                }
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// DeleteNamespace is a function deletes the namespace
func (n *NamespaceService) DeleteNamespace(ctx context.Context, namespace string) (ctrl.Result, error) <span class="cov0" title="0">{
        nsResource := &amp;corev1.Namespace{}
        found, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                Name: namespace,
        }, nsResource)
        //Load Event Recorder with project name and namespace
        eventRecorder := util.CtxEventRecorder(ctx).WithProject(util.GetProjectName(namespace)).WithNamespace(ControllerNamespace)

        // Load metrics with project name and namespace
        n.mf.WithProject(util.GetProjectName(util.GetProjectName(namespace))).
                WithNamespace(ControllerNamespace)

        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                nsToBeDeleted := &amp;corev1.Namespace{
                        ObjectMeta: metav1.ObjectMeta{
                                Name: namespace,
                        },
                }
                err := util.DeleteResource(ctx, nsToBeDeleted)
                nsToBeDeleted.Namespace = ControllerNamespace
                if err != nil </span><span class="cov0" title="0">{
                        util.RecordEvent(ctx, eventRecorder, nsToBeDeleted, nil, events.EventNamespaceDeletionFailed)
                        n.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventNamespaceDeletionFailed),
                                        "object_name": nsToBeDeleted.Name,
                                        "object_kind": metricKindNamespace,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, nsToBeDeleted, nil, events.EventNamespaceDeleted)
                n.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventNamespaceDeleted),
                                "object_name": nsToBeDeleted.Name,
                                "object_kind": metricKindNamespace,
                        },
                )</span>
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

func (n *NamespaceService) getResourceLabel(namespace string, owner client.Object) map[string]string <span class="cov0" title="0">{
        label := map[string]string{}
        for key, value := range util.LabelsKubeSliceController </span><span class="cov0" title="0">{
                label[key] = value
        }</span>
        <span class="cov0" title="0">kind := owner.GetObjectKind().GroupVersionKind().Kind
        if kind == "" </span><span class="cov0" title="0">{
                kind = "Project"
        }</span>
        <span class="cov0" title="0">label[util.LabelName] = fmt.Sprintf(util.LabelValue, kind, namespace)
        return label</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "encoding/json"
        "fmt"

        "github.com/kubeslice/kubeslice-controller/metrics"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"

        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/events"
        "github.com/kubeslice/kubeslice-controller/util"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type IProjectService interface {
        ReconcileProject(ctx context.Context, req ctrl.Request) (ctrl.Result, error)
}

// ProjectService implements different service interfaces
type ProjectService struct {
        ns  INamespaceService
        acs IAccessControlService
        c   IClusterService
        sc  ISliceConfigService
        se  IServiceExportConfigService
        q   ISliceQoSConfigService
        mf  metrics.IMetricRecorder
}

// ReconcileProject is a function to reconcile the projects includes reconciliation of roles, clusters, project namespaces etc.
func (t *ProjectService) ReconcileProject(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        // Step 0: Get project resource
        logger := util.CtxLogger(ctx)
        logger.Infof("Starting Recoincilation of Project with name %s in namespace %s",
                req.Name, req.Namespace)
        project := &amp;controllerv1alpha1.Project{}
        found, err := util.GetResourceIfExist(ctx, req.NamespacedName, project)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                logger.Infof("project %v not found, returning from reconciler loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>
        // Load Event Recorder with project name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).WithProject(project.Name).WithNamespace(ControllerNamespace)

        // Load metrics with project name and namespace
        t.mf.WithProject(project.Name).
                WithNamespace(ControllerNamespace)

        projectNamespace := fmt.Sprintf(ProjectNamespacePrefix, project.GetName())
        // Finalizers
        if project.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                if !util.ContainsString(project.GetFinalizers(), ProjectFinalizer) </span><span class="cov0" title="0">{
                        if shouldReturn, result, reconErr := util.IsReconciled(util.AddFinalizer(ctx, project, ProjectFinalizer)); shouldReturn </span><span class="cov0" title="0">{
                                return result, reconErr
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                logger.Debug("starting delete for project", req.NamespacedName)
                if shouldReturn, result, reconErr := util.IsReconciled(t.CleanUpProjectResources(ctx, projectNamespace)); shouldReturn </span><span class="cov0" title="0">{
                        return result, reconErr
                }</span>
                <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(util.RemoveFinalizer(ctx, project, ProjectFinalizer)); shouldReturn </span><span class="cov0" title="0">{
                        // Register an event for project deletion fail
                        util.RecordEvent(ctx, eventRecorder, project, nil, events.EventProjectDeletionFailed)
                        t.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventProjectDeletionFailed),
                                        "object_name": project.Name,
                                        "object_kind": metricKindProject,
                                },
                        )
                        return result, reconErr
                }</span>
                // Register an event for project deletion
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, project, nil, events.EventProjectDeleted)
                t.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventProjectDeleted),
                                "object_name": project.Name,
                                "object_kind": metricKindProject,
                        },
                )
                return ctrl.Result{}, nil</span>
        }

        // Step 1: adding ProjectNamespace in labels/annotations from ConfigMap
        <span class="cov0" title="0">configLabels, configAnnotations, err := t.getNamespaceConfigFromConfigMap(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if project.Labels == nil </span><span class="cov0" title="0">{
                project.Labels = make(map[string]string)
        }</span>
        <span class="cov0" title="0">for k, v := range configLabels </span><span class="cov0" title="0">{
                project.Labels[k] = v
        }</span>
        <span class="cov0" title="0">project.Labels[util.LabelProjectNamespace] = projectNamespace
        if project.Annotations == nil </span><span class="cov0" title="0">{
                project.Annotations = make(map[string]string)
        }</span>
        <span class="cov0" title="0">for k, v := range configAnnotations </span><span class="cov0" title="0">{
                project.Annotations[k] = v
        }</span>

        <span class="cov0" title="0">err = util.UpdateResource(ctx, project)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Step 2: Namespace Reconciliation
        <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(t.ns.ReconcileProjectNamespace(ctx, projectNamespace, project)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>

        // Step 3: Worker-Cluster Role reconciliation
        <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(t.acs.ReconcileWorkerClusterRole(ctx, projectNamespace, project)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>
        // Step 4: Create shared Read-Only and Read-Write Roles for end-users
        // 4.1 Read-Only Shared Role
        <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(t.acs.ReconcileReadOnlyRole(ctx, projectNamespace, project)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>

        // 4.2 Read-Write Shared Role
        <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(t.acs.ReconcileReadWriteRole(ctx, projectNamespace, project)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>

        // Step 5: Reconciliation for Read-Only Users
        <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(t.acs.ReconcileReadOnlyUserServiceAccountAndRoleBindings(ctx,
                projectNamespace, project.Spec.ServiceAccount.ReadOnly, project)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>

        // Step 6: Reconciliation for Read-Write Users
        <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(t.acs.ReconcileReadWriteUserServiceAccountAndRoleBindings(ctx,
                projectNamespace, project.Spec.ServiceAccount.ReadWrite, project)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>

        // Step 7: adding ProjectNamespace in labels
        <span class="cov0" title="0">labels := make(map[string]string)
        labels["kubeslice-project-namespace"] = projectNamespace
        project.Labels = labels

        err = util.UpdateResource(ctx, project)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Step 8: Create default SliceQOSConfig (10 gbps ceiling, 1 gbps guaranteed)
        <span class="cov0" title="0">defaultSliceQOSConfig := &amp;controllerv1alpha1.SliceQoSConfig{
                ObjectMeta: metav1.ObjectMeta{
                        Name:      util.DefaultSliceQOSConfigName,
                        Namespace: projectNamespace,
                },
                Spec: controllerv1alpha1.SliceQoSConfigSpec{
                        QueueType:               "HTB",
                        Priority:                0,
                        TcType:                  "BANDWIDTH_CONTROL",
                        BandwidthCeilingKbps:    10000000,
                        BandwidthGuaranteedKbps: 1000000,
                        DscpClass:               "AF11",
                },
        }
        // check if default SliceQOSConfig exists
        found, err = util.GetResourceIfExist(
                ctx,
                types.NamespacedName{
                        Name:      util.DefaultSliceQOSConfigName,
                        Namespace: projectNamespace,
                },
                defaultSliceQOSConfig)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                err = util.CreateResource(ctx, defaultSliceQOSConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">eventRecorder.WithNamespace(projectNamespace)
                logger.Infof("default SliceQOSConfig %s created", util.DefaultSliceQOSConfigName)
                util.RecordEvent(ctx, eventRecorder, defaultSliceQOSConfig, nil, events.EventDefaultSliceQoSConfigCreated)
                t.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "created",
                                "event":       string(events.EventDefaultSliceQoSConfigCreated),
                                "object_name": defaultSliceQOSConfig.Name,
                                "object_kind": metricKindSliceQoSConfig,
                        },
                )</span>
        }

        <span class="cov0" title="0">logger.Infof("project %s reconciled", req.Name)
        return ctrl.Result{}, nil</span>
}

func (t *ProjectService) CleanUpProjectResources(ctx context.Context, namespace string) (ctrl.Result, error) <span class="cov0" title="0">{
        if shouldReturn, result, reconErr := util.IsReconciled(t.se.DeleteServiceExportConfigs(ctx, namespace)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>
        <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(t.sc.DeleteSliceConfigs(ctx, namespace)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>
        <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(t.c.DeleteClusters(ctx, namespace)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>
        <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(t.q.DeleteSliceQoSConfig(ctx, namespace)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>
        <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(t.ns.DeleteNamespace(ctx, namespace)); shouldReturn </span><span class="cov0" title="0">{
                return result, reconErr
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// Fetch namespace ConfigMap from controller cluster
func (p *ProjectService) getNamespaceConfigFromConfigMap(ctx context.Context) (map[string]string, map[string]string, error) <span class="cov0" title="0">{

        cm := &amp;corev1.ConfigMap{}
        found, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                Name:      "namespace-labels-config",
                Namespace: ControllerNamespace,
        }, cm)

        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">labels := make(map[string]string)
        annotations := make(map[string]string)

        if err := json.Unmarshal([]byte(cm.Data["labels"]), &amp;labels); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">if err := json.Unmarshal([]byte(cm.Data["annotations"]), &amp;annotations); err != nil </span><span class="cov0" title="0">{
                return labels, nil, err
        }</span>

        <span class="cov0" title="0">return labels, annotations, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"
        "os"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
        "strings"

        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"

        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/util"
        corev1 "k8s.io/api/core/v1"
        rbacv1 "k8s.io/api/rbac/v1"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// ValidateProjectCreate is a function to validate the creation of project
func ValidateProjectCreate(ctx context.Context, project *controllerv1alpha1.Project) (admission.Warnings, error) <span class="cov0" title="0">{
        if err := validateAppliedInControllerNamespace(ctx, project); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Project"}, project.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateProjectName(project.Name); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Project"}, project.Name, field.ErrorList{err})
        }</span>
        // FIXME: Remove the comment after testing.
        // Validation for existing project namespace is not required. User may want to use an existing namespace.
        // if err := validateProjectNamespaceIfAlreadyExists(ctx, project.Name); err != nil {
        //         return apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Project"}, project.Name, field.ErrorList{err})
        // }
        <span class="cov0" title="0">if err := validateDNSCompliantSANames(ctx, project); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Project"}, project.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// ValidateProjectUpdate is a function to verify the project - service account, role binding, service account names
func ValidateProjectUpdate(ctx context.Context, project *controllerv1alpha1.Project) (admission.Warnings, error) <span class="cov0" title="0">{
        if err := validateServiceAccount(ctx, project); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Project"}, project.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateRoleBinding(ctx, project); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Project"}, project.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateDNSCompliantSANames(ctx, project); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Project"}, project.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func ValidateProjectDelete(ctx context.Context, project *controllerv1alpha1.Project) (admission.Warnings, error) <span class="cov0" title="0">{
        if exists := validateIfSliceConfigExists(ctx, project); exists </span><span class="cov0" title="0">{
                err := field.Forbidden(field.NewPath("Project"), "The Project can be delete only after deleting the slice config")
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "Project"}, project.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func validateIfSliceConfigExists(ctx context.Context, project *controllerv1alpha1.Project) bool <span class="cov0" title="0">{
        sliceConfig := &amp;controllerv1alpha1.SliceConfigList{}
        projectNamespace := fmt.Sprintf(ProjectNamespacePrefix, project.GetName())
        err := util.ListResources(ctx, sliceConfig, client.InNamespace(projectNamespace))
        // if the only existing slice config is the default slice config, the project can be deleted
        if err == nil &amp;&amp; len(sliceConfig.Items) == 1 &amp;&amp; sliceConfig.Items[0].Name == fmt.Sprintf(util.DefaultProjectSliceName, project.GetName()) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if err == nil &amp;&amp; len(sliceConfig.Items) &gt; 0 </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func validateProjectName(name string) *field.Error <span class="cov0" title="0">{
        if strings.Contains(name, ".") </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("name"), name, "cannot contain dot(.)")
        }</span>
        <span class="cov0" title="0">if len(name) &gt; 30 </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("name"), name, "cannot contain more than 30 characters")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateAppliedInControllerNamespace is a function to verify if project is applied in kubeslice
func validateAppliedInControllerNamespace(ctx context.Context, project *controllerv1alpha1.Project) *field.Error <span class="cov0" title="0">{
        if project.Namespace != os.Getenv("KUBESLICE_CONTROLLER_MANAGER_NAMESPACE") </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("namespace"), project.Namespace, "project must be applied on kubeslice-manager namespace - "+os.Getenv("KUBESLICE_CONTROLLER_MANAGER_NAMESPACE"))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// // validateProjectNamespaceIfAlreadyExists is a function validate the whether the project namespace already exists or not
// func validateProjectNamespaceIfAlreadyExists(ctx context.Context, projectName string) *field.Error {
//         projectNamespace := fmt.Sprintf(ProjectNamespacePrefix, projectName)
//         if exist, _ := util.GetResourceIfExist(ctx, client.ObjectKey{Name: projectNamespace}, &amp;corev1.Namespace{}); exist {
//                 return field.Invalid(field.NewPath("project namespace"), projectNamespace, "already exists")
//         }
//         return nil
// }

// validateDNSCompliantSANames is a function to validate the service account name whether it is DNS compliant
func validateDNSCompliantSANames(ctx context.Context, project *controllerv1alpha1.Project) *field.Error <span class="cov0" title="0">{
        readNames := project.Spec.ServiceAccount.ReadOnly
        for _, name := range readNames </span><span class="cov0" title="0">{
                if !util.IsDNSCompliant(name) </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("spec").Child("serviceAccount").Child("readOnly"), name, "is not valid.")
                }</span>
        }
        <span class="cov0" title="0">writeNames := project.Spec.ServiceAccount.ReadWrite
        for _, name := range writeNames </span><span class="cov0" title="0">{
                if !util.IsDNSCompliant(name) </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("spec").Child("serviceAccount").Child("readWrite"), name, "is not valid.")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateServiceAccount is a function to validate the service account
func validateServiceAccount(ctx context.Context, project *controllerv1alpha1.Project) *field.Error <span class="cov0" title="0">{
        projectNamespace := fmt.Sprintf(ProjectNamespacePrefix, project.Name)
        // structured validation errors.
        err := validateSANamesIfAlreadyExists(ctx, project, project.Spec.ServiceAccount.ReadOnly, projectNamespace, ServiceAccountReadOnlyUser, "readOnly")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = validateSANamesIfAlreadyExists(ctx, project, project.Spec.ServiceAccount.ReadWrite, projectNamespace, ServiceAccountReadWriteUser, "readWrite")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateRoleBindingIfExists is a function to verify the role like read only, readwrite
func validateRoleBinding(ctx context.Context, project *controllerv1alpha1.Project) *field.Error <span class="cov0" title="0">{
        projectNamespace := fmt.Sprintf(ProjectNamespacePrefix, project.Name)
        // structured validation errors.
        err := validateRoleBindingIfExists(ctx, project, project.Spec.ServiceAccount.ReadOnly, projectNamespace, RoleBindingReadOnlyUser, "readOnly")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = validateRoleBindingIfExists(ctx, project, project.Spec.ServiceAccount.ReadWrite, projectNamespace, RoleBindingReadWriteUser, "readWrite")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateRoleBindingIfExists(ctx context.Context, project *controllerv1alpha1.Project, names []string, projectNamespace, format, child string) *field.Error <span class="cov0" title="0">{
        completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(project), project.GetName())
        labels := util.GetOwnerLabel(completeResourceName)
        for _, name := range names </span><span class="cov0" title="0">{
                roleBindingNamespacedName := client.ObjectKey{
                        Namespace: projectNamespace,
                        Name:      fmt.Sprintf(format, name),
                }
                actualRoleBinding := rbacv1.RoleBinding{}
                exist, _ := util.GetResourceIfExist(ctx, roleBindingNamespacedName, &amp;actualRoleBinding)
                if exist </span><span class="cov0" title="0">{
                        for key, value := range labels </span><span class="cov0" title="0">{
                                if actualRoleBinding.Labels[key] != value </span><span class="cov0" title="0">{
                                        return field.Invalid(field.NewPath("spec").Child("roleBinding").Child(child), name, "already exists")
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// validateSANamesIfAlreadyExists is a function to validate the service account name if already exists
func validateSANamesIfAlreadyExists(ctx context.Context, project *controllerv1alpha1.Project, names []string, projectNamespace, format, child string) *field.Error <span class="cov0" title="0">{
        completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(project), project.GetName())
        labels := util.GetOwnerLabel(completeResourceName)
        for _, name := range names </span><span class="cov0" title="0">{
                serviceAccountNamespacedName := client.ObjectKey{
                        Namespace: projectNamespace,
                        Name:      fmt.Sprintf(format, name),
                }
                sa := corev1.ServiceAccount{}
                exist, _ := util.GetResourceIfExist(ctx, serviceAccountNamespacedName, &amp;sa)
                if exist </span><span class="cov0" title="0">{
                        for key, value := range labels </span><span class="cov0" title="0">{
                                if sa.Labels[key] != value </span><span class="cov0" title="0">{
                                        return field.Invalid(field.NewPath("spec").Child("serviceAccount").Child(child), name, "already exists")
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "github.com/kubeslice/kubeslice-controller/metrics"

        "github.com/kubeslice/kubeslice-controller/events"
        "github.com/kubeslice/kubeslice-controller/util"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type ISecretService interface {
        DeleteSecret(ctx context.Context, namespace string, secretName string) (ctrl.Result, error)
}

type SecretService struct {
        mf metrics.IMetricRecorder
}

// DeleteSecret is a function to delete the secret
func (s *SecretService) DeleteSecret(ctx context.Context, namespace string, secretName string) (ctrl.Result, error) <span class="cov0" title="0">{
        nsResource := &amp;corev1.Secret{}
        found, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                Name:      secretName,
                Namespace: namespace,
        }, nsResource)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return ctrl.Result{}, nil
        }</span>

        //Load Event Recorder with project name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).WithProject(util.GetProjectName(nsResource.Namespace)).WithNamespace(nsResource.Namespace)

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(nsResource.Namespace)).
                WithNamespace(nsResource.Namespace)

        if found </span><span class="cov0" title="0">{
                err = util.DeleteResource(ctx, &amp;corev1.Secret{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      secretName,
                                Namespace: namespace,
                        },
                })
                if err != nil </span><span class="cov0" title="0">{
                        //Register an event for secret deletion failure
                        util.RecordEvent(ctx, eventRecorder, nsResource, nil, events.EventSecretDeletionFailed)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventSecretDeletionFailed),
                                        "object_name": nsResource.Name,
                                        "object_kind": metricKindSecret,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                //Register an event for secret deletion
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, nsResource, nil, events.EventSecretDeleted)
                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventSecretDeleted),
                                "object_name": nsResource.Name,
                                "object_kind": metricKindSecret,
                        },
                )</span>
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"
        "github.com/kubeslice/kubeslice-controller/metrics"

        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/events"
        "github.com/kubeslice/kubeslice-controller/util"
        "go.uber.org/zap"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type IServiceExportConfigService interface {
        ReconcileServiceExportConfig(ctx context.Context, req ctrl.Request) (ctrl.Result, error)
        DeleteServiceExportConfigs(ctx context.Context, namespace string) (ctrl.Result, error)
        DeleteServiceExportConfigByParticipatingSliceConfig(ctx context.Context, sliceName string, namespace string) error
}

type ServiceExportConfigService struct {
        ses IWorkerServiceImportService
        mf  metrics.IMetricRecorder
}

// ReconcileServiceExportConfig is a function to reconcile the service export config
func (s *ServiceExportConfigService) ReconcileServiceExportConfig(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        // Step 0: Get project resource
        logger := util.CtxLogger(ctx)
        logger.Infof("Starting Recoincilation of ServiceExportConfig with name %s in namespace %s",
                req.Name, req.Namespace)
        serviceExportConfig := &amp;controllerv1alpha1.ServiceExportConfig{}
        found, err := util.GetResourceIfExist(ctx, req.NamespacedName, serviceExportConfig)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                logger.Infof("ServiceExportConfig %v not found, returning from reconciler loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>
        //Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(serviceExportConfig.Namespace)).
                WithNamespace(serviceExportConfig.Namespace).
                WithSlice(serviceExportConfig.Labels["original-slice-name"])

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(serviceExportConfig.Namespace)).
                WithNamespace(serviceExportConfig.Namespace).
                WithSlice(serviceExportConfig.Labels["original-slice-name"])

        //Step 1: Finalizers
        if serviceExportConfig.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                logger.Debugf("Not deleting")
                if !util.ContainsString(serviceExportConfig.GetFinalizers(), serviceExportConfigFinalizer) </span><span class="cov0" title="0">{
                        if shouldReturn, result, reconErr := util.IsReconciled(util.AddFinalizer(ctx, serviceExportConfig, serviceExportConfigFinalizer)); shouldReturn </span><span class="cov0" title="0">{
                                return result, reconErr
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                logger.Debug("starting delete for serviceExportConfig", req.NamespacedName)
                // todo: delete logic
                if shouldReturn, result, reconErr := util.IsReconciled(s.cleanUpServiceExportConfigResources(ctx, serviceExportConfig, req.Namespace)); shouldReturn </span><span class="cov0" title="0">{
                        return result, reconErr
                }</span>
                <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(util.RemoveFinalizer(ctx, serviceExportConfig, serviceExportConfigFinalizer)); shouldReturn </span><span class="cov0" title="0">{
                        //Register an event for service export config deletion failure
                        util.RecordEvent(ctx, eventRecorder, serviceExportConfig, nil, events.EventServiceExportConfigDeletionFailed)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventServiceExportConfigDeletionFailed),
                                        "object_name": serviceExportConfig.Name,
                                        "object_kind": metricKindServiceExportConfig,
                                },
                        )
                        return result, reconErr
                }</span>
                //Register an event for service export config deletion
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, serviceExportConfig, nil, events.EventServiceExportConfigDeleted)
                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventServiceExportConfigDeleted),
                                "object_name": serviceExportConfig.Name,
                                "object_kind": metricKindServiceExportConfig,
                        },
                )
                return ctrl.Result{}, err</span>
        }
        //Step 2: Get the slice based upon the sliceName and sliceNamespace
        <span class="cov0" title="0">slice := controllerv1alpha1.SliceConfig{}
        exist, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                Name:      serviceExportConfig.Spec.SliceName,
                Namespace: req.Namespace,
        }, &amp;slice)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !exist </span><span class="cov0" title="0">{
                logger.With(zap.Error(err)).Errorf("Slice %s doesn't exist in namespace %s",
                        serviceExportConfig.Spec.SliceName, req.Namespace)
                return ctrl.Result{}, nil
        }</span>
        // Step 3: Add labels to ServiceExportConfig (if not present)
        <span class="cov0" title="0">if serviceExportConfig.Labels["original-slice-name"] != serviceExportConfig.Spec.SliceName ||
                serviceExportConfig.Labels["worker-cluster"] != serviceExportConfig.Spec.SourceCluster ||
                serviceExportConfig.Labels["service-name"] != serviceExportConfig.Spec.ServiceName ||
                serviceExportConfig.Labels["service-namespace"] != serviceExportConfig.Spec.ServiceNamespace </span><span class="cov0" title="0">{

                if serviceExportConfig.Labels == nil </span><span class="cov0" title="0">{
                        serviceExportConfig.Labels = make(map[string]string)
                }</span>
                <span class="cov0" title="0">serviceExportConfig.Labels["original-slice-name"] = serviceExportConfig.Spec.SliceName
                serviceExportConfig.Labels["worker-cluster"] = serviceExportConfig.Spec.SourceCluster
                serviceExportConfig.Labels["service-name"] = serviceExportConfig.Spec.ServiceName
                serviceExportConfig.Labels["service-namespace"] = serviceExportConfig.Spec.ServiceNamespace
                err = util.UpdateResource(ctx, serviceExportConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        }
        <span class="cov0" title="0">ownerLabels := s.getOwnerLabelsForServiceExport(serviceExportConfig)
        err = s.ses.CreateMinimalWorkerServiceImport(ctx, slice.Spec.Clusters, req.Namespace, ownerLabels, serviceExportConfig.Spec.ServiceName, serviceExportConfig.Spec.ServiceNamespace, serviceExportConfig.Spec.SliceName, serviceExportConfig.Spec.Aliases)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

func (s *ServiceExportConfigService) cleanUpServiceExportConfigResources(ctx context.Context,
        serviceExportConfig *controllerv1alpha1.ServiceExportConfig, namespace string) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := util.CtxLogger(ctx)
        seList := controllerv1alpha1.ServiceExportConfigList{}
        if err := s.ses.LookupServiceExportForService(ctx, &amp;seList, serviceExportConfig.Namespace, serviceExportConfig.Spec.ServiceName, serviceExportConfig.Spec.ServiceNamespace, serviceExportConfig.Spec.SliceName); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">ownershipLabel := s.getOwnerLabelsForServiceExport(serviceExportConfig)
        // If no ServiceExportConfig are found: delete all service imports
        // If exactly 1 ServiceExportConfig is found, and it belongs to same cluster for which the service export is being deleted for (race condition): delete all service imports
        if len(seList.Items) == 0 || (len(seList.Items) == 1 &amp;&amp; seList.Items[0].Spec.SourceCluster == serviceExportConfig.Spec.SourceCluster) </span><span class="cov0" title="0">{
                err := s.ses.DeleteWorkerServiceImportByLabel(ctx, ownershipLabel, namespace)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        } else<span class="cov0" title="0"> {
                list, err := s.ses.ListWorkerServiceImport(ctx, ownershipLabel, serviceExportConfig.Namespace)
                if err != nil </span><span class="cov0" title="0">{
                        logger.With(zap.Error(err)).Errorf("failed to list worker service imports with labels %v", ownershipLabel)
                }</span>
                <span class="cov0" title="0">err = s.ses.ForceReconciliation(ctx, list)
                if err != nil </span><span class="cov0" title="0">{
                        logger.With(zap.Error(err)).Errorf("failed to queue worker service imports for reconciliation with labels %v", ownershipLabel)
                }</span>
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// DeleteServiceExportConfigs is a function to delete the export configs
func (s *ServiceExportConfigService) DeleteServiceExportConfigs(ctx context.Context, namespace string) (ctrl.Result, error) <span class="cov0" title="0">{
        serviceExports := &amp;controllerv1alpha1.ServiceExportConfigList{}
        err := util.ListResources(ctx, serviceExports, client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">for _, serviceExport := range serviceExports.Items </span><span class="cov0" title="0">{
                //Load Event Recorder with project name, slice name and namespace
                eventRecorder := util.CtxEventRecorder(ctx).
                        WithProject(util.GetProjectName(serviceExport.Namespace)).
                        WithNamespace(serviceExport.Namespace).
                        WithSlice(serviceExport.Labels["original-slice-name"])

                // Load metrics with project name and namespace
                s.mf.WithProject(util.GetProjectName(serviceExport.Namespace)).
                        WithNamespace(serviceExport.Namespace).
                        WithSlice(serviceExport.Labels["original-slice-name"])

                err = util.DeleteResource(ctx, &amp;serviceExport)
                if err != nil </span><span class="cov0" title="0">{
                        //Register an event for service export config deletion
                        util.RecordEvent(ctx, eventRecorder, &amp;serviceExport, nil, events.EventServiceExportConfigDeletionFailed)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventServiceExportConfigDeletionFailed),
                                        "object_name": serviceExport.Name,
                                        "object_kind": metricKindServiceExportConfig,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                //Register an event for service export config deletion
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;serviceExport, nil, events.EventServiceExportConfigDeleted)
                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventServiceExportConfigDeleted),
                                "object_name": serviceExport.Name,
                                "object_kind": metricKindServiceExportConfig,
                        },
                )</span>
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// DeleteServiceExportConfigByParticipatingSliceConfig is a function to delete the export config which are in slice
func (s *ServiceExportConfigService) DeleteServiceExportConfigByParticipatingSliceConfig(ctx context.Context, sliceName string, namespace string) error <span class="cov0" title="0">{
        serviceExports, err := s.ListServiceExportConfigs(ctx, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, serviceExport := range serviceExports </span><span class="cov0" title="0">{
                if serviceExport.Labels["original-slice-name"] == sliceName </span><span class="cov0" title="0">{
                        //Load Event Recorder with project name, slice name and namespace
                        eventRecorder := util.CtxEventRecorder(ctx).
                                WithProject(util.GetProjectName(serviceExport.Namespace)).
                                WithNamespace(serviceExport.Namespace).
                                WithSlice(serviceExport.Labels["original-slice-name"])

                        // Load metrics with project name and namespace
                        s.mf.WithProject(util.GetProjectName(serviceExport.Namespace)).
                                WithNamespace(serviceExport.Namespace).
                                WithSlice(serviceExport.Labels["original-slice-name"])

                        err = util.DeleteResource(ctx, &amp;serviceExport)
                        if err != nil </span><span class="cov0" title="0">{
                                //Register an event for service export config deletion
                                util.RecordEvent(ctx, eventRecorder, &amp;serviceExport, nil, events.EventServiceExportConfigDeletionFailed)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deletion_failed",
                                                "event":       string(events.EventServiceExportConfigDeletionFailed),
                                                "object_name": serviceExport.Name,
                                                "object_kind": metricKindServiceExportConfig,
                                        },
                                )
                                return err
                        }</span>
                        //Register an event for service export config deletion
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;serviceExport, nil, events.EventServiceExportConfigDeleted)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deleted",
                                        "event":       string(events.EventServiceExportConfigDeleted),
                                        "object_name": serviceExport.Name,
                                        "object_kind": metricKindServiceExportConfig,
                                },
                        )</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *ServiceExportConfigService) ListServiceExportConfigs(ctx context.Context, namespace string) ([]controllerv1alpha1.ServiceExportConfig, error) <span class="cov0" title="0">{
        serviceExports := &amp;controllerv1alpha1.ServiceExportConfigList{}
        err := util.ListResources(ctx, serviceExports, client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return serviceExports.Items, nil</span>
}

func (s *ServiceExportConfigService) getOwnerLabelsForServiceExport(serviceExportConfig *controllerv1alpha1.ServiceExportConfig) map[string]string <span class="cov0" title="0">{
        ownerLabels := make(map[string]string)
        resourceName := fmt.Sprintf("%s-%s-%s", serviceExportConfig.Spec.ServiceName, serviceExportConfig.Spec.ServiceNamespace, serviceExportConfig.Spec.SliceName)
        // validating the length of label
        completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(serviceExportConfig), resourceName)
        ownerLabels = util.GetOwnerLabel(completeResourceName)
        return ownerLabels
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/util"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// ValidateServiceExportConfigCreate is a function to validate the create process of service export config
func ValidateServiceExportConfigCreate(ctx context.Context, serviceExportConfig *controllerv1alpha1.ServiceExportConfig) (admission.Warnings, error) <span class="cov0" title="0">{
        if err := validateServiceExportConfigNamespace(ctx, serviceExportConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "ServiceExportConfig"}, serviceExportConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateServiceExportClusterAndSlice(ctx, serviceExportConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "ServiceExportConfig"}, serviceExportConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateServiceEndpoint(ctx, serviceExportConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "ServiceExportConfig"}, serviceExportConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// ValidateServiceExportConfigUpdate is a function to validate the update process of service export config
func ValidateServiceExportConfigUpdate(ctx context.Context, serviceExportConfig *controllerv1alpha1.ServiceExportConfig) (admission.Warnings, error) <span class="cov0" title="0">{
        if err := validateServiceExportClusterAndSlice(ctx, serviceExportConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "ServiceExportConfig"}, serviceExportConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateServiceEndpoint(ctx, serviceExportConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "ServiceExportConfig"}, serviceExportConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// ValidateServiceExportConfigDelete is a function to validate the delete process of service export config
func ValidateServiceExportConfigDelete(ctx context.Context, serviceExportConfig *controllerv1alpha1.ServiceExportConfig) (admission.Warnings, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func validateServiceExportClusterAndSlice(ctx context.Context, serviceExport *controllerv1alpha1.ServiceExportConfig) *field.Error <span class="cov0" title="0">{
        cluster := &amp;controllerv1alpha1.Cluster{}
        clusterExist, _ := util.GetResourceIfExist(ctx, client.ObjectKey{Name: serviceExport.Spec.SourceCluster, Namespace: serviceExport.Namespace}, cluster)
        sliceConfig := &amp;controllerv1alpha1.SliceConfig{}
        sliceExist, _ := util.GetResourceIfExist(ctx, client.ObjectKey{Name: serviceExport.Spec.SliceName, Namespace: serviceExport.Namespace}, sliceConfig)
        if !sliceExist </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("SliceName"), serviceExport.Spec.SliceName, "There is no valid slice with this name")
        }</span>
        <span class="cov0" title="0">if !clusterExist </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("SourceCluster"), serviceExport.Spec.SourceCluster, "Cluster is not registered")
        }</span>
        <span class="cov0" title="0">if clusterExist </span><span class="cov0" title="0">{
                clusterPresentInSlice := false
                for _, clusterInSlice := range sliceConfig.Spec.Clusters </span><span class="cov0" title="0">{
                        if clusterInSlice == serviceExport.Spec.SourceCluster </span><span class="cov0" title="0">{
                                clusterPresentInSlice = true
                        }</span>
                }
                <span class="cov0" title="0">if !clusterPresentInSlice </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("Cluster"), serviceExport.Spec.SourceCluster, fmt.Sprintf("Cluster %s is not a part of the slice %s", serviceExport.Spec.SourceCluster, serviceExport.Spec.SliceName))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func validateServiceEndpoint(ctx context.Context, serviceExport *controllerv1alpha1.ServiceExportConfig) *field.Error <span class="cov0" title="0">{
        sliceName := serviceExport.Spec.SliceName
        for _, serviceDiscoveryEndPoint := range serviceExport.Spec.ServiceDiscoveryEndpoints </span><span class="cov0" title="0">{
                clusterName := serviceDiscoveryEndPoint.Cluster
                cluster := &amp;controllerv1alpha1.Cluster{}
                clusterExist, _ := util.GetResourceIfExist(ctx, client.ObjectKey{Name: clusterName, Namespace: serviceExport.Namespace}, cluster)
                sliceConfig := &amp;controllerv1alpha1.SliceConfig{}
                sliceExist, _ := util.GetResourceIfExist(ctx, client.ObjectKey{Name: sliceName, Namespace: serviceExport.Namespace}, sliceConfig)
                if !sliceExist </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("SliceName"), serviceExport.Spec.SliceName, "There is no valid slice with this name")
                }</span>
                <span class="cov0" title="0">if !clusterExist </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("ServiceDiscoveryEndpoints").Child("Cluster"), clusterName, "Cluster is not registered")
                }</span>
                <span class="cov0" title="0">if clusterExist </span><span class="cov0" title="0">{
                        clusterPresentInSlice := false
                        for _, clusterInSlice := range sliceConfig.Spec.Clusters </span><span class="cov0" title="0">{
                                if clusterInSlice == clusterName </span><span class="cov0" title="0">{
                                        clusterPresentInSlice = true
                                }</span>
                        }
                        <span class="cov0" title="0">if !clusterPresentInSlice </span><span class="cov0" title="0">{
                                return field.Invalid(field.NewPath("Spec").Child("ServiceDiscoveryEndpoints").Child("Cluster"), clusterName, fmt.Sprintf("Service Discovery Endpoint Cluster %s is not a part of the slice %s", clusterName, sliceName))
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func validateServiceExportConfigNamespace(ctx context.Context, serviceExport *controllerv1alpha1.ServiceExportConfig) *field.Error <span class="cov0" title="0">{
        namespace := &amp;corev1.Namespace{}
        exist, _ := util.GetResourceIfExist(ctx, client.ObjectKey{Name: serviceExport.Namespace}, namespace)
        if !exist || !util.CheckForProjectNamespace(namespace) </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("metadata").Child("namespace"), serviceExport.Namespace, "ServiceExportConfig must be applied on project namespace")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "time"

        "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/util"
        "go.uber.org/zap"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// RemoveWorkerFinalizers removes the finalizer specified by workerFinalizerName from the
// object's finalizers list.
// If the workerFinalizerName is not found in the initial finalizers list, all finalizers
// are removed and the function returns the reconciliation result for no-requeue.
// If the finalizers list is empty after the removal, the function returns the
// reconciliation result for no-requeue.
// If the finalizers list is non-empty after the removal, the function returns the
// reconciliation result for delayed requeue.
func RemoveWorkerFinalizers(ctx context.Context, object client.Object, workerFinalizerName string) ctrl.Result <span class="cov0" title="0">{
        logger := util.CtxLogger(ctx)
        finalizers := object.GetFinalizers()
        additionalFinalizers := make([]string, 0)
        result := ctrl.Result{}
        logger.Debugf("Attempting to remove finalizer %s from %v", workerFinalizerName, finalizers)
        if util.IsInSlice(finalizers, workerFinalizerName) </span><span class="cov0" title="0">{
                for _, finalizer := range finalizers </span><span class="cov0" title="0">{
                        if finalizer != workerFinalizerName </span><span class="cov0" title="0">{
                                additionalFinalizers = append(additionalFinalizers, finalizer)
                        }</span>
                }
                <span class="cov0" title="0">if len(additionalFinalizers) &gt; 0 </span><span class="cov0" title="0">{
                        if time.Now().Sub(object.GetDeletionTimestamp().Time) &lt; KubesliceWorkerDeleteRequeueTime*time.Minute </span><span class="cov0" title="0">{
                                result.Requeue = true
                                result.RequeueAfter = KubesliceWorkerDeleteRequeueTime * time.Minute
                                logger.Debugf("Found additional finalizers: %v. Requeuing with Reconciliation Result: %+v", additionalFinalizers, result)
                                return result
                        }</span> else<span class="cov0" title="0"> {
                                logger.Debugf("Cleaning up additional finalizers: %v because deletion grace period has exceeded", additionalFinalizers)
                        }</span>
                } else<span class="cov0" title="0"> {
                        logger.Debugf("No additional finalizers found.")
                }</span>
        }
        <span class="cov0" title="0">object.SetFinalizers(make([]string, 0))
        if err := util.UpdateResource(ctx, object); err != nil </span><span class="cov0" title="0">{
                logger.With(zap.Error(err)).Errorf("Failed to cleanup finalizers")
        }</span>
        <span class="cov0" title="0">return result</span>
}

// get Slice gateway service type for each cluster registered with given slice
func getSliceGwSvcTypes(sliceConfig *v1alpha1.SliceConfig) map[string]*v1alpha1.SliceGatewayServiceType <span class="cov0" title="0">{
        var sliceGwSvcTypeMap = make(map[string]*v1alpha1.SliceGatewayServiceType)
        if sliceConfig.Spec.SliceGatewayProvider == nil </span><span class="cov0" title="0">{
                return sliceGwSvcTypeMap
        }</span>
        <span class="cov0" title="0">for i := range sliceConfig.Spec.SliceGatewayProvider.SliceGatewayServiceType </span><span class="cov0" title="0">{
                gwSvctype := &amp;sliceConfig.Spec.SliceGatewayProvider.SliceGatewayServiceType[i]
                if gwSvctype.Cluster == "*" </span><span class="cov0" title="0">{
                        for _, cluster := range sliceConfig.Spec.Clusters </span><span class="cov0" title="0">{
                                sliceGwSvcTypeMap[cluster] = gwSvctype
                        }</span>
                } else<span class="cov0" title="0"> {
                        sliceGwSvcTypeMap[gwSvctype.Cluster] = gwSvctype
                }</span>
        }
        <span class="cov0" title="0">return sliceGwSvcTypeMap</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"
        "reflect"

        "github.com/kubeslice/kubeslice-controller/metrics"
        "go.uber.org/zap"

        "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/events"
        "github.com/kubeslice/kubeslice-controller/util"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type ISliceConfigService interface {
        ReconcileSliceConfig(ctx context.Context, req ctrl.Request) (ctrl.Result, error)
        DeleteSliceConfigs(ctx context.Context, namespace string) (ctrl.Result, error)
}

// SliceConfigService implements different interfaces -
type SliceConfigService struct {
        ns    INamespaceService
        acs   IAccessControlService
        sgs   IWorkerSliceGatewayService
        ms    IWorkerSliceConfigService
        si    IWorkerServiceImportService
        se    IServiceExportConfigService
        wsgrs IWorkerSliceGatewayRecyclerService
        mf    metrics.IMetricRecorder
        vpn   IVpnKeyRotationService
}

const NamespaceAndClusterFormat = "namespace=%s&amp;cluster=%s"

// ReconcileSliceConfig is a function to reconcile the sliceconfig
func (s *SliceConfigService) ReconcileSliceConfig(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        // Step 0: Get SliceConfig resource
        logger := util.CtxLogger(ctx)
        logger.Infof("Started Recoincilation of SliceConfig %v", req.NamespacedName)
        sliceConfig := &amp;v1alpha1.SliceConfig{}
        found, err := util.GetResourceIfExist(ctx, req.NamespacedName, sliceConfig)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                logger.Infof("sliceConfig %v not found, returning from  reconciler loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>
        // Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(sliceConfig.Namespace)).
                WithNamespace(sliceConfig.Namespace).
                WithSlice(sliceConfig.Name)

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(sliceConfig.Namespace)).
                WithNamespace(sliceConfig.Namespace).
                WithSlice(sliceConfig.Name)

        if duplicate, value := util.CheckDuplicateInArray(sliceConfig.Spec.Clusters); duplicate </span><span class="cov0" title="0">{
                logger.Infof("Duplicate cluster name %v found in sliceConfig %v", value, req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>
        // Step 1: Finalizers
        <span class="cov0" title="0">if sliceConfig.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                if !util.ContainsString(sliceConfig.GetFinalizers(), SliceConfigFinalizer) </span><span class="cov0" title="0">{
                        if shouldReturn, result, reconErr := util.IsReconciled(util.AddFinalizer(ctx, sliceConfig, SliceConfigFinalizer)); shouldReturn </span><span class="cov0" title="0">{
                                return result, reconErr
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                logger.Debug("starting delete for slice config", req.NamespacedName)
                if shouldReturn, result, reconErr := util.IsReconciled(s.cleanUpSliceConfigResources(ctx, sliceConfig, req.Namespace)); shouldReturn </span><span class="cov0" title="0">{
                        return result, reconErr
                }</span>
                <span class="cov0" title="0">if shouldReturn, result, reconErr := util.IsReconciled(util.RemoveFinalizer(ctx, sliceConfig, SliceConfigFinalizer)); shouldReturn </span><span class="cov0" title="0">{
                        // Register an event for slice config deletion fail
                        util.RecordEvent(ctx, eventRecorder, sliceConfig, nil, events.EventSliceConfigDeletionFailed)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventSliceConfigDeletionFailed),
                                        "object_name": sliceConfig.Name,
                                        "object_kind": metricKindSliceConfig,
                                },
                        )
                        return result, reconErr
                }</span>
                // Register an event for slice config deletion
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, sliceConfig, nil, events.EventSliceConfigDeleted)
                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventSliceConfigDeleted),
                                "object_name": sliceConfig.Name,
                                "object_kind": metricKindSliceConfig,
                        },
                )
                return ctrl.Result{}, err</span>
        }

        // Step 2: check if SliceConfig is in project namespace
        <span class="cov0" title="0">nsResource := &amp;corev1.Namespace{}
        found, err = util.GetResourceIfExist(ctx, client.ObjectKey{
                Name: req.Namespace,
        }, nsResource)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found || !s.checkForProjectNamespace(nsResource) </span><span class="cov0" title="0">{
                logger.Infof("Created SliceConfig %v is not in project namespace. Returning from reconciliation loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>

        // Step 3: Before creation or update of worker slice config, handle default slice appns removal if project has defaultSliceCreation enabled
        <span class="cov0" title="0">projectName := util.GetProjectName(req.Namespace)
        project := &amp;v1alpha1.Project{}
        foundProject, err := util.GetResourceIfExist(ctx, types.NamespacedName{
                Name:      projectName,
                Namespace: ControllerNamespace,
        }, project)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">if foundProject </span><span class="cov0" title="0">{
                // add missing project label to sliceConfig
                additionalLabels := util.FilterLabelsAndAnnotations(project.Labels)
                additionalAnnotations := util.FilterLabelsAndAnnotations(project.Annotations)
                if sliceConfig.Labels == nil </span><span class="cov0" title="0">{
                        sliceConfig.Labels = make(map[string]string)
                }</span>
                // check if project label is already present in sliceConfig
                <span class="cov0" title="0">isUpadataRequired := false
                for key, value := range additionalLabels </span><span class="cov0" title="0">{
                        if val, ok := sliceConfig.Labels[key]; !ok &amp;&amp; val != value </span><span class="cov0" title="0">{
                                sliceConfig.Labels[key] = value
                                isUpadataRequired = true
                        }</span>
                }
                <span class="cov0" title="0">if sliceConfig.Annotations == nil </span><span class="cov0" title="0">{
                        sliceConfig.Annotations = make(map[string]string)
                }</span>
                <span class="cov0" title="0">for key, value := range additionalAnnotations </span><span class="cov0" title="0">{
                        if val, ok := sliceConfig.Annotations[key]; !ok &amp;&amp; val != value </span><span class="cov0" title="0">{
                                sliceConfig.Annotations[key] = value
                                isUpadataRequired = true
                        }</span>
                }
                <span class="cov0" title="0">if isUpadataRequired </span><span class="cov0" title="0">{
                        if err := util.UpdateResource(ctx, sliceConfig); err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                }
        }

        <span class="cov0" title="0">if foundProject &amp;&amp; project.Spec.DefaultSliceCreation </span><span class="cov0" title="0">{
                logger.Info("found project and defaultslicecreation is enable")
                if shouldReturn, result, reconErr := util.IsReconciled(s.handleDefaultSliceConfigAppns(ctx, req, logger, projectName, sliceConfig)); shouldReturn </span><span class="cov0" title="0">{
                        return result, reconErr
                }</span>
        }

        <span class="cov0" title="0">completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(sliceConfig), sliceConfig.GetName())
        ownershipLabel := util.GetOwnerLabel(completeResourceName)

        if sliceConfig.Spec.OverlayNetworkDeploymentMode == v1alpha1.NONET </span><span class="cov0" title="0">{
                err = s.ms.CreateMinimalWorkerSliceConfigForNoNetworkSlice(ctx, sliceConfig.Spec.Clusters, req.Namespace, ownershipLabel, sliceConfig.Name)
                return ctrl.Result{}, err
        }</span>

        // Step 4: Creation of worker slice Objects and Cluster Labels
        // get cluster cidr from maxClusters of slice config
        <span class="cov0" title="0">clusterCidr := ""
        clusterCidr = util.FindCIDRByMaxClusters(sliceConfig.Spec.MaxClusters)

        // collect slice gw svc info for given clusters
        sliceGwSvcTypeMap := getSliceGwSvcTypes(sliceConfig)

        clusterMap, err := s.ms.CreateMinimalWorkerSliceConfig(ctx, sliceConfig.Spec.Clusters, req.Namespace, ownershipLabel, sliceConfig.Name, sliceConfig.Spec.SliceSubnet, clusterCidr, sliceGwSvcTypeMap)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Step 5: Resolve topology to get gateway pairs
        <span class="cov0" title="0">gatewayPairs, err := s.resolveTopologyPairs(sliceConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Failed to resolve topology for slice %s: %v", sliceConfig.Name, err)
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">logger.Infof("Resolved %d gateway pairs for slice %s", len(gatewayPairs), sliceConfig.Name)

        // Step 6: Create gateways with minimum specification
        _, err = s.sgs.CreateMinimumWorkerSliceGateways(ctx, sliceConfig.Name, sliceConfig.Spec.Clusters, req.Namespace, ownershipLabel, clusterMap, sliceConfig.Spec.SliceSubnet, clusterCidr, sliceGwSvcTypeMap, gatewayPairs)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">logger.Infof("sliceConfig %v reconciled", req.NamespacedName)

        // Step 7: Create VPNKeyRotation CR
        // TODO(rahul): handle change in rotation interval
        if err := s.vpn.CreateMinimalVpnKeyRotationConfig(ctx, sliceConfig.Name, sliceConfig.Namespace, sliceConfig.Spec.RotationInterval); err != nil </span><span class="cov0" title="0">{
                // register an event
                util.RecordEvent(ctx, eventRecorder, sliceConfig, nil, events.EventVPNKeyRotationConfigCreationFailed)
                return ctrl.Result{}, err
        }</span>
        // Step 8: update cluster info into vpnkeyrotation Config
        <span class="cov0" title="0">if _, err := s.vpn.ReconcileClusters(ctx, sliceConfig.Name, sliceConfig.Namespace, sliceConfig.Spec.Clusters); err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        // Step 9: Create ServiceImport Objects
        <span class="cov0" title="0">serviceExports := &amp;v1alpha1.ServiceExportConfigList{}
        _, err = s.getServiceExportBySliceName(ctx, req.Namespace, sliceConfig.Name, serviceExports)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if len(serviceExports.Items) &gt; 0 </span><span class="cov0" title="0">{
                // iterate service export configs
                for _, serviceExport := range serviceExports.Items </span><span class="cov0" title="0">{
                        err = s.si.CreateMinimalWorkerServiceImport(ctx, sliceConfig.Spec.Clusters, req.Namespace, s.getOwnerLabelsForServiceExport(&amp;serviceExport), serviceExport.Spec.ServiceName, serviceExport.Spec.ServiceNamespace, serviceExport.Spec.SliceName, serviceExport.Spec.Aliases)
                        if err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// checkForProjectNamespace is a function to check the namespace is in proper format
func (s *SliceConfigService) checkForProjectNamespace(namespace *corev1.Namespace) bool <span class="cov0" title="0">{
        return namespace.Labels[util.LabelName] == fmt.Sprintf(util.LabelValue, "Project", namespace.Name)
}</span>

// cleanUpSliceConfigResources is a function to delete the slice config resources
func (s *SliceConfigService) cleanUpSliceConfigResources(ctx context.Context,
        slice *v1alpha1.SliceConfig, namespace string,
) (ctrl.Result, error) <span class="cov0" title="0">{
        completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(slice), slice.GetName())
        ownershipLabel := util.GetOwnerLabel(completeResourceName)
        err := s.sgs.DeleteWorkerSliceGatewaysByLabel(ctx, ownershipLabel, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">err = s.ms.DeleteWorkerSliceConfigByLabel(ctx, ownershipLabel, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">recyclerLabel := map[string]string{
                "slice_name": slice.Name,
        }
        err = s.wsgrs.DeleteWorkerSliceGatewayRecyclersByLabel(ctx, recyclerLabel, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// DeleteSliceConfigs is a function to delete the sliceconfigs
func (s *SliceConfigService) DeleteSliceConfigs(ctx context.Context, namespace string) (ctrl.Result, error) <span class="cov0" title="0">{
        sliceConfigs := &amp;v1alpha1.SliceConfigList{}
        err := util.ListResources(ctx, sliceConfigs, client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">for _, sliceConfig := range sliceConfigs.Items </span><span class="cov0" title="0">{
                // Load Event Recorder with project name, slice name and namespace
                eventRecorder := util.CtxEventRecorder(ctx).
                        WithProject(util.GetProjectName(sliceConfig.Namespace)).
                        WithNamespace(sliceConfig.Namespace).
                        WithSlice(sliceConfig.Name)

                // Load metrics with project name and namespace
                s.mf.WithProject(util.GetProjectName(sliceConfig.Namespace)).
                        WithNamespace(sliceConfig.Namespace).
                        WithSlice(sliceConfig.Name)

                err = util.DeleteResource(ctx, &amp;sliceConfig)
                if err != nil </span><span class="cov0" title="0">{
                        // Register an event for slice config deletion fail
                        util.RecordEvent(ctx, eventRecorder, &amp;sliceConfig, nil, events.EventSliceConfigDeletionFailed)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventSliceConfigDeletionFailed),
                                        "object_name": sliceConfig.Name,
                                        "object_kind": metricKindSliceConfig,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                // Register an event for slice config deletion
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;sliceConfig, nil, events.EventSliceConfigDeleted)
                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventSliceConfigDeleted),
                                "object_name": sliceConfig.Name,
                                "object_kind": metricKindSliceConfig,
                        },
                )</span>
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// getServiceExportBySliceName is a function to get the service export configs by slice name
func (s *SliceConfigService) getServiceExportBySliceName(ctx context.Context, namespace string, sliceName string, serviceExports *v1alpha1.ServiceExportConfigList) (ctrl.Result, error) <span class="cov0" title="0">{
        label := map[string]string{
                "original-slice-name": sliceName,
        }
        err := util.ListResources(ctx, serviceExports, client.InNamespace(namespace), client.MatchingLabels(label))
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// getOwnerLabelsForServiceExport is a function to get the owner labels for service export
func (s *SliceConfigService) getOwnerLabelsForServiceExport(serviceExportConfig *v1alpha1.ServiceExportConfig) map[string]string <span class="cov0" title="0">{
        ownerLabels := make(map[string]string)
        resourceName := fmt.Sprintf("%s-%s-%s", serviceExportConfig.Spec.ServiceName, serviceExportConfig.Spec.ServiceNamespace, serviceExportConfig.Spec.SliceName)
        completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(serviceExportConfig), resourceName)
        ownerLabels = util.GetOwnerLabel(completeResourceName)
        return ownerLabels
}</span>

func (s *SliceConfigService) constructApplicationNamespaceMap(registeredClusters []string, sliceConfigApplicationNamespaces []v1alpha1.SliceNamespaceSelection) map[string]struct{} <span class="cov0" title="0">{
        nsMap := make(map[string]struct{})
        for _, appns := range sliceConfigApplicationNamespaces </span><span class="cov0" title="0">{
                if len(appns.Clusters) &gt; 0 &amp;&amp; appns.Clusters[0] == "*" </span><span class="cov0" title="0">{
                        // add all cluster and namespace combnination to the map
                        for _, cluster := range registeredClusters </span><span class="cov0" title="0">{
                                namespaceToClusterMapKey := fmt.Sprintf(NamespaceAndClusterFormat, appns.Namespace, cluster)
                                nsMap[namespaceToClusterMapKey] = struct{}{}
                        }</span>
                } else<span class="cov0" title="0"> {
                        for _, cluster := range appns.Clusters </span><span class="cov0" title="0">{
                                namespaceToClusterMapKey := fmt.Sprintf(NamespaceAndClusterFormat, appns.Namespace, cluster)
                                nsMap[namespaceToClusterMapKey] = struct{}{}
                        }</span>
                }
        }
        <span class="cov0" title="0">return nsMap</span>
}

func (s *SliceConfigService) removeSliceApplicationNamespaces(namespaceWithCluster map[string]struct{}, defaultSliceConfigApplicationNamespaces []v1alpha1.SliceNamespaceSelection) []v1alpha1.SliceNamespaceSelection <span class="cov0" title="0">{
        filteredApplicaitonNamespaces := []v1alpha1.SliceNamespaceSelection{}

        for _, appns := range defaultSliceConfigApplicationNamespaces </span><span class="cov0" title="0">{
                if len(appns.Clusters) &gt; 1 </span><span class="cov0" title="0">{
                        for _, cluster := range appns.Clusters </span><span class="cov0" title="0">{
                                mapKey := fmt.Sprintf(NamespaceAndClusterFormat, appns.Namespace, cluster)
                                if _, ok := namespaceWithCluster[mapKey]; ok </span><span class="cov0" title="0">{
                                        appns.Clusters = util.RemoveElementFromArray(appns.Clusters, cluster)
                                }</span>
                        }
                        <span class="cov0" title="0">filteredApplicaitonNamespaces = append(filteredApplicaitonNamespaces, appns)</span>
                } else<span class="cov0" title="0"> {
                        mapKey := fmt.Sprintf(NamespaceAndClusterFormat, appns.Namespace, appns.Clusters[0])
                        if _, ok := namespaceWithCluster[mapKey]; ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">filteredApplicaitonNamespaces = append(filteredApplicaitonNamespaces, appns)</span>
                }
        }
        <span class="cov0" title="0">return filteredApplicaitonNamespaces</span>
}

func (s *SliceConfigService) handleDefaultSliceConfigAppns(ctx context.Context, req ctrl.Request, logger *zap.SugaredLogger, projectName string, sliceConfig *v1alpha1.SliceConfig) (ctrl.Result, error) <span class="cov0" title="0">{
        defaultSliceName := fmt.Sprintf(util.DefaultProjectSliceName, projectName)
        defaultProjectSlice := &amp;v1alpha1.SliceConfig{}
        defaultSliceNamespacedName := types.NamespacedName{
                Namespace: req.Namespace,
                Name:      defaultSliceName,
        }
        foundDefaultSlice, err := util.GetResourceIfExist(ctx, defaultSliceNamespacedName, defaultProjectSlice)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("error while getting default slice %v", defaultSliceName)
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if foundDefaultSlice </span><span class="cov0" title="0">{

                logger.Info("found default slice", defaultProjectSlice.Name)
                if defaultProjectSlice.Name == sliceConfig.Name </span><span class="cov0" title="0">{
                        // reconciling for default-slice so no need to remove ns
                        return ctrl.Result{}, nil
                }</span>
                // remove all namespaces from default slice that are present in this slice config
                <span class="cov0" title="0">defaultApplicationNamespaces := defaultProjectSlice.Spec.NamespaceIsolationProfile.ApplicationNamespaces
                sliceConfigApplicationNamespaces := sliceConfig.Spec.NamespaceIsolationProfile.ApplicationNamespaces

                sliceAppnsMap := s.constructApplicationNamespaceMap(sliceConfig.Spec.Clusters, sliceConfigApplicationNamespaces)
                defaultAppnsMap := s.constructApplicationNamespaceMap(defaultProjectSlice.Spec.Clusters, defaultApplicationNamespaces)
                appnsMapToRemove := make(map[string]struct{})

                for key := range sliceAppnsMap </span><span class="cov0" title="0">{
                        // if same namespace and cluster is present in default slice, then  add it to appnsMapToRemove
                        if namespaceWithCluster, ok := defaultAppnsMap[key]; ok </span><span class="cov0" title="0">{
                                appnsMapToRemove[key] = namespaceWithCluster
                        }</span>
                }

                <span class="cov0" title="0">filteredDefaultApplicationNamespaces := s.removeSliceApplicationNamespaces(appnsMapToRemove, defaultApplicationNamespaces)

                if !reflect.DeepEqual(filteredDefaultApplicationNamespaces, defaultApplicationNamespaces) </span><span class="cov0" title="0">{
                        logger.Info("updating default slice config from %s to %s", defaultApplicationNamespaces, filteredDefaultApplicationNamespaces)
                        defaultProjectSlice.Spec.NamespaceIsolationProfile.ApplicationNamespaces = filteredDefaultApplicationNamespaces
                        err := util.UpdateResource(ctx, defaultProjectSlice)
                        if err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, err
                        }</span>
                        <span class="cov0" title="0">logger.Info("successfully updated default slice config")

                        return ctrl.Result{}, nil</span>
                }
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

func (s *SliceConfigService) resolveTopologyPairs(sliceConfig *v1alpha1.SliceConfig) ([]util.GatewayPair, error) <span class="cov8" title="1">{
        clusters := sliceConfig.Spec.Clusters

        // Default to full-mesh if no topology config
        if sliceConfig.Spec.TopologyConfig == nil </span><span class="cov8" title="1">{
                return s.resolveFullMeshTopology(clusters), nil
        }</span>

        <span class="cov8" title="1">switch sliceConfig.Spec.TopologyConfig.TopologyType </span>{
        case v1alpha1.TopologyFullMesh, "":<span class="cov8" title="1">
                return s.resolveFullMeshTopology(clusters), nil</span>
        case v1alpha1.TopologyCustom:<span class="cov8" title="1">
                return s.resolveCustomTopology(clusters, sliceConfig.Spec.TopologyConfig.ConnectivityMatrix)</span>
        case v1alpha1.TopologyRestricted:<span class="cov8" title="1">
                return s.resolveRestrictedTopology(clusters, sliceConfig.Spec.TopologyConfig.ForbiddenEdges)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unknown topology type: %s", sliceConfig.Spec.TopologyConfig.TopologyType)</span>
        }
}

// resolveFullMeshTopology creates bidirectional pairs for all cluster combinations
func (s *SliceConfigService) resolveFullMeshTopology(clusters []string) []util.GatewayPair <span class="cov8" title="1">{
        if len(clusters) &lt; 2 </span><span class="cov8" title="1">{
                return []util.GatewayPair{}
        }</span>

        <span class="cov8" title="1">pairs := make([]util.GatewayPair, 0, len(clusters)*(len(clusters)-1)/2)
        for i := 0; i &lt; len(clusters); i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(clusters); j++ </span><span class="cov8" title="1">{
                        pairs = append(pairs, util.GatewayPair{
                                Source:        clusters[i],
                                Target:        clusters[j],
                                Bidirectional: true,
                        })
                }</span>
        }
        <span class="cov8" title="1">return pairs</span>
}

// resolveCustomTopology creates pairs based on explicit connectivity matrix
func (s *SliceConfigService) resolveCustomTopology(clusters []string, matrix []v1alpha1.ConnectivityEntry) ([]util.GatewayPair, error) <span class="cov8" title="1">{
        if len(matrix) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("custom topology requires connectivity matrix")
        }</span>

        <span class="cov8" title="1">clusterSet := s.makeClusterSet(clusters)
        pairs := make([]util.GatewayPair, 0)

        for _, entry := range matrix </span><span class="cov8" title="1">{
                if !clusterSet[entry.SourceCluster] </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("connectivity entry references unknown source cluster: %s", entry.SourceCluster)
                }</span>
                <span class="cov8" title="1">for _, target := range entry.TargetClusters </span><span class="cov8" title="1">{
                        if !clusterSet[target] </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("connectivity entry references unknown target cluster: %s", target)
                        }</span>
                        <span class="cov8" title="1">pairs = append(pairs, util.GatewayPair{
                                Source:        entry.SourceCluster,
                                Target:        target,
                                Bidirectional: true,
                        })</span>
                }
        }

        <span class="cov8" title="1">return pairs, nil</span>
}

// resolveRestrictedTopology creates full-mesh and removes forbidden edges
func (s *SliceConfigService) resolveRestrictedTopology(clusters []string, forbiddenEdges []v1alpha1.ForbiddenEdge) ([]util.GatewayPair, error) <span class="cov8" title="1">{
        // Start with full mesh
        allPairs := s.resolveFullMeshTopology(clusters)

        if len(forbiddenEdges) == 0 </span><span class="cov8" title="1">{
                return allPairs, nil
        }</span>

        // Build forbidden set
        <span class="cov8" title="1">forbidden := s.buildForbiddenSet(forbiddenEdges)

        // Filter out forbidden pairs
        filtered := s.filterForbiddenPairs(allPairs, forbidden)

        // Ensure connectivity (add bridge edges if partitioned)
        preservedPairs, err := s.ensureConnectivity(clusters, filtered, forbidden)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return preservedPairs, nil</span>
}

// buildForbiddenSet creates a map of forbidden edges
func (s *SliceConfigService) buildForbiddenSet(forbiddenEdges []v1alpha1.ForbiddenEdge) map[string]bool <span class="cov8" title="1">{
        forbidden := make(map[string]bool)
        for _, edge := range forbiddenEdges </span><span class="cov8" title="1">{
                for _, target := range edge.TargetClusters </span><span class="cov8" title="1">{
                        forbidden[s.pairKey(edge.SourceCluster, target)] = true
                }</span>
        }
        <span class="cov8" title="1">return forbidden</span>
}

// filterForbiddenPairs removes pairs that are in the forbidden set
func (s *SliceConfigService) filterForbiddenPairs(pairs []util.GatewayPair, forbidden map[string]bool) []util.GatewayPair <span class="cov8" title="1">{
        filtered := make([]util.GatewayPair, 0, len(pairs))
        for _, p := range pairs </span><span class="cov8" title="1">{
                if !forbidden[s.pairKey(p.Source, p.Target)] </span><span class="cov8" title="1">{
                        filtered = append(filtered, p)
                }</span>
        }
        <span class="cov8" title="1">return filtered</span>
}

// ensureConnectivity adds bridge edges if forbidden edges create partitions
func (s *SliceConfigService) ensureConnectivity(clusters []string, pairs []util.GatewayPair, forbidden map[string]bool) ([]util.GatewayPair, error) <span class="cov8" title="1">{
        graph := s.buildGraph(pairs)
        components := s.findConnectedComponents(clusters, graph)

        if len(components) &lt;= 1 </span><span class="cov8" title="1">{
                return pairs, nil
        }</span>

        // Find bridge edges between components
        <span class="cov8" title="1">bridgeEdges := s.findBridgeEdges(components, forbidden)
        if len(bridgeEdges) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("forbidden edges create partitioned topology with no safe bridge edges available")
        }</span>

        // Add bridge edges to reconnect components
        <span class="cov0" title="0">for _, bridge := range bridgeEdges </span><span class="cov0" title="0">{
                pairs = append(pairs, bridge)
        }</span>

        <span class="cov0" title="0">return pairs, nil</span>
}

// buildGraph creates adjacency list from gateway pairs
func (s *SliceConfigService) buildGraph(pairs []util.GatewayPair) map[string][]string <span class="cov8" title="1">{
        graph := make(map[string][]string)
        for _, p := range pairs </span><span class="cov8" title="1">{
                graph[p.Source] = append(graph[p.Source], p.Target)
                graph[p.Target] = append(graph[p.Target], p.Source)
        }</span>
        <span class="cov8" title="1">return graph</span>
}

// findConnectedComponents uses DFS to find all connected components
func (s *SliceConfigService) findConnectedComponents(clusters []string, graph map[string][]string) [][]string <span class="cov8" title="1">{
        visited := make(map[string]bool)
        components := make([][]string, 0)

        for _, cluster := range clusters </span><span class="cov8" title="1">{
                if !visited[cluster] </span><span class="cov8" title="1">{
                        component := s.dfsComponent(cluster, graph, visited)
                        components = append(components, component)
                }</span>
        }

        <span class="cov8" title="1">return components</span>
}

// dfsComponent performs depth-first search to find a component
func (s *SliceConfigService) dfsComponent(node string, graph map[string][]string, visited map[string]bool) []string <span class="cov8" title="1">{
        visited[node] = true
        component := []string{node}

        for _, neighbor := range graph[node] </span><span class="cov8" title="1">{
                if !visited[neighbor] </span><span class="cov8" title="1">{
                        component = append(component, s.dfsComponent(neighbor, graph, visited)...)
                }</span>
        }

        <span class="cov8" title="1">return component</span>
}

// findBridgeEdges finds edges to connect partitioned components
func (s *SliceConfigService) findBridgeEdges(components [][]string, forbidden map[string]bool) []util.GatewayPair <span class="cov8" title="1">{
        bridges := make([]util.GatewayPair, 0)

        // Connect each component to the next
        for i := 0; i &lt; len(components); i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(components); j++ </span><span class="cov8" title="1">{
                        added := false
                        for _, ni := range components[i] </span><span class="cov8" title="1">{
                                if added </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov8" title="1">for _, nj := range components[j] </span><span class="cov8" title="1">{
                                        key := s.pairKey(ni, nj)
                                        if !forbidden[key] </span><span class="cov0" title="0">{
                                                bridges = append(bridges, util.GatewayPair{
                                                        Source:        ni,
                                                        Target:        nj,
                                                        Bidirectional: true,
                                                })
                                                added = true
                                                break</span>
                                        }
                                }
                        }
                }
        }

        <span class="cov8" title="1">return bridges</span>
}

// makeClusterSet creates a set from cluster list
func (s *SliceConfigService) makeClusterSet(clusters []string) map[string]bool <span class="cov8" title="1">{
        set := make(map[string]bool, len(clusters))
        for _, cluster := range clusters </span><span class="cov8" title="1">{
                set[cluster] = true
        }</span>
        <span class="cov8" title="1">return set</span>
}

// pairKey creates a normalized key for a cluster pair
func (s *SliceConfigService) pairKey(a, b string) string <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a + "-" + b
        }</span>
        <span class="cov0" title="0">return b + "-" + a</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"
        "regexp"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"
        "strconv"
        "strings"
        "time"

        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/types"

        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        workerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/worker/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/util"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// ValidateSliceConfigCreate is a function to verify the creation of slice config
func ValidateSliceConfigCreate(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig) (admission.Warnings, error) <span class="cov0" title="0">{
        if err := validateProjectNamespace(ctx, sliceConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateClustersOnCreate(ctx, sliceConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateApplicationNamespaces(ctx, sliceConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateAllowedNamespaces(sliceConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateNamespaceIsolationProfile(sliceConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateMaxClusterCount(sliceConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateTopologyConfig(sliceConfig.Spec.TopologyConfig, sliceConfig.Spec.Clusters); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if sliceConfig.Spec.OverlayNetworkDeploymentMode != controllerv1alpha1.NONET </span><span class="cov0" title="0">{
                if err := validateSliceSubnet(sliceConfig); err != nil </span><span class="cov0" title="0">{
                        return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
                }</span>
                <span class="cov0" title="0">if err := validateSlicegatewayServiceType(ctx, sliceConfig); err != nil </span><span class="cov0" title="0">{
                        return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
                }</span>
                <span class="cov0" title="0">if err := validateQosProfile(ctx, sliceConfig); err != nil </span><span class="cov0" title="0">{
                        return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
                }</span>
                <span class="cov0" title="0">if err := validateExternalGatewayConfig(sliceConfig); err != nil </span><span class="cov0" title="0">{
                        return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

// ValidateSliceConfigUpdate is function to verify the update of slice config
func ValidateSliceConfigUpdate(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig, old runtime.Object) (admission.Warnings, error) <span class="cov0" title="0">{
        oldSc := old.(*controllerv1alpha1.SliceConfig)
        isNetworkTransitioning := sliceConfig.Spec.OverlayNetworkDeploymentMode != oldSc.Spec.OverlayNetworkDeploymentMode

        if isNetworkTransitioning &amp;&amp; oldSc.Spec.OverlayNetworkDeploymentMode != controllerv1alpha1.NONET </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{
                        field.Forbidden(field.NewPath("Spec").Child("OverlayNetworkDeploymentMode"), fmt.Sprintf("Slice cannot be transitioned to %v mode from %v mode", sliceConfig.Spec.OverlayNetworkDeploymentMode, oldSc.Spec.OverlayNetworkDeploymentMode)),
                })
        }</span>
        // if overlay network deployment mode is transitioning, we can allow change in optional fields
        <span class="cov0" title="0">if !isNetworkTransitioning </span><span class="cov0" title="0">{
                if err := preventUpdate(ctx, sliceConfig, old); err != nil </span><span class="cov0" title="0">{
                        return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
                }</span>
        }

        // Common validations to be done irrespective of overlay network deployment mode
        <span class="cov0" title="0">if err := validateClustersOnUpdate(ctx, sliceConfig, old); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateApplicationNamespaces(ctx, sliceConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateAllowedNamespaces(sliceConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateNamespaceIsolationProfile(sliceConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateTopologyConfig(sliceConfig.Spec.TopologyConfig, sliceConfig.Spec.Clusters); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if sliceConfig.Spec.OverlayNetworkDeploymentMode != controllerv1alpha1.NONET </span><span class="cov0" title="0">{
                if err := validateSliceSubnet(sliceConfig); err != nil </span><span class="cov0" title="0">{
                        return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
                }</span>
                <span class="cov0" title="0">if !isNetworkTransitioning </span><span class="cov0" title="0">{
                        if err := preventMaxClusterCountUpdate(ctx, sliceConfig, old); err != nil </span><span class="cov0" title="0">{
                                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
                        }</span>
                }
                <span class="cov0" title="0">if err := validateSlicegatewayServiceType(ctx, sliceConfig); err != nil </span><span class="cov0" title="0">{
                        return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
                }</span>
                <span class="cov0" title="0">if err := validateQosProfile(ctx, sliceConfig); err != nil </span><span class="cov0" title="0">{
                        return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
                }</span>
                <span class="cov0" title="0">if err := validateExternalGatewayConfig(sliceConfig); err != nil </span><span class="cov0" title="0">{
                        return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
                }</span>

                <span class="cov0" title="0">if err := validateRenewNowInSliceConfig(ctx, sliceConfig, old); err != nil </span><span class="cov0" title="0">{
                        return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
                }</span>
                <span class="cov0" title="0">if _, err := validateRotationIntervalInSliceConfig(ctx, sliceConfig, old); err != nil </span><span class="cov0" title="0">{
                        return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
                }</span>

        }

        <span class="cov0" title="0">return nil, nil</span>
}

// ValidateSliceConfigDelete is function to validate the deletion of sliceConfig
func ValidateSliceConfigDelete(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig) (admission.Warnings, error) <span class="cov0" title="0">{
        if err := checkNamespaceDeboardingStatus(ctx, sliceConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateIfServiceExportConfigExists(ctx, sliceConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceConfig"}, sliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func validateRenewNowInSliceConfig(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig, old runtime.Object) *field.Error <span class="cov0" title="0">{
        oldSliceConfig := old.(*controllerv1alpha1.SliceConfig)
        // nochange detected
        if sliceConfig.Spec.RenewBefore.Equal(oldSliceConfig.Spec.RenewBefore) </span><span class="cov0" title="0">{
                return nil
        }</span>
        // change detected
        <span class="cov0" title="0">vpnKeyRotation := controllerv1alpha1.VpnKeyRotation{}
        exists, _ := util.GetResourceIfExist(ctx, types.NamespacedName{
                Namespace: sliceConfig.Namespace,
                Name:      sliceConfig.Name,
        }, &amp;vpnKeyRotation)
        if exists </span><span class="cov0" title="0">{
                for gateway := range vpnKeyRotation.Status.CurrentRotationState </span><span class="cov0" title="0">{
                        status, ok := vpnKeyRotation.Status.CurrentRotationState[gateway]
                        if ok </span><span class="cov0" title="0">{
                                if status.Status != controllerv1alpha1.Complete </span><span class="cov0" title="0">{
                                        return &amp;field.Error{
                                                Type:   field.ErrorTypeForbidden,
                                                Field:  "Field: RenewBefore",
                                                Detail: fmt.Sprintf("Certs Renewal status for %s gateway is not in Complete state", gateway),
                                        }
                                }</span>
                        }
                }
        }
        // check if we are past and its a correct time
        <span class="cov0" title="0">if !time.Now().After(sliceConfig.Spec.RenewBefore.Time) </span><span class="cov0" title="0">{
                return &amp;field.Error{
                        Type:   field.ErrorTypeForbidden,
                        Field:  "Field: RenewBefore",
                        Detail: "Renewal Time inappropriate for sliceconfig",
                }
        }</span>

        <span class="cov0" title="0">vpnKeyRotation.Spec.CertificateExpiryTime = sliceConfig.Spec.RenewBefore
        err := util.UpdateResource(ctx, &amp;vpnKeyRotation)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;field.Error{
                        Type:   field.ErrorTypeForbidden,
                        Field:  "Field: RenewBefore",
                        Detail: "Failed to Update Renewal Time, Please try again!",
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func validateRotationIntervalInSliceConfig(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig, old runtime.Object) (*controllerv1alpha1.VpnKeyRotation, *field.Error) <span class="cov0" title="0">{
        oldSliceConfig := old.(*controllerv1alpha1.SliceConfig)
        // nochange detected
        if sliceConfig.Spec.RotationInterval == oldSliceConfig.Spec.RotationInterval </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        // change detected
        <span class="cov0" title="0">vpnKeyRotation := controllerv1alpha1.VpnKeyRotation{}
        exists, _ := util.GetResourceIfExist(ctx, types.NamespacedName{
                Namespace: sliceConfig.Namespace,
                Name:      sliceConfig.Name,
        }, &amp;vpnKeyRotation)
        if exists </span><span class="cov0" title="0">{
                vpnKeyRotation.Spec.RotationInterval = sliceConfig.Spec.RotationInterval
                // update the new expiry TS
                expiryTS := metav1.NewTime(vpnKeyRotation.Spec.CertificateCreationTime.AddDate(0, 0, vpnKeyRotation.Spec.RotationInterval).Add(-1 * time.Hour))
                vpnKeyRotation.Spec.CertificateExpiryTime = &amp;expiryTS
                err := util.UpdateResource(ctx, &amp;vpnKeyRotation)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;field.Error{
                                Type:   field.ErrorTypeForbidden,
                                Field:  "Field: RenewBefore",
                                Detail: "Failed to Update Renewal Time, Please try again!",
                        }
                }</span>
        }
        <span class="cov0" title="0">return &amp;vpnKeyRotation, nil</span>
}

// checkNamespaceDeboardingStatus checks if the namespace is deboarding
func checkNamespaceDeboardingStatus(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        workerSlices := &amp;workerv1alpha1.WorkerSliceConfigList{}
        ownerLabel := map[string]string{
                "original-slice-name": sliceConfig.Name,
        }
        err := util.ListResources(ctx, workerSlices, client.MatchingLabels(ownerLabel), client.InNamespace(sliceConfig.Namespace))
        if err == nil &amp;&amp; len(workerSlices.Items) &gt; 0 </span><span class="cov0" title="0">{
                for _, slice := range workerSlices.Items </span><span class="cov0" title="0">{
                        if len(slice.Spec.NamespaceIsolationProfile.ApplicationNamespaces) &gt; 0 </span><span class="cov0" title="0">{
                                return &amp;field.Error{
                                        Type:     field.ErrorTypeForbidden,
                                        Field:    "Field: ApplicationNamespaces",
                                        BadValue: fmt.Sprintf("Number of ApplicationNamespaces: %d ", len(slice.Spec.NamespaceIsolationProfile.ApplicationNamespaces)),
                                        Detail:   fmt.Sprint("Please deboard the namespaces before deletion of slice."),
                                }
                        }</span> else<span class="cov0" title="0"> {
                                if len(slice.Status.OnboardedAppNamespaces) &gt; 0 </span><span class="cov0" title="0">{
                                        return &amp;field.Error{
                                                Type:     field.ErrorTypeInternal,
                                                Field:    "Field: OnboardedAppNamespaces",
                                                BadValue: fmt.Sprintf("Number of onboarded Application namespaces: %d", len(slice.Status.OnboardedAppNamespaces)),
                                                Detail:   fmt.Sprint("Deboarding of namespaces is in progress, please try after some time."),
                                        }
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// validateSliceSubnet is function to validate the the subnet of slice
func validateSliceSubnet(sliceConfig *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        if sliceConfig.Spec.SliceSubnet == "" </span><span class="cov0" title="0">{
                return field.Required(field.NewPath("Spec").Child("SliceSubnet"), "SliceSubnet is required for slice config")
        }</span>
        <span class="cov0" title="0">if !util.IsPrivateSubnet(sliceConfig.Spec.SliceSubnet) </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("sliceSubnet"), sliceConfig.Spec.SliceSubnet, "must be a private subnet")
        }</span>
        <span class="cov0" title="0">if !util.HasPrefix(sliceConfig.Spec.SliceSubnet, "16") </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("sliceSubnet"), sliceConfig.Spec.SliceSubnet, "prefix must be 16")
        }</span>
        <span class="cov0" title="0">if !util.HasLastTwoOctetsZero(sliceConfig.Spec.SliceSubnet) </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("sliceSubnet"), sliceConfig.Spec.SliceSubnet, "third and fourth octets must be 0")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateProjectNamespace is a function to verify the namespace of project
func validateProjectNamespace(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        namespace := &amp;corev1.Namespace{}
        exist, _ := util.GetResourceIfExist(ctx, client.ObjectKey{Name: sliceConfig.Namespace}, namespace)
        if !exist || !util.CheckForProjectNamespace(namespace) </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("metadata").Child("namespace"), sliceConfig.Namespace, "SliceConfig must be applied on project namespace")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateIfServiceExportConfigExists is a function to validate if ServiceExportConfig exists for the given SliceConfig
func validateIfServiceExportConfigExists(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        serviceExports := &amp;controllerv1alpha1.ServiceExportConfigList{}
        err := getServiceExportBySliceName(ctx, sliceConfig.Namespace, sliceConfig.Name, serviceExports)
        if err == nil &amp;&amp; len(serviceExports.Items) &gt; 0 </span><span class="cov0" title="0">{
                return field.Forbidden(field.NewPath("ServiceExportConfig"), "The SliceConfig can only be deleted after all the service export configs are deleted for the slice.")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateClusters is function to validate the cluster specification
func validateClustersOnCreate(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        if duplicate, value := util.CheckDuplicateInArray(sliceConfig.Spec.Clusters); duplicate </span><span class="cov0" title="0">{
                return field.Duplicate(field.NewPath("Spec").Child("Clusters"), strings.Join(value, ", "))
        }</span>
        <span class="cov0" title="0">for i, clusterName := range sliceConfig.Spec.Clusters </span><span class="cov0" title="0">{
                cluster := controllerv1alpha1.Cluster{}
                exist, _ := util.GetResourceIfExist(ctx, client.ObjectKey{Name: clusterName, Namespace: sliceConfig.Namespace}, &amp;cluster)
                if !exist </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("Clusters").Index(i), clusterName, "cluster is not registered")
                }</span>
                <span class="cov0" title="0">if cluster.Status.RegistrationStatus != controllerv1alpha1.RegistrationStatusRegistered </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("Clusters").Index(i), clusterName, "cluster registration is not completed. Possible cause: Slice Operator installation is pending on the cluster.")
                }</span>
                <span class="cov0" title="0">if cluster.Status.ClusterHealth != nil &amp;&amp; cluster.Status.ClusterHealth.ClusterHealthStatus != controllerv1alpha1.ClusterHealthStatusNormal </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("Clusters").Index(i), clusterName, "cluster health is not normal")
                }</span>
                <span class="cov0" title="0">if len(cluster.Spec.NodeIPs) == 0 &amp;&amp; len(cluster.Status.NodeIPs) == 0 </span><span class="cov0" title="0">{
                        return field.NotFound(field.NewPath("Status").Child("NodeIPs"), "in cluster "+clusterName+". Autodetected node IPs are not available. Possible cause: Slice Operator installation is pending on the cluster.")
                }</span>
                // If overlay network is enabled, check if network components are installed and cluster's CNI subnet is set and not overlapping with slice subnet
                <span class="cov0" title="0">if sliceConfig.Spec.OverlayNetworkDeploymentMode != controllerv1alpha1.NONET </span><span class="cov0" title="0">{
                        if !cluster.Status.NetworkPresent </span><span class="cov0" title="0">{
                                return field.Invalid(field.NewPath("Spec").Child("Clusters").Index(i), clusterName, "cluster network is not present")
                        }</span>
                        <span class="cov0" title="0">if len(cluster.Status.CniSubnet) == 0 </span><span class="cov0" title="0">{
                                return field.NotFound(field.NewPath("Status").Child("CniSubnet"), "in cluster "+clusterName+". Possible cause: Slice Operator installation is pending on the cluster.")
                        }</span>
                        <span class="cov0" title="0">for _, cniSubnet := range cluster.Status.CniSubnet </span><span class="cov0" title="0">{
                                if util.OverlapIP(cniSubnet, sliceConfig.Spec.SliceSubnet) </span><span class="cov0" title="0">{
                                        return field.Invalid(field.NewPath("Spec").Child("SliceSubnet"), sliceConfig.Spec.SliceSubnet, "must not overlap with CniSubnet "+cniSubnet+" of cluster "+clusterName)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// validateClustersOnUpdate is function to validate the cluster specification
func validateClustersOnUpdate(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig, old runtime.Object) *field.Error <span class="cov0" title="0">{
        oldSc := old.(*controllerv1alpha1.SliceConfig)
        if duplicate, value := util.CheckDuplicateInArray(sliceConfig.Spec.Clusters); duplicate </span><span class="cov0" title="0">{
                return field.Duplicate(field.NewPath("Spec").Child("Clusters"), strings.Join(value, ", "))
        }</span>
        <span class="cov0" title="0">newlyAddedClusters := util.DifferenceOfArray(sliceConfig.Spec.Clusters, oldSc.Spec.Clusters)
        for _, clusterName := range newlyAddedClusters </span><span class="cov0" title="0">{
                cluster := controllerv1alpha1.Cluster{}
                exist, _ := util.GetResourceIfExist(ctx, client.ObjectKey{Name: clusterName, Namespace: sliceConfig.Namespace}, &amp;cluster)
                if !exist </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("Clusters"), clusterName, "cluster is not registered")
                }</span>
                <span class="cov0" title="0">if cluster.Status.RegistrationStatus != controllerv1alpha1.RegistrationStatusRegistered </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("Clusters"), clusterName, "cluster registration is not completed. Possible cause: Slice Operator installation is pending on the cluster.")
                }</span>
                <span class="cov0" title="0">if cluster.Status.ClusterHealth.ClusterHealthStatus != controllerv1alpha1.ClusterHealthStatusNormal </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("Clusters"), clusterName, "cluster health is not normal")
                }</span>
        }
        <span class="cov0" title="0">for i, clusterName := range sliceConfig.Spec.Clusters </span><span class="cov0" title="0">{
                cluster := controllerv1alpha1.Cluster{}
                exist, _ := util.GetResourceIfExist(ctx, client.ObjectKey{Name: clusterName, Namespace: sliceConfig.Namespace}, &amp;cluster)
                if !exist </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("Clusters").Index(i), clusterName, "cluster is not registered")
                }</span>
                <span class="cov0" title="0">if len(cluster.Spec.NodeIPs) == 0 &amp;&amp; len(cluster.Status.NodeIPs) == 0 </span><span class="cov0" title="0">{
                        return field.NotFound(field.NewPath("Status").Child("NodeIPs"), "in cluster "+clusterName+". Autodetected node IPs are not available. Possible cause: Slice Operator installation is pending on the cluster.")
                }</span>
                <span class="cov0" title="0">if sliceConfig.Spec.OverlayNetworkDeploymentMode != controllerv1alpha1.NONET </span><span class="cov0" title="0">{
                        if !cluster.Status.NetworkPresent </span><span class="cov0" title="0">{
                                return field.Invalid(field.NewPath("Spec").Child("Clusters").Index(i), clusterName, "cluster network is not present")
                        }</span>
                        <span class="cov0" title="0">if len(cluster.Status.CniSubnet) == 0 </span><span class="cov0" title="0">{
                                return field.NotFound(field.NewPath("Status").Child("CniSubnet"), "in cluster "+clusterName+". Possible cause: Slice Operator installation is pending on the cluster.")
                        }</span>
                        <span class="cov0" title="0">for _, cniSubnet := range cluster.Status.CniSubnet </span><span class="cov0" title="0">{
                                if util.OverlapIP(cniSubnet, sliceConfig.Spec.SliceSubnet) </span><span class="cov0" title="0">{
                                        return field.Invalid(field.NewPath("Spec").Child("SliceSubnet"), sliceConfig.Spec.SliceSubnet, "must not overlap with CniSubnet "+cniSubnet+" of cluster "+clusterName)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// to validate the SlicegatewayServiceType array
func validateSlicegatewayServiceType(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        if sliceConfig.Spec.SliceGatewayProvider == nil </span><span class="cov0" title="0">{
                return field.Required(field.NewPath("Spec").Child("SliceGatewayProvider"), "SliceGatewayProvider is required for slice config")
        }</span>
        <span class="cov0" title="0">freq := make(map[string]int)
        for _, sliceGwSvcType := range sliceConfig.Spec.SliceGatewayProvider.SliceGatewayServiceType </span><span class="cov0" title="0">{
                cluster := sliceGwSvcType.Cluster
                freq[cluster] += 1
                // cluster name can't be empty
                if cluster == "" </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("SliceGatewayProvider").Child("SliceGatewayServiceType"), sliceGwSvcType, "Cluster name can't be empty")
                }</span>
                // cluster should participate in slice
                <span class="cov0" title="0">if cluster != "*" &amp;&amp; !util.ContainsString(sliceConfig.Spec.Clusters, cluster) </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("SliceGatewayProvider").Child("SliceGatewayServiceType"), sliceGwSvcType, "Cluster is not participating in slice config")
                }</span>
                // don't allow duplicate cluster values
                <span class="cov0" title="0">if freq[cluster] &gt; 1 </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("SliceGatewayProvider").Child("SliceGatewayServiceType"), sliceGwSvcType, "Duplicate entries for same cluster are not allowed")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// preventUpdate is a function to stop/avoid the update of config of slice
func preventUpdate(ctx context.Context, sc *controllerv1alpha1.SliceConfig, old runtime.Object) *field.Error <span class="cov0" title="0">{
        sliceConfig := old.(*controllerv1alpha1.SliceConfig)
        if sliceConfig.Spec.SliceSubnet != sc.Spec.SliceSubnet </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("SliceSubnet"), sc.Spec.SliceSubnet, "cannot be updated")
        }</span>
        <span class="cov0" title="0">if sliceConfig.Spec.SliceType != sc.Spec.SliceType </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("SliceType"), sc.Spec.SliceType, "cannot be updated")
        }</span>
        <span class="cov0" title="0">if sliceConfig.Spec.SliceGatewayProvider != nil &amp;&amp; sc.Spec.SliceGatewayProvider != nil </span><span class="cov0" title="0">{
                if sliceConfig.Spec.SliceGatewayProvider.SliceGatewayType != sc.Spec.SliceGatewayProvider.SliceGatewayType </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("SliceGatewayProvider").Child("SliceGatewayType"), sc.Spec.SliceGatewayProvider.SliceGatewayType, "cannot be updated")
                }</span>
                <span class="cov0" title="0">if sliceConfig.Spec.SliceGatewayProvider.SliceCaType != sc.Spec.SliceGatewayProvider.SliceCaType </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("SliceGatewayProvider").Child("SliceCaType"), sc.Spec.SliceGatewayProvider.SliceCaType, "cannot be updated")
                }</span>
        }
        <span class="cov0" title="0">if sliceConfig.Spec.SliceIpamType != sc.Spec.SliceIpamType </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("SliceIpamType"), sc.Spec.SliceIpamType, "cannot be updated")
        }</span>
        // required if slice from previous releases is upgraded
        <span class="cov0" title="0">if sliceConfig.Spec.VPNConfig != nil </span><span class="cov0" title="0">{
                if sliceConfig.Spec.VPNConfig.Cipher != sc.Spec.VPNConfig.Cipher </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("VPNConfig").Child("Cipher"), sc.Spec.VPNConfig.Cipher, "cannot be updated")
                }</span>
        }
        // not allowed to switch gw svc types &amp; protocols
        // create cluster:GwType map from old config
        <span class="cov0" title="0">gwSvcTypeMap := getSliceGwSvcTypes(sliceConfig)

        // check new config
        if sc.Spec.SliceGatewayProvider != nil &amp;&amp; gwSvcTypeMap != nil </span><span class="cov0" title="0">{
                for _, new := range sc.Spec.SliceGatewayProvider.SliceGatewayServiceType </span><span class="cov0" title="0">{
                        oldType, exists := gwSvcTypeMap[new.Cluster]
                        // allow user to update NodePort to LoadBalancer but not vice versa
                        if exists &amp;&amp; oldType.Type != defaultSliceGatewayServiceType &amp;&amp; new.Type != oldType.Type </span><span class="cov0" title="0">{
                                return field.Forbidden(field.NewPath("Spec").Child("SliceGatewayProvider").Child("SliceGatewayServiceType"), "updating gateway service type is not allowed")
                        }</span>
                        // don't allow user to update TCP to UDP &amp; vice versa
                        <span class="cov0" title="0">if exists &amp;&amp; new.Protocol != oldType.Protocol </span><span class="cov0" title="0">{
                                return field.Forbidden(field.NewPath("Spec").Child("SliceGatewayProvider").Child("SliceGatewayServiceType"), "updating gateway protocol is not allowed")
                        }</span>
                        // when no protocol is specified then it's assumed to be UDP, so can't be updated to TCP
                        <span class="cov0" title="0">if util.ContainsString(sliceConfig.Spec.Clusters, new.Cluster) &amp;&amp; !exists &amp;&amp; new.Protocol != defaultSliceGatewayServiceProtocol </span><span class="cov0" title="0">{
                                return field.Forbidden(field.NewPath("Spec").Child("SliceGatewayProvider").Child("SliceGatewayServiceType"), "updating gateway protocol is not allowed")
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// validateQosProfile is a function to validate the Qos(quality of service)profile of slice
func validateQosProfile(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        if sliceConfig.Spec.StandardQosProfileName != "" &amp;&amp; sliceConfig.Spec.QosProfileDetails != nil </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("StandardQosProfileName"), sliceConfig.Spec.StandardQosProfileName, "StandardQosProfileName cannot be set when QosProfileDetails is set")
        }</span>
        <span class="cov0" title="0">if sliceConfig.Spec.StandardQosProfileName == "" &amp;&amp; sliceConfig.Spec.QosProfileDetails == nil </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("StandardQosProfileName"), sliceConfig.Spec.StandardQosProfileName, "Either StandardQosProfileName or QosProfileDetails is required")
        }</span>
        <span class="cov0" title="0">if sliceConfig.Spec.StandardQosProfileName != "" </span><span class="cov0" title="0">{
                exists := checkIfQoSConfigExists(ctx, sliceConfig.Namespace, sliceConfig.Spec.StandardQosProfileName)
                if !exists </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("StandardQosProfileName"), sliceConfig.Spec.StandardQosProfileName, "SliceQoSConfig not found.")
                }</span>
        }
        <span class="cov0" title="0">if sliceConfig.Spec.QosProfileDetails != nil &amp;&amp; sliceConfig.Spec.QosProfileDetails.BandwidthCeilingKbps &lt; sliceConfig.Spec.QosProfileDetails.BandwidthGuaranteedKbps </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("QosProfileDetails").Child("BandwidthGuaranteedKbps"), sliceConfig.Spec.QosProfileDetails.BandwidthGuaranteedKbps, "BandwidthGuaranteedKbps cannot be greater than BandwidthCeilingKbps")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// validateExternalGatewayConfig is a function to validate the external gateway
func validateExternalGatewayConfig(sliceConfig *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        count := 0
        var allClusters []string
        for _, config := range sliceConfig.Spec.ExternalGatewayConfig </span><span class="cov0" title="0">{
                if util.ContainsString(config.Clusters, "*") </span><span class="cov0" title="0">{
                        count++
                        if len(config.Clusters) &gt; 1 </span><span class="cov0" title="0">{
                                return field.Invalid(field.NewPath("Spec").Child("ExternalGatewayConfig").Child("Clusters"), strings.Join(config.Clusters, ", "), "other clusters are not allowed when * is present")
                        }</span>
                }
                <span class="cov0" title="0">for _, cluster := range config.Clusters </span><span class="cov0" title="0">{
                        allClusters = append(allClusters, cluster)
                        if cluster != "*" &amp;&amp; !util.ContainsString(sliceConfig.Spec.Clusters, cluster) </span><span class="cov0" title="0">{
                                return field.Invalid(field.NewPath("Spec").Child("ExternalGatewayConfig").Child("Clusters"), cluster, "cluster is not participating in slice config")
                        }</span>
                }
        }
        <span class="cov0" title="0">if count &gt; 1 </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("ExternalGatewayConfig").Child("Clusters"), "*", "* is not allowed in more than one external gateways")
        }</span>
        <span class="cov0" title="0">if duplicate, value := util.CheckDuplicateInArray(allClusters); duplicate </span><span class="cov0" title="0">{
                return field.Duplicate(field.NewPath("Spec").Child("ExternalGatewayConfig").Child("Clusters"), strings.Join(value, ", "))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateApplicationNamespaces is function to validate the application namespaces
func validateApplicationNamespaces(ctx context.Context, sliceConfig *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        for _, applicationNamespace := range sliceConfig.Spec.NamespaceIsolationProfile.ApplicationNamespaces </span><span class="cov0" title="0">{
                /* check duplicate values of clusters */
                if len(applicationNamespace.Namespace) &gt; 0 &amp;&amp; len(applicationNamespace.Clusters) == 0 </span><span class="cov0" title="0">{
                        return field.Required(field.NewPath("Spec").Child("NamespaceIsolationProfile").Child("ApplicationNamespaces").Child("Clusters"), "clusters")
                }</span>
                <span class="cov0" title="0">if len(applicationNamespace.Namespace) == 0 &amp;&amp; len(applicationNamespace.Clusters) &gt; 0 </span><span class="cov0" title="0">{
                        return field.Required(field.NewPath("Spec").Child("NamespaceIsolationProfile").Child("ApplicationNamespaces").Child("Namespace"), "Namespace")
                }</span>
                <span class="cov0" title="0">if duplicate, value := util.CheckDuplicateInArray(applicationNamespace.Clusters); duplicate </span><span class="cov0" title="0">{
                        return field.Duplicate(field.NewPath("Spec").Child("NamespaceIsolationProfile.ApplicationNamespaces").Child("Clusters"), strings.Join(value, ", "))
                }</span>
                <span class="cov0" title="0">if applicationNamespace.Clusters[0] == "*" </span><span class="cov0" title="0">{
                        projectName := util.GetProjectName(sliceConfig.Namespace)
                        defaultSliceName := fmt.Sprintf(util.DefaultProjectSliceName, projectName)
                        if defaultSliceName == sliceConfig.Name </span><span class="cov0" title="0">{
                                return field.Invalid(field.NewPath("Spec").Child("NamespaceIsolationProfile.ApplicationNamespaces").Child("Clusters"), strings.Join(applicationNamespace.Clusters, ", "), "Namespace sameness is not allowed in default slice")
                        }</span>
                        <span class="cov0" title="0">for _, clusterName := range sliceConfig.Spec.Clusters </span><span class="cov0" title="0">{
                                err := validateGrantedClusterNamespaces(ctx, clusterName, applicationNamespace.Namespace, sliceConfig.Name, sliceConfig)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        for _, clusterName := range applicationNamespace.Clusters </span><span class="cov0" title="0">{
                                err := validateGrantedClusterNamespaces(ctx, clusterName, applicationNamespace.Namespace, sliceConfig.Name, sliceConfig)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// validateClusterNamespaces is a function to validate the namespaces present is cluster
func validateGrantedClusterNamespaces(ctx context.Context, clusterName string, applicationNamespace string, sliceName string, sliceConfig *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        cluster := controllerv1alpha1.Cluster{}
        _, _ = util.GetResourceIfExist(ctx, client.ObjectKey{Name: clusterName, Namespace: sliceConfig.Namespace}, &amp;cluster)
        projectName := util.GetProjectName(sliceConfig.Namespace)
        defaultSliceName := fmt.Sprintf(util.DefaultProjectSliceName, projectName)
        for _, clusterNamespace := range cluster.Status.Namespaces </span><span class="cov0" title="0">{
                if applicationNamespace == clusterNamespace.Name &amp;&amp; len(clusterNamespace.SliceName) &gt; 0 &amp;&amp; clusterNamespace.SliceName != sliceName &amp;&amp; clusterNamespace.SliceName != defaultSliceName </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("NamespaceIsolationProfile.ApplicationNamespaces"), applicationNamespace, "The given namespace: "+applicationNamespace+" in cluster "+clusterName+" is already acquired by other slice: "+clusterNamespace.SliceName)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateAllowedNamespaces is a function to validate the namespaces present in slice config
func validateAllowedNamespaces(sliceConfig *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        for _, allowedNamespace := range sliceConfig.Spec.NamespaceIsolationProfile.AllowedNamespaces </span><span class="cov0" title="0">{
                /* check duplicate values of clusters */
                if duplicate, value := util.CheckDuplicateInArray(allowedNamespace.Clusters); duplicate </span><span class="cov0" title="0">{
                        return field.Duplicate(field.NewPath("Spec").Child("NamespaceIsolationProfile.AllowedNamespaces").Child("Clusters"), strings.Join(value, ", "))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// validateNamespaceIsolationProfile checks for validation errors in NamespaceIsolationProfile.
// Checks if the participating clusters are valid and if the namespaces are configured correctly.
func validateNamespaceIsolationProfile(s *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        if len(s.Spec.NamespaceIsolationProfile.ApplicationNamespaces) == 0 &amp;&amp; len(s.Spec.NamespaceIsolationProfile.AllowedNamespaces) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        // for each namespace in applicationNamespaces, check if the clusters are valid
        <span class="cov0" title="0">participatingClusters := s.Spec.Clusters
        var checkedApplicationNs []string

        for _, nsSelection := range s.Spec.NamespaceIsolationProfile.ApplicationNamespaces </span><span class="cov0" title="0">{
                validNamespace, _ := regexp.MatchString("^[a-zA-Z0-9-]+$", nsSelection.Namespace)
                if validNamespace == false </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("NamespaceIsolationProfile").Child("ApplicationNamespaces").Child("Namespace"), nsSelection.Namespace, "Namespaces cannot contain special characteres")
                }</span>
                // check if the clusters are already specified for a namespace
                <span class="cov0" title="0">if util.ContainsString(checkedApplicationNs, nsSelection.Namespace) </span><span class="cov0" title="0">{
                        return field.Duplicate(field.NewPath("Spec").Child("NamespaceIsolationProfile").Child("ApplicationNamespaces").Child("Namespace"), nsSelection.Namespace)
                }</span>
                <span class="cov0" title="0">checkedApplicationNs = append(checkedApplicationNs, nsSelection.Namespace)

                if util.ContainsString(nsSelection.Clusters, "*") </span><span class="cov0" title="0">{
                        if len(nsSelection.Clusters) &gt; 1 </span><span class="cov0" title="0">{
                                return field.Invalid(field.NewPath("Spec").Child("NamespaceIsolationProfile").Child("ApplicationNamespaces").Child("Clusters"), strings.Join(nsSelection.Clusters, ", "), "Other clusters are not allowed when * is present")
                        }</span>
                }
                // check if the cluster is valid
                <span class="cov0" title="0">for _, cluster := range nsSelection.Clusters </span><span class="cov0" title="0">{
                        if cluster != "*" &amp;&amp; !util.ContainsString(participatingClusters, cluster) </span><span class="cov0" title="0">{
                                return field.Invalid(field.NewPath("Spec").Child("NamespaceIsolationProfile").Child("ApplicationNamespaces").Child("Clusters"), cluster, "Cluster is not participating in slice config")
                        }</span>
                }
        }

        // for each namespace in AllowedNamespaces, check if the clusters are valid
        <span class="cov0" title="0">var checkedAllowedNs []string
        for _, nsSelection := range s.Spec.NamespaceIsolationProfile.AllowedNamespaces </span><span class="cov0" title="0">{
                if len(nsSelection.Namespace) == 0 &amp;&amp; len(nsSelection.Clusters) &gt; 0 </span><span class="cov0" title="0">{
                        return field.Required(field.NewPath("Spec").Child("NamespaceIsolationProfile").Child("AllowedNamespaces").Child("Namespace"), nsSelection.Namespace)
                }</span>
                <span class="cov0" title="0">validNamespace, _ := regexp.MatchString("^[a-zA-Z0-9-]+$", nsSelection.Namespace)
                if validNamespace == false </span><span class="cov0" title="0">{
                        return field.Invalid(field.NewPath("Spec").Child("NamespaceIsolationProfile").Child("AllowedNamespaces").Child("Namespace"), nsSelection.Namespace, "Namespaces cannot contain special characteres")
                }</span>
                <span class="cov0" title="0">if len(nsSelection.Namespace) &gt; 0 &amp;&amp; len(nsSelection.Clusters) == 0 </span><span class="cov0" title="0">{
                        return field.Required(field.NewPath("Spec").Child("NamespaceIsolationProfile").Child("AllowedNamespaces").Child("Clusters"), "clusters")
                }</span>
                // check if the clusters are already specified for a namespace
                <span class="cov0" title="0">if util.ContainsString(checkedAllowedNs, nsSelection.Namespace) </span><span class="cov0" title="0">{
                        return field.Duplicate(field.NewPath("Spec").Child("NamespaceIsolationProfile").Child("AllowedNamespaces").Child("Namespace"), nsSelection.Namespace)
                }</span>
                <span class="cov0" title="0">checkedAllowedNs = append(checkedAllowedNs, nsSelection.Namespace)

                if util.ContainsString(nsSelection.Clusters, "*") </span><span class="cov0" title="0">{
                        if len(nsSelection.Clusters) &gt; 1 </span><span class="cov0" title="0">{
                                return field.Invalid(field.NewPath("Spec").Child("NamespaceIsolationProfile").Child("AllowedNamespaces").Child("Clusters"), strings.Join(nsSelection.Clusters, ", "), "Other clusters are not allowed when * is present")
                        }</span>
                }
                // check if the cluster is valid
                <span class="cov0" title="0">for _, cluster := range nsSelection.Clusters </span><span class="cov0" title="0">{
                        if cluster != "*" &amp;&amp; !util.ContainsString(participatingClusters, cluster) </span><span class="cov0" title="0">{
                                return field.Invalid(field.NewPath("Spec").Child("NamespaceIsolationProfile").Child("AllowedNamespaces").Child("Clusters"), cluster, "Cluster is not participating in slice config")
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func validateMaxClusterCount(s *controllerv1alpha1.SliceConfig) *field.Error <span class="cov0" title="0">{
        if s.Spec.MaxClusters &lt; 2 || s.Spec.MaxClusters &gt; 32 </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("MaxClusterCount"), s.Spec.MaxClusters, "MaxClusterCount cannot be less than 2 or greater than 32.")
        }</span>
        <span class="cov0" title="0">if len(s.Spec.Clusters) &gt; s.Spec.MaxClusters </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("Clusters"), s.Spec.Clusters, "participating clusters cannot be greater than MaxClusterCount :"+strconv.Itoa(s.Spec.MaxClusters))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// prevent update MaxClusterCount if it is already set
func preventMaxClusterCountUpdate(ctx context.Context, s *controllerv1alpha1.SliceConfig, old runtime.Object) *field.Error <span class="cov0" title="0">{
        oldSc := old.(*controllerv1alpha1.SliceConfig)

        if s.Spec.MaxClusters != oldSc.Spec.MaxClusters </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("MaxClusterCount"), s.Spec.MaxClusters, "MaxClusterCount cannot be updated.")
        }</span>
        <span class="cov0" title="0">if len(s.Spec.Clusters) &gt; s.Spec.MaxClusters </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("Clusters"), s.Spec.Clusters, "participating clusters cannot be greater than MaxClusterCount :"+strconv.Itoa(s.Spec.MaxClusters))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// getServiceExportBySliceName is a function to get the service export configs by slice name
func getServiceExportBySliceName(ctx context.Context, namespace string, sliceName string, serviceExports *controllerv1alpha1.ServiceExportConfigList) error <span class="cov0" title="0">{
        label := map[string]string{
                "original-slice-name": sliceName,
        }
        err := util.ListResources(ctx, serviceExports, client.InNamespace(namespace), client.MatchingLabels(label))
        return err
}</span>

func checkIfQoSConfigExists(ctx context.Context, namespace string, qosProfileName string) bool <span class="cov0" title="0">{
        NamespacedName := client.ObjectKey{
                Name:      qosProfileName,
                Namespace: namespace,
        }
        sliceQosConfig := &amp;controllerv1alpha1.SliceQoSConfig{}
        found, err := util.GetResourceIfExist(ctx, NamespacedName, sliceQosConfig)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return found</span>
}

func validateTopologyConfig(topology *controllerv1alpha1.TopologyConfig, clusters []string) *field.Error <span class="cov8" title="1">{
        if topology == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">clusterSet := make(map[string]struct{}, len(clusters))
        for _, c := range clusters </span><span class="cov8" title="1">{
                clusterSet[c] = struct{}{}
        }</span>
        <span class="cov8" title="1">topologyPath := field.NewPath("spec", "topologyConfig")
        switch topology.TopologyType </span>{
        case controllerv1alpha1.TopologyCustom:<span class="cov8" title="1">
                if err := validateCustomTopology(topology.ConnectivityMatrix, clusterSet, topologyPath); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        case controllerv1alpha1.TopologyRestricted:<span class="cov8" title="1">
                if err := validateRestrictedTopology(topology, clusterSet, topologyPath); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case controllerv1alpha1.TopologyFullMesh, "":<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                return field.Invalid(topologyPath.Child("topologyType"), topology.TopologyType, "must be one of: restricted, full-mesh, custom")</span>
        }
        <span class="cov8" title="1">return validateForbiddenEdges(topology.ForbiddenEdges, clusterSet, topologyPath)</span>
}

func validateCustomTopology(matrix []controllerv1alpha1.ConnectivityEntry, clusterSet map[string]struct{}, basePath *field.Path) *field.Error <span class="cov8" title="1">{
        matrixPath := basePath.Child("connectivityMatrix")
        if len(matrix) == 0 </span><span class="cov8" title="1">{
                return field.Required(matrixPath, "required for custom topology")
        }</span>
        <span class="cov8" title="1">for i, entry := range matrix </span><span class="cov8" title="1">{
                entryPath := matrixPath.Index(i)
                if _, exists := clusterSet[entry.SourceCluster]; !exists </span><span class="cov8" title="1">{
                        return field.Invalid(entryPath.Child("sourceCluster"), entry.SourceCluster, "not in spec.clusters")
                }</span>
                <span class="cov8" title="1">for j, target := range entry.TargetClusters </span><span class="cov8" title="1">{
                        if _, exists := clusterSet[target]; !exists </span><span class="cov0" title="0">{
                                return field.Invalid(entryPath.Child("targetClusters").Index(j), target, "not in spec.clusters")
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func validateRestrictedTopology(topology *controllerv1alpha1.TopologyConfig, clusterSet map[string]struct{}, basePath *field.Path) *field.Error <span class="cov8" title="1">{
        // Soft removal: ignore autoOptions fields entirely at webhook layer
        // Controller will not act on these fields and webhook will not validate them
        return nil
}</span>

func validateForbiddenEdges(edges []controllerv1alpha1.ForbiddenEdge, clusterSet map[string]struct{}, basePath *field.Path) *field.Error <span class="cov8" title="1">{
        edgesPath := basePath.Child("forbiddenEdges")
        for i, edge := range edges </span><span class="cov8" title="1">{
                entryPath := edgesPath.Index(i)
                if _, exists := clusterSet[edge.SourceCluster]; !exists </span><span class="cov8" title="1">{
                        return field.Invalid(entryPath.Child("sourceCluster"), edge.SourceCluster, "not in spec.clusters")
                }</span>
                <span class="cov0" title="0">for j, target := range edge.TargetClusters </span><span class="cov0" title="0">{
                        if _, exists := clusterSet[target]; !exists </span><span class="cov0" title="0">{
                                return field.Invalid(entryPath.Child("targetClusters").Index(j), target, "not in spec.clusters")
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"
        "time"

        "github.com/kubeslice/kubeslice-controller/metrics"

        "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/events"
        "github.com/kubeslice/kubeslice-controller/util"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type ISliceQoSConfigService interface {
        ReconcileSliceQoSConfig(ctx context.Context, req ctrl.Request) (ctrl.Result, error)
        DeleteSliceQoSConfig(ctx context.Context, namespace string) (ctrl.Result, error)
}

// SliceQoSConfigService implements different service interfaces
type SliceQoSConfigService struct {
        wsc IWorkerSliceConfigService
        mf  metrics.IMetricRecorder
}

// ReconcileSliceQoSConfig is a function to reconcile the qos_profile
func (q *SliceQoSConfigService) ReconcileSliceQoSConfig(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        // Step 0: Get SliceQoSConfig resource
        logger := util.CtxLogger(ctx)
        logger.Infof("Started Recoincilation of SliceQoSConfig %v", req.NamespacedName)
        sliceQosConfig := &amp;v1alpha1.SliceQoSConfig{}
        found, err := util.GetResourceIfExist(ctx, req.NamespacedName, sliceQosConfig)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                logger.Infof("QoS Profile %v not found, returning from  reconciler loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>

        //Load Event Recorder with project name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(sliceQosConfig.Namespace)).
                WithNamespace(sliceQosConfig.Namespace)

        // Load metrics with project name and namespace
        q.mf.WithProject(util.GetProjectName(sliceQosConfig.Namespace)).
                WithNamespace(sliceQosConfig.Namespace)

        //Step 1: Finalizers
        if sliceQosConfig.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                if !util.ContainsString(sliceQosConfig.GetFinalizers(), SliceQoSConfigFinalizer) </span><span class="cov0" title="0">{
                        if shouldReturn, result, reconErr := util.IsReconciled(util.AddFinalizer(ctx, sliceQosConfig, SliceQoSConfigFinalizer)); shouldReturn </span><span class="cov0" title="0">{
                                return result, reconErr
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                logger.Debug("starting delete for qos profile", req.NamespacedName)
                if shouldReturn, result, reconErr := util.IsReconciled(util.RemoveFinalizer(ctx, sliceQosConfig, SliceQoSConfigFinalizer)); shouldReturn </span><span class="cov0" title="0">{
                        //Register an event for slice qos config deletion failure
                        util.RecordEvent(ctx, eventRecorder, sliceQosConfig, nil, events.EventSliceQoSConfigDeletionFailed)
                        q.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventSliceQoSConfigDeletionFailed),
                                        "object_name": sliceQosConfig.Name,
                                        "object_kind": metricKindSliceQoSConfig,
                                },
                        )
                        return result, reconErr
                }</span>
                //Register an event for slice qos config deletion
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, sliceQosConfig, nil, events.EventSliceQoSConfigDeleted)
                q.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventSliceQoSConfigDeleted),
                                "object_name": sliceQosConfig.Name,
                                "object_kind": metricKindSliceQoSConfig,
                        },
                )
                return ctrl.Result{}, err</span>
        }

        // Step 2: check if SliceQoSConfig is in project namespace
        <span class="cov0" title="0">nsResource := &amp;corev1.Namespace{}
        found, err = util.GetResourceIfExist(ctx, client.ObjectKey{
                Name: req.Namespace,
        }, nsResource)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found || !q.checkForProjectNamespace(nsResource) </span><span class="cov0" title="0">{
                logger.Infof("Created QoS Profile %v is not in project namespace. Returning from reconciliation loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>

        <span class="cov0" title="0">err = q.updateWorkerSliceConfigs(ctx, req.NamespacedName)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>

        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// checkForProjectNamespace is a function to check the namespace is in proper format
func (q *SliceQoSConfigService) checkForProjectNamespace(namespace *corev1.Namespace) bool <span class="cov0" title="0">{
        return namespace.Labels[util.LabelName] == fmt.Sprintf(util.LabelValue, "Project", namespace.Name)
}</span>

// updateWorkerSliceConfigs is a function to trigger reconciliation of worker slice config whenever there is a change in qos profile
func (q *SliceQoSConfigService) updateWorkerSliceConfigs(ctx context.Context, namespacedName types.NamespacedName) error <span class="cov0" title="0">{
        logger := util.CtxLogger(ctx)
        label := map[string]string{
                StandardQoSProfileLabel: namespacedName.Name,
        }
        workerSlices, err := q.wsc.ListWorkerSliceConfigs(ctx, label, namespacedName.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, workerSlice := range workerSlices </span><span class="cov0" title="0">{
                if workerSlice.Annotations == nil </span><span class="cov0" title="0">{
                        workerSlice.Annotations = make(map[string]string)
                }</span>
                <span class="cov0" title="0">workerSlice.Annotations["updatedTimestamp"] = time.Now().String()
                logger.Debug("Reconciling workerSliceConfig: ", workerSlice.Name)
                err = util.UpdateResource(ctx, &amp;workerSlice)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// DeleteSliceQoSConfig is a function to delete the slice qos config
func (q *SliceQoSConfigService) DeleteSliceQoSConfig(ctx context.Context, namespace string) (ctrl.Result, error) <span class="cov0" title="0">{
        sliceQoSConfigs := &amp;v1alpha1.SliceQoSConfigList{}
        err := util.ListResources(ctx, sliceQoSConfigs, client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">for _, sliceQoSConfig := range sliceQoSConfigs.Items </span><span class="cov0" title="0">{
                //Load Event Recorder with project name, slice name and namespace
                eventRecorder := util.CtxEventRecorder(ctx).
                        WithProject(util.GetProjectName(sliceQoSConfig.Namespace)).
                        WithNamespace(sliceQoSConfig.Namespace)
                // Load metrics with project name and namespace
                q.mf.WithProject(util.GetProjectName(sliceQoSConfig.Namespace)).
                        WithNamespace(sliceQoSConfig.Namespace)

                err = util.DeleteResource(ctx, &amp;sliceQoSConfig)
                if err != nil </span><span class="cov0" title="0">{
                        //Register an event for slice config deletion fail
                        util.RecordEvent(ctx, eventRecorder, &amp;sliceQoSConfig, nil, events.EventSliceQoSConfigDeletionFailed)
                        q.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventSliceConfigDeletionFailed),
                                        "object_name": sliceQoSConfig.Name,
                                        "object_kind": metricKindSliceQoSConfig,
                                },
                        )
                        return ctrl.Result{}, err
                }</span>
                //Register an event for slice config deletion
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;sliceQoSConfig, nil, events.EventSliceQoSConfigDeleted)
                q.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventSliceConfigDeleted),
                                "object_name": sliceQoSConfig.Name,
                                "object_kind": metricKindSliceQoSConfig,
                        },
                )</span>
        }
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package service

import (
        "context"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        workerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/worker/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/util"
        corev1 "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/validation/field"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// ValidateSliceQosConfigCreate is a function to validate the creation of SliceQosConfig
func ValidateSliceQosConfigCreate(ctx context.Context, sliceQoSConfig *controllerv1alpha1.SliceQoSConfig) (admission.Warnings, error) <span class="cov0" title="0">{
        if err := validateSliceQosConfigAppliedInProjectNamespace(ctx, sliceQoSConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceQosConfig"}, sliceQoSConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">if err := validateSliceQosConfigSpec(ctx, sliceQoSConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceQosConfig"}, sliceQoSConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// ValidateSliceQosConfigUpdate is a function to validate the update of SliceQosConfig
func ValidateSliceQosConfigUpdate(ctx context.Context, sliceQoSConfig *controllerv1alpha1.SliceQoSConfig) (admission.Warnings, error) <span class="cov0" title="0">{
        if err := validateSliceQosConfigSpec(ctx, sliceQoSConfig); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceQosConfig"}, sliceQoSConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// ValidateSliceQosConfigDelete is a function to validate the deletion of SliceQosConfig
func ValidateSliceQosConfigDelete(ctx context.Context, sliceQoSConfig *controllerv1alpha1.SliceQoSConfig) (admission.Warnings, error) <span class="cov0" title="0">{
        exists, slices, err := validateIfQosExistsOnAnySlice(ctx, sliceQoSConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                err := field.Forbidden(field.NewPath("SliceQoSConfig"), "The SliceQoSProfile "+sliceQoSConfig.Name+" cannot be deleted. It is present on slices [ "+util.ArrayToString(slices)+" ]")
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceControllers, Kind: "SliceQosConfig"}, sliceQoSConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func validateSliceQosConfigSpec(ctx context.Context, sliceQosConfig *controllerv1alpha1.SliceQoSConfig) *field.Error <span class="cov0" title="0">{
        // check bandwidth
        if sliceQosConfig.Spec.BandwidthCeilingKbps &lt; sliceQosConfig.Spec.BandwidthGuaranteedKbps </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("BandwidthGuaranteedKbps"), sliceQosConfig.Spec.BandwidthGuaranteedKbps, "BandwidthGuaranteedKbps cannot be greater than BandwidthCeilingKbps")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// validateAppliedInProjectNamespace is a function to validate the if the SliceQosConfig is applied in project namespace or not
func validateSliceQosConfigAppliedInProjectNamespace(ctx context.Context, sliceQoSConfig *controllerv1alpha1.SliceQoSConfig) *field.Error <span class="cov0" title="0">{
        namespace := &amp;corev1.Namespace{}
        exist, _ := util.GetResourceIfExist(ctx, client.ObjectKey{Name: sliceQoSConfig.Namespace}, namespace)
        if !exist || !util.CheckForProjectNamespace(namespace) </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("metadata").Child("namespace"), sliceQoSConfig.Name, "SliceQosConfig must be applied on project namespace")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

/* validateIfQosProfileExists function to check if qos profile exists on any of workerslices */
func validateIfQosExistsOnAnySlice(ctx context.Context, sliceQosConfig *controllerv1alpha1.SliceQoSConfig) (bool, []string, error) <span class="cov0" title="0">{
        workerSlices := &amp;workerv1alpha1.WorkerSliceConfigList{}
        slices := make([]string, 0)
        ownerLabel := map[string]string{
                StandardQoSProfileLabel: sliceQosConfig.Name,
        }
        sliceMap := make(map[string]bool)
        err := util.ListResources(ctx, workerSlices, client.MatchingLabels(ownerLabel), client.InNamespace(sliceQosConfig.Namespace))
        if err != nil </span><span class="cov0" title="0">{
                return false, slices, err
        }</span>
        <span class="cov0" title="0">if len(workerSlices.Items) &gt; 0 </span><span class="cov0" title="0">{
                for _, workerSlice := range workerSlices.Items </span><span class="cov0" title="0">{
                        if _, ok := sliceMap[workerSlice.Spec.SliceName]; !ok </span><span class="cov0" title="0">{
                                sliceMap[workerSlice.Spec.SliceName] = true
                                slices = append(slices, workerSlice.Spec.SliceName)
                        }</span>
                }
                <span class="cov0" title="0">return true, slices, nil</span>
        }
        <span class="cov0" title="0">return false, slices, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"
        "reflect"
        "sync/atomic"
        "time"

        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        workerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/worker/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/events"
        "github.com/kubeslice/kubeslice-controller/util"
        batchv1 "k8s.io/api/batch/v1"
        corev1 "k8s.io/api/core/v1"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/types"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
)

type IVpnKeyRotationService interface {
        CreateMinimalVpnKeyRotationConfig(ctx context.Context, sliceName, namespace string, r int) error
        ReconcileClusters(ctx context.Context, sliceName, namespace string, clusters []string) (*controllerv1alpha1.VpnKeyRotation, error)
        ReconcileVpnKeyRotation(ctx context.Context, req ctrl.Request) (ctrl.Result, error)
}

type VpnKeyRotationService struct {
        wsgs                  IWorkerSliceGatewayService
        wscs                  IWorkerSliceConfigService
        jobCreationInProgress atomic.Bool
}

// JobStatus represents the status of a job.
type JobStatus int

const (
        JobStatusComplete JobStatus = iota
        JobStatusError
        JobStatusSuspended
        JobStatusListError
        JobStatusRunning
        JobNotCreated
)

// String returns the string representation of JobStatus.
func (status JobStatus) String() string <span class="cov0" title="0">{
        switch status </span>{
        case JobStatusComplete:<span class="cov0" title="0">
                return "JobStatusComplete"</span>
        case JobStatusError:<span class="cov0" title="0">
                return "JobStatusError"</span>
        case JobStatusSuspended:<span class="cov0" title="0">
                return "JobStatusSuspended"</span>
        case JobStatusListError:<span class="cov0" title="0">
                return "JobStatusListError"</span>
        case JobStatusRunning:<span class="cov0" title="0">
                return "JobStatusRunning"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Unknown JobStatus: %d", status)</span>
        }
}

// CreateMinimalVpnKeyRotationConfig creates minimal VPNKeyRotationCR if not found
func (v *VpnKeyRotationService) CreateMinimalVpnKeyRotationConfig(ctx context.Context, sliceName, namespace string, r int) error <span class="cov0" title="0">{
        logger := util.CtxLogger(ctx).
                With("name", "CreateMinimalVpnKeyRotationConfig").
                With("reconciler", "VpnKeyRotationConfig")

        vpnKeyRotationConfig := controllerv1alpha1.VpnKeyRotation{}
        found, err := util.GetResourceIfExist(ctx, types.NamespacedName{
                Namespace: namespace,
                Name:      sliceName,
        }, &amp;vpnKeyRotationConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error fetching vpnKeyRotationConfig %s. Err: %s ", sliceName, err.Error())
                return err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                vpnKeyRotationConfig = controllerv1alpha1.VpnKeyRotation{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      sliceName,
                                Namespace: namespace,
                                Labels: map[string]string{
                                        "kubeslice-slice": sliceName,
                                },
                        },
                        Spec: controllerv1alpha1.VpnKeyRotationSpec{
                                RotationInterval: r,
                                SliceName:        sliceName,
                                RotationCount:    1,
                        },
                }
                if err := util.CreateResource(ctx, &amp;vpnKeyRotationConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">logger.Debugf("created vpnKeyRotationConfig %s ", sliceName)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ReconcileClusters checks whether any cluster is added/removed and updates it in vpnkeyrotation config
// the first arg is returned for testing purposes
func (v *VpnKeyRotationService) ReconcileClusters(ctx context.Context, sliceName, namespace string, clusters []string) (*controllerv1alpha1.VpnKeyRotation, error) <span class="cov0" title="0">{
        logger := util.CtxLogger(ctx).
                With("name", "ReconcileClusters").
                With("reconciler", "VpnKeyRotationConfig")

        vpnKeyRotationConfig := controllerv1alpha1.VpnKeyRotation{}
        found, err := util.GetResourceIfExist(ctx, types.NamespacedName{
                Namespace: namespace,
                Name:      sliceName,
        }, &amp;vpnKeyRotationConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("error fetching vpnKeyRotationConfig %s. Err: %s ", sliceName, err.Error())
                return nil, err
        }</span>
        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                if !reflect.DeepEqual(vpnKeyRotationConfig.Spec.Clusters, clusters) </span><span class="cov0" title="0">{
                        vpnKeyRotationConfig.Spec.Clusters = clusters
                        return &amp;vpnKeyRotationConfig, util.UpdateResource(ctx, &amp;vpnKeyRotationConfig)
                }</span>
        }
        <span class="cov0" title="0">return &amp;vpnKeyRotationConfig, nil</span>
}

func (v *VpnKeyRotationService) ReconcileVpnKeyRotation(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        // Step 0: Get VpnKeyRotation resource
        logger := util.CtxLogger(ctx).
                With("name", "ReconcileVpnKeyRotation").
                With("reconciler", "VpnKeyRotationConfig")

        logger.Infof("Starting Recoincilation of VpnKeyRotation with name %s in namespace %s",
                req.Name, req.Namespace)
        vpnKeyRotationConfig := &amp;controllerv1alpha1.VpnKeyRotation{}
        found, err := util.GetResourceIfExist(ctx, req.NamespacedName, vpnKeyRotationConfig)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Err: %s", err.Error())
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                logger.Infof("Vpn Key Rotation Config %v not found, returning from reconciler loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>
        // get slice config
        <span class="cov0" title="0">s, err := v.getSliceConfig(ctx, req.Name, req.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Err getting sliceconfig: %s", err.Error())
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if vpnKeyRotationConfig.GetOwnerReferences() == nil </span><span class="cov0" title="0">{
                if err := controllerutil.SetControllerReference(s, vpnKeyRotationConfig, util.GetKubeSliceControllerRequestContext(ctx).Scheme); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("failed to set SliceConfig as owner of vpnKeyRotationConfig. Err %s", err.Error())
                        return ctrl.Result{}, err
                }</span>
        }
        // Step 1: Build map of clusterName: gateways
        <span class="cov0" title="0">clusterGatewayMapping, err := v.constructClusterGatewayMapping(ctx, s)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Err constructing clusterGatewayMapping: %s", err.Error())
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">copyVpnConfig := vpnKeyRotationConfig.DeepCopy()

        toUpdate := false
        if !reflect.DeepEqual(copyVpnConfig.Spec.ClusterGatewayMapping, clusterGatewayMapping) </span><span class="cov0" title="0">{
                copyVpnConfig.Spec.ClusterGatewayMapping = clusterGatewayMapping
                toUpdate = true
        }</span>
        <span class="cov0" title="0">if !reflect.DeepEqual(copyVpnConfig.Spec.RotationInterval, s.Spec.RotationInterval) </span><span class="cov0" title="0">{
                copyVpnConfig.Spec.RotationInterval = s.Spec.RotationInterval
                toUpdate = true
        }</span>
        <span class="cov0" title="0">if !reflect.DeepEqual(copyVpnConfig.Spec.SliceName, s.Name) </span><span class="cov0" title="0">{
                copyVpnConfig.Spec.SliceName = s.Name
                toUpdate = true
        }</span>
        <span class="cov0" title="0">if !reflect.DeepEqual(copyVpnConfig.Spec.Clusters, s.Spec.Clusters) </span><span class="cov0" title="0">{
                copyVpnConfig.Spec.Clusters = s.Spec.Clusters
                toUpdate = true
        }</span>
        <span class="cov0" title="0">if toUpdate </span><span class="cov0" title="0">{
                logger.Debugf("vpnkeyrotation config %s deviated from sliceconfig %s", copyVpnConfig.Name, s.Name)
                if err := util.UpdateResource(ctx, copyVpnConfig); err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Err updating clusterGatewayMapping in vpnconfig: %s", err.Error())
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">return ctrl.Result{Requeue: true}, nil</span>
        }
        // Step 2: TODO Update Certificate Creation TimeStamp and Expiry Timestamp if
        // a. The Creation TS and Expiry TS is empty
        // b. The Current TS is pass the expiry TS
        <span class="cov0" title="0">res, copyVpnConfig, err := v.reconcileVpnKeyRotationConfig(ctx, copyVpnConfig, s)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Err: %s", err.Error())
                return res, err
        }</span>
        <span class="cov0" title="0">if res.RequeueAfter &gt; 0 </span><span class="cov0" title="0">{
                return res, nil
        }</span>
        // always returns error but but if err==nil and copyVpnConfig==nil this means dont requeue
        <span class="cov0" title="0">if copyVpnConfig == nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, nil
        }</span>
        <span class="cov0" title="0">expiryTime := copyVpnConfig.Spec.CertificateExpiryTime.Time
        remainingDuration := expiryTime.Sub(metav1.Now().Time)
        logger.Debugf("vpnkeyrotation config reconciler will requeue after %s", remainingDuration)
        return ctrl.Result{RequeueAfter: remainingDuration}, nil</span>
}

func (v *VpnKeyRotationService) reconcileVpnKeyRotationConfig(ctx context.Context, copyVpnConfig *controllerv1alpha1.VpnKeyRotation, s *controllerv1alpha1.SliceConfig) (ctrl.Result, *controllerv1alpha1.VpnKeyRotation, error) <span class="cov0" title="0">{
        logger := util.CtxLogger(ctx)

        //Load Event Recorder with project name, vpnkeyrotation(slice) name and namespace
        eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(s.Namespace)).
                WithNamespace(s.Namespace).
                WithSlice(s.Name)

        now := metav1.Now()
        // Check if it's the first time creation
        if copyVpnConfig.Spec.CertificateCreationTime.IsZero() &amp;&amp; copyVpnConfig.Spec.CertificateExpiryTime.IsZero() </span><span class="cov0" title="0">{
                // verify jobs are completed
                status, err := v.verifyAllJobsAreCompleted(ctx, copyVpnConfig.Spec.SliceName)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, nil, err
                }</span>
                // requeue after 1 minute if job is still running
                <span class="cov0" title="0">if status == JobStatusRunning </span><span class="cov0" title="0">{
                        return ctrl.Result{RequeueAfter: 30 * time.Second}, nil, nil
                }</span>
                <span class="cov0" title="0">if status == JobStatusError || status == JobStatusSuspended </span><span class="cov0" title="0">{
                        // register an event
                        util.RecordEvent(ctx, eventRecorder, copyVpnConfig, nil, events.EventCertificateJobFailed)
                        return ctrl.Result{}, nil, nil
                }</span>
                <span class="cov0" title="0">if status == JobNotCreated </span><span class="cov0" title="0">{
                        return ctrl.Result{RequeueAfter: 30 * time.Second}, nil, nil
                }</span>

                <span class="cov0" title="0">copyVpnConfig.Spec.CertificateCreationTime = &amp;now
                expiryTS := metav1.NewTime(now.AddDate(0, 0, copyVpnConfig.Spec.RotationInterval).Add(-1 * time.Hour))
                copyVpnConfig.Spec.CertificateExpiryTime = &amp;expiryTS
                if err := util.UpdateResource(ctx, copyVpnConfig); err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, nil, err
                }</span>
                //register an event
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, copyVpnConfig, nil, events.EventVPNKeyRotationConfigUpdated)</span>

        } else<span class="cov0" title="0"> {
                if now.After(copyVpnConfig.Spec.CertificateExpiryTime.Time) </span><span class="cov0" title="0">{
                        if !v.jobCreationInProgress.Load() </span><span class="cov0" title="0">{
                                if err := v.triggerJobsForCertCreation(ctx, copyVpnConfig, s); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("error creating new certs", err)
                                        // register an event
                                        util.RecordEvent(ctx, eventRecorder, copyVpnConfig, nil, events.EventCertificateJobCreationFailed)
                                        return ctrl.Result{}, nil, err
                                }</span>
                                <span class="cov0" title="0">v.jobCreationInProgress.Store(true)
                                logger.Debugf("jobs triggered for creating new certs for slice %s", s.Name)
                                return ctrl.Result{RequeueAfter: 30 * time.Second}, nil, nil</span>
                        }
                        // verify jobs are completed
                        <span class="cov0" title="0">status, err := v.verifyAllJobsAreCompleted(ctx, copyVpnConfig.Spec.SliceName)
                        if err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, nil, err
                        }</span>
                        <span class="cov0" title="0">logger.Debugf("certs job status for sliceconfig %s = %s ", s.Name, status.String())
                        // requeue after 1 minute if job is still running
                        if status == JobStatusRunning </span><span class="cov0" title="0">{
                                return ctrl.Result{RequeueAfter: 30 * time.Second}, nil, nil
                        }</span>
                        <span class="cov0" title="0">if status == JobStatusError || status == JobStatusSuspended </span><span class="cov0" title="0">{
                                // register an event
                                util.RecordEvent(ctx, eventRecorder, copyVpnConfig, nil, events.EventCertificateJobFailed)
                                return ctrl.Result{}, nil, nil
                        }</span>
                        <span class="cov0" title="0">if status == JobNotCreated </span><span class="cov0" title="0">{
                                return ctrl.Result{RequeueAfter: 30 * time.Second}, nil, nil
                        }</span>
                        <span class="cov0" title="0">copyVpnConfig.Spec.CertificateCreationTime = &amp;now
                        expiryTS := metav1.NewTime(now.AddDate(0, 0, copyVpnConfig.Spec.RotationInterval).Add(-1 * time.Hour))
                        copyVpnConfig.Spec.CertificateExpiryTime = &amp;expiryTS
                        copyVpnConfig.Spec.RotationCount = copyVpnConfig.Spec.RotationCount + 1
                        if err := util.UpdateResource(ctx, copyVpnConfig); err != nil </span><span class="cov0" title="0">{
                                return ctrl.Result{}, nil, err
                        }</span>
                        // restore the variable jobCreationInProgress to false
                        <span class="cov0" title="0">v.jobCreationInProgress.Store(false)
                        //register an event
                        util.RecordEvent(ctx, eventRecorder, copyVpnConfig, nil, events.EventVPNKeyRotationStart)</span>
                }
        }
        <span class="cov0" title="0">return ctrl.Result{}, copyVpnConfig, nil</span>
}

func (v *VpnKeyRotationService) constructClusterGatewayMapping(ctx context.Context, s *controllerv1alpha1.SliceConfig) (map[string][]string, error) <span class="cov0" title="0">{
        var clusterGatewayMapping = make(map[string][]string, 0)
        for _, cluster := range s.Spec.Clusters </span><span class="cov0" title="0">{
                // list workerslicegateways
                o := map[string]string{
                        "worker-cluster":      cluster,
                        "original-slice-name": s.Name,
                }
                workerSliceGatewaysList, err := v.listWorkerSliceGateways(ctx, o)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">vl := v.fetchGatewayNames(workerSliceGatewaysList)
                clusterGatewayMapping[cluster] = vl</span>
        }
        <span class="cov0" title="0">return clusterGatewayMapping, nil</span>
}

func (v *VpnKeyRotationService) triggerJobsForCertCreation(ctx context.Context, vpnKeyRotationConfig *controllerv1alpha1.VpnKeyRotation, s *controllerv1alpha1.SliceConfig) error <span class="cov0" title="0">{
        o := map[string]string{
                "original-slice-name": vpnKeyRotationConfig.Spec.SliceName,
        }
        workerSliceGatewaysList, err := v.listWorkerSliceGateways(ctx, o)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // fire certificate creation jobs for each gateway pair
        <span class="cov0" title="0">for _, gateway := range workerSliceGatewaysList.Items </span><span class="cov0" title="0">{
                if gateway.Spec.GatewayHostType == "Server" </span><span class="cov0" title="0">{
                        cl, err := v.listClientPairGateway(workerSliceGatewaysList, gateway.Spec.RemoteGatewayConfig.GatewayName)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // construct clustermap
                        <span class="cov0" title="0">clusterCidr := util.FindCIDRByMaxClusters(s.Spec.MaxClusters)
                        completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(s), s.GetName())
                        ownershipLabel := util.GetOwnerLabel(completeResourceName)
                        workerSliceConfigs, err := v.wscs.ListWorkerSliceConfigs(ctx, ownershipLabel, s.Namespace)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">clusterMap := v.wscs.ComputeClusterMap(s.Spec.Clusters, workerSliceConfigs)
                        // contruct gw address
                        gatewayAddresses := v.wsgs.BuildNetworkAddresses(s.Spec.SliceSubnet, gateway.Spec.LocalGatewayConfig.ClusterName, gateway.Spec.RemoteGatewayConfig.ClusterName, clusterMap, clusterCidr)
                        // call GenerateCerts()
                        if err := v.wsgs.GenerateCerts(ctx, s.Name, s.Namespace, gateway.Spec.GatewayProtocol, &amp;gateway, cl, gatewayAddresses); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (v *VpnKeyRotationService) listWorkerSliceGateways(ctx context.Context, labels map[string]string) (*workerv1alpha1.WorkerSliceGatewayList, error) <span class="cov0" title="0">{
        workerSliceGatewaysList := workerv1alpha1.WorkerSliceGatewayList{}
        // list workerslicegateways
        listOpts := []client.ListOption{
                client.MatchingLabels(
                        labels,
                ),
        }
        if err := util.ListResources(ctx, &amp;workerSliceGatewaysList, listOpts...); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;workerSliceGatewaysList, nil</span>
}

// getSliceConfig
func (v *VpnKeyRotationService) getSliceConfig(ctx context.Context, name, namespace string) (*controllerv1alpha1.SliceConfig, error) <span class="cov0" title="0">{
        s := controllerv1alpha1.SliceConfig{}
        found, err := util.GetResourceIfExist(ctx, types.NamespacedName{
                Name:      name,
                Namespace: namespace,
        }, &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("sliceconfig %s not found", name)
        }</span>
        <span class="cov0" title="0">return &amp;s, nil</span>
}

func (v *VpnKeyRotationService) listClientPairGateway(wl *workerv1alpha1.WorkerSliceGatewayList, clientGatewayName string) (*workerv1alpha1.WorkerSliceGateway, error) <span class="cov0" title="0">{
        for _, gateway := range wl.Items </span><span class="cov0" title="0">{
                if gateway.Name == clientGatewayName </span><span class="cov0" title="0">{
                        return &amp;gateway, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("cannot find gateway %s", clientGatewayName)</span>
}

// verifyAllJobsAreCompleted checks if all the jobs are in complete state
func (v *VpnKeyRotationService) verifyAllJobsAreCompleted(ctx context.Context, sliceName string) (JobStatus, error) <span class="cov0" title="0">{
        jobs := batchv1.JobList{}
        o := map[string]string{
                "SLICE_NAME": sliceName,
        }
        listOpts := []client.ListOption{
                client.MatchingLabels(o),
        }
        if err := util.ListResources(ctx, &amp;jobs, listOpts...); err != nil </span><span class="cov0" title="0">{
                return JobStatusListError, err
        }</span>

        <span class="cov0" title="0">if len(jobs.Items) == 0 </span><span class="cov0" title="0">{
                return JobNotCreated, nil
        }</span>

        <span class="cov0" title="0">for _, job := range jobs.Items </span><span class="cov0" title="0">{
                for _, condition := range job.Status.Conditions </span><span class="cov0" title="0">{
                        if condition.Type == batchv1.JobFailed &amp;&amp; condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                return JobStatusError, nil
                        }</span>

                        <span class="cov0" title="0">if condition.Type == batchv1.JobSuspended &amp;&amp; condition.Status == corev1.ConditionTrue </span><span class="cov0" title="0">{
                                return JobStatusSuspended, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">for _, job := range jobs.Items </span><span class="cov0" title="0">{
                if job.Status.Active &gt; 0 </span><span class="cov0" title="0">{
                        return JobStatusRunning, nil
                }</span>
        }

        <span class="cov0" title="0">return JobStatusComplete, nil</span>
}

// fetchGatewayNames fetches gateway names from the list of workerv1alpha1.WorkerSliceGatewayList
func (v *VpnKeyRotationService) fetchGatewayNames(gl *workerv1alpha1.WorkerSliceGatewayList) []string <span class="cov0" title="0">{
        var gatewayNames []string
        for _, g := range gl.Items </span><span class="cov0" title="0">{
                if g.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        gatewayNames = append(gatewayNames, g.Name)
                }</span>
        }
        <span class="cov0" title="0">return gatewayNames</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package service

import (
        "context"
        "fmt"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/events"
        "github.com/kubeslice/kubeslice-controller/util"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

func ValidateVpnKeyRotationCreate(ctx context.Context, r *controllerv1alpha1.VpnKeyRotation) (admission.Warnings, error) <span class="cov0" title="0">{
        if r.Spec.SliceName == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config,.spec.sliceName could not be empty")
        }</span>
        <span class="cov0" title="0">if r.Name != r.Spec.SliceName </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config, name should match with slice name")
        }</span>
        <span class="cov0" title="0">slice := &amp;controllerv1alpha1.SliceConfig{}
        found, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                Name:      r.Spec.SliceName,
                Namespace: r.Namespace,
        }, slice)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid config, sliceconfig %s not present", r.Spec.SliceName)
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

func ValidateVpnKeyRotationDelete(ctx context.Context, r *controllerv1alpha1.VpnKeyRotation) (admission.Warnings, error) <span class="cov0" title="0">{
        slice := &amp;controllerv1alpha1.SliceConfig{}
        found, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                Name:      r.Spec.SliceName,
                Namespace: r.Namespace,
        }, slice)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if found &amp;&amp; slice.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                //Load Event Recorder with project name, vpnkeyrotation(slice) name and namespace
                eventRecorder := util.CtxEventRecorder(ctx).
                        WithProject(util.GetProjectName(r.Namespace)).
                        WithNamespace(r.Namespace).
                        WithSlice(r.Name)
                //Register an event for worker slice config deleted forcefully
                util.RecordEvent(ctx, eventRecorder, r, slice, events.EventIllegalVPNKeyRotationConfigDelete)
                return nil, fmt.Errorf("vpnkeyrotation config %s not allowed to delete unless sliceconfig is deleted", r.Name)
        }</span>
        // if not found or timestamp is non-zero,this means slice is deleted/under deletion.
        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"
        "time"

        "github.com/kubeslice/kubeslice-controller/metrics"

        "github.com/kubeslice/kubeslice-controller/events"

        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        workerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/worker/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/util"
        "go.uber.org/zap"
        k8sErrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type IWorkerServiceImportService interface {
        ReconcileWorkerServiceImport(ctx context.Context, req ctrl.Request) (ctrl.Result, error)
        CreateMinimalWorkerServiceImport(ctx context.Context, clusters []string, namespace string, label map[string]string,
                serviceName string, serviceNamespace string, sliceName string, aliases []string) error
        DeleteWorkerServiceImportByLabel(ctx context.Context, label map[string]string, namespace string) error
        ListWorkerServiceImport(ctx context.Context, ownerLabel map[string]string, namespace string) ([]workerv1alpha1.WorkerServiceImport, error)
        ForceReconciliation(ctx context.Context, list []workerv1alpha1.WorkerServiceImport) error
        LookupServiceExportForService(ctx context.Context,
                serviceExportList *controllerv1alpha1.ServiceExportConfigList,
                namespace, serviceName, serviceNamespace, sliceName string) error
}

type WorkerServiceImportService struct {
        mf metrics.IMetricRecorder
}

// ReconcileWorkerServiceImport is a function to reconcile the service import for worker object
func (s *WorkerServiceImportService) ReconcileWorkerServiceImport(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        // Step 0: Get WorkerServiceImport resource
        logger := util.CtxLogger(ctx)
        logger.Infof("Started Recoincilation of WorkerServiceImport %v", req.NamespacedName)
        workerServiceImport := &amp;workerv1alpha1.WorkerServiceImport{}
        found, err := util.GetResourceIfExist(ctx, req.NamespacedName, workerServiceImport)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                logger.Infof("workerServiceImport %v not found, returning from  reconciler loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>
        //Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(req.Namespace)).
                WithNamespace(req.Namespace).
                WithSlice(workerServiceImport.Labels["original-slice-name"])

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(req.Namespace)).
                WithNamespace(req.Namespace).
                WithSlice(workerServiceImport.Labels["original-slice-name"])

        //Step 1: Finalizers
        if workerServiceImport.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                if !util.ContainsString(workerServiceImport.GetFinalizers(), WorkerServiceImportFinalizer) </span><span class="cov0" title="0">{
                        if shouldReturn, result, reconErr := util.IsReconciled(util.AddFinalizer(ctx, workerServiceImport, WorkerServiceImportFinalizer)); shouldReturn </span><span class="cov0" title="0">{
                                return result, reconErr
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                logger.Debugf("starting delete for WorkerServiceImport %v", req.NamespacedName)
                result := RemoveWorkerFinalizers(ctx, workerServiceImport, WorkerServiceImportFinalizer)
                if result.Requeue </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
                <span class="cov0" title="0">serviceExportList := &amp;controllerv1alpha1.ServiceExportConfigList{}
                err = s.LookupServiceExportForService(ctx, serviceExportList, req.Namespace, workerServiceImport.Spec.ServiceName, workerServiceImport.Spec.ServiceNamespace, workerServiceImport.Spec.SliceName)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">found = len(serviceExportList.Items) &gt; 0
                if found &amp;&amp; serviceExportList.Items[0].ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        serviceExport := &amp;serviceExportList.Items[0]
                        slice := &amp;controllerv1alpha1.SliceConfig{}
                        exist, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                                Name:      serviceExport.Spec.SliceName,
                                Namespace: req.Namespace,
                        }, slice)
                        if err != nil </span><span class="cov0" title="0">{
                                return result, err
                        }</span>
                        <span class="cov0" title="0">if exist &amp;&amp; util.IsInSlice(slice.Spec.Clusters, workerServiceImport.Labels["worker-cluster"]) </span><span class="cov0" title="0">{
                                //Register an event for worker service import deleted forcefully
                                util.RecordEvent(ctx, eventRecorder, workerServiceImport, serviceExport, events.EventWorkerServiceImportDeletedForcefully)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deleted_forcefully",
                                                "event":       string(events.EventWorkerServiceImportDeletedForcefully),
                                                "object_name": workerServiceImport.Name,
                                                "object_kind": metricKindWorkerServiceImport,
                                        },
                                )
                                if serviceExport.Annotations == nil </span><span class="cov0" title="0">{
                                        serviceExport.Annotations = make(map[string]string)
                                }</span>
                                <span class="cov0" title="0">serviceExport.Annotations["updatedTimestamp"] = time.Now().String()
                                err = util.UpdateResource(ctx, serviceExport)
                                if err != nil </span><span class="cov0" title="0">{
                                        //Register an event for worker service import recreation failure
                                        util.RecordEvent(ctx, eventRecorder, workerServiceImport, serviceExport, events.EventWorkerServiceImportRecreationFailed)
                                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                                map[string]string{
                                                        "action":      "recreation_failed",
                                                        "event":       string(events.EventWorkerServiceImportRecreationFailed),
                                                        "object_name": workerServiceImport.Name,
                                                        "object_kind": metricKindWorkerServiceImport,
                                                },
                                        )
                                        return result, err
                                }</span>
                                //Register an event for worker service import recreation success
                                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, workerServiceImport, serviceExport, events.EventWorkerServiceImportRecreated)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "recreated",
                                                "event":       string(events.EventWorkerServiceImportRecreated),
                                                "object_name": workerServiceImport.Name,
                                                "object_kind": metricKindWorkerServiceImport,
                                        },
                                )</span>
                        }
                }
                <span class="cov0" title="0">return result, nil</span>
        }

        <span class="cov0" title="0">serviceExportList := &amp;controllerv1alpha1.ServiceExportConfigList{}
        err = s.LookupServiceExportForService(ctx, serviceExportList, req.Namespace, workerServiceImport.Spec.ServiceName, workerServiceImport.Spec.ServiceNamespace, workerServiceImport.Spec.SliceName)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("failed to list resources of kind ServiceExportConfig for service import reconciliation %v", workerServiceImport)
                return ctrl.Result{Requeue: true, RequeueAfter: 10 * time.Second}, err
        }</span>
        <span class="cov0" title="0">found = len(serviceExportList.Items) &gt; 0
        if !found </span><span class="cov0" title="0">{
                logger.Infof("serviceExport %v not found, returning from  reconciler loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>
        //add more fields
        <span class="cov0" title="0">serviceImportSpec := s.copySpecFromServiceExportConfigToWorkerServiceImport(ctx, serviceExportList.Items)
        workerServiceImport.Spec = serviceImportSpec
        workerServiceImport.UID = ""
        err = util.UpdateResource(ctx, workerServiceImport)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, err</span>
}

// CreateMinimalWorkerServiceImport is a function to create the service import on worker object/cluster
func (s *WorkerServiceImportService) CreateMinimalWorkerServiceImport(ctx context.Context, clusters []string,
        namespace string, label map[string]string, serviceName string, serviceNamespace string, sliceName string, aliases []string) error <span class="cov0" title="0">{
        logger := util.CtxLogger(ctx)
        err := s.cleanUpWorkerServiceImportsForRemovedClusters(ctx, label, namespace, clusters)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(sliceName)

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(sliceName)

        for _, cluster := range clusters </span><span class="cov0" title="0">{
                logger.Debugf("Cluster Object %s", cluster)
                label["worker-cluster"] = cluster
                label["project-namespace"] = namespace
                label["original-slice-name"] = sliceName
                label["kubeslice-manager"] = "controller"

                expectedWorkerServiceImport := workerv1alpha1.WorkerServiceImport{
                        TypeMeta: metav1.TypeMeta{},
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      fmt.Sprintf("%s-%s-%s-%s", serviceName, serviceNamespace, sliceName, cluster),
                                Labels:    label,
                                Namespace: namespace,
                        },
                        Spec: workerv1alpha1.WorkerServiceImportSpec{
                                ServiceName:      serviceName,
                                ServiceNamespace: serviceNamespace,
                                SliceName:        sliceName,
                                Aliases:          aliases,
                        },
                }
                existingWorkerServiceImport := &amp;workerv1alpha1.WorkerServiceImport{}
                found, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                        Name:      expectedWorkerServiceImport.Name,
                        Namespace: namespace,
                }, existingWorkerServiceImport)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        err = util.CreateResource(ctx, &amp;expectedWorkerServiceImport)
                        if err != nil </span><span class="cov0" title="0">{
                                //Register an event for worker service import create failure
                                util.RecordEvent(ctx, eventRecorder, &amp;expectedWorkerServiceImport, nil, events.EventWorkerServiceImportCreationFailed)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "creation_failed",
                                                "event":       string(events.EventWorkerServiceImportCreationFailed),
                                                "object_name": expectedWorkerServiceImport.Name,
                                                "object_kind": metricKindWorkerServiceImport,
                                        },
                                )
                                if !k8sErrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{ // ignores resource already exists error (for handling parallel calls to create same resource)
                                        logger.Debug("failed to create worker service import %s since it already exists, namespace - %s ",
                                                expectedWorkerServiceImport.Name, namespace)
                                        return err
                                }</span>
                        }
                        //Register an event for worker service import create success
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;expectedWorkerServiceImport, nil, events.EventWorkerServiceImportCreated)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "created",
                                        "event":       string(events.EventWorkerServiceImportCreated),
                                        "object_name": expectedWorkerServiceImport.Name,
                                        "object_kind": metricKindWorkerServiceImport,
                                },
                        )</span>
                } else<span class="cov0" title="0"> {
                        existingWorkerServiceImport.UID = ""
                        if existingWorkerServiceImport.Annotations == nil </span><span class="cov0" title="0">{
                                existingWorkerServiceImport.Annotations = make(map[string]string)
                        }</span>
                        <span class="cov0" title="0">existingWorkerServiceImport.Annotations["updatedTimestamp"] = time.Now().String()
                        err = util.UpdateResource(ctx, existingWorkerServiceImport)
                        if err != nil </span><span class="cov0" title="0">{
                                //Register an event for worker service import update failure
                                util.RecordEvent(ctx, eventRecorder, existingWorkerServiceImport, nil, events.EventWorkerServiceImportUpdateFailed)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "update_failed",
                                                "event":       string(events.EventWorkerServiceImportUpdateFailed),
                                                "object_name": existingWorkerServiceImport.Name,
                                                "object_kind": metricKindWorkerServiceImport,
                                        },
                                )
                                if !k8sErrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{ // ignores resource already exists error (for handling parallel calls to create same resource)
                                        logger.Debug("failed to create service import %s since it already exists, namespace - %s ",
                                                existingWorkerServiceImport.Name, namespace)
                                        return err
                                }</span>
                        }
                        //Register an event for worker service import update success
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, existingWorkerServiceImport, nil, events.EventWorkerServiceImportUpdated)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "updated",
                                        "event":       string(events.EventWorkerServiceImportUpdated),
                                        "object_name": existingWorkerServiceImport.Name,
                                        "object_kind": metricKindWorkerServiceImport,
                                },
                        )</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// DeleteWorkerServiceImportByLabel is function to delete the service import from worker cluster/object
func (s *WorkerServiceImportService) DeleteWorkerServiceImportByLabel(ctx context.Context, label map[string]string, namespace string) error <span class="cov0" title="0">{
        workerServiceImports, err := s.ListWorkerServiceImport(ctx, label, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        //Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(label["original-slice-name"])

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(label["original-slice-name"])

        for _, serviceImport := range workerServiceImports </span><span class="cov0" title="0">{
                err = util.DeleteResource(ctx, &amp;serviceImport)
                if err != nil </span><span class="cov0" title="0">{
                        //Register an event for worker service import delete failure
                        util.RecordEvent(ctx, eventRecorder, &amp;serviceImport, nil, events.EventWorkerServiceImportDeletionFailed)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventWorkerServiceImportDeletionFailed),
                                        "object_name": serviceImport.Name,
                                        "object_kind": metricKindWorkerServiceImport,
                                },
                        )
                        return err
                }</span>
                //Register an event for worker service import delete success
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;serviceImport, nil, events.EventWorkerServiceImportDeleted)
                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventWorkerServiceImportDeleted),
                                "object_name": serviceImport.Name,
                                "object_kind": metricKindWorkerServiceImport,
                        },
                )</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ListWorkerServiceImport is a function to list down the serviceImport
func (s *WorkerServiceImportService) ListWorkerServiceImport(ctx context.Context, ownerLabel map[string]string,
        namespace string) ([]workerv1alpha1.WorkerServiceImport, error) <span class="cov0" title="0">{
        workerServiceImports := &amp;workerv1alpha1.WorkerServiceImportList{}
        err := util.ListResources(ctx, workerServiceImports, client.MatchingLabels(ownerLabel), client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return workerServiceImports.Items, nil</span>
}

// cleanUpWorkerServiceImportsForRemovedClusters is a function to remove the service import for deleted clusters
func (s *WorkerServiceImportService) cleanUpWorkerServiceImportsForRemovedClusters(ctx context.Context, label map[string]string, namespace string, clusters []string) error <span class="cov0" title="0">{
        serviceImports, err := s.ListWorkerServiceImport(ctx, label, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">clusterSet := map[string]bool{}
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                clusterSet[cluster] = true
        }</span>
        //Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(label["original-slice-name"])

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(label["original-slice-name"])

        for _, serviceImport := range serviceImports </span><span class="cov0" title="0">{
                clusterName := serviceImport.Labels["worker-cluster"]
                if !clusterSet[clusterName] </span><span class="cov0" title="0">{
                        err = util.DeleteResource(ctx, &amp;serviceImport)
                        if err != nil </span><span class="cov0" title="0">{
                                //Register an event for worker service import delete failure
                                util.RecordEvent(ctx, eventRecorder, &amp;serviceImport, nil, events.EventWorkerServiceImportDeletionFailed)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deletion_failed",
                                                "event":       string(events.EventWorkerServiceImportDeletionFailed),
                                                "object_name": serviceImport.Name,
                                                "object_kind": metricKindWorkerServiceImport,
                                        },
                                )
                                return err
                        }</span>
                        //Register an event for worker service import delete success
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;serviceImport, nil, events.EventWorkerServiceImportDeleted)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deleted",
                                        "event":       string(events.EventWorkerServiceImportDeleted),
                                        "object_name": serviceImport.Name,
                                        "object_kind": metricKindWorkerServiceImport,
                                },
                        )</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// copySpecFromServiceExportConfigToWorkerServiceImport is a function to copy the service export configuration from controller to worker
func (s *WorkerServiceImportService) copySpecFromServiceExportConfigToWorkerServiceImport(ctx context.Context,
        serviceExportConfig []controllerv1alpha1.ServiceExportConfig) workerv1alpha1.WorkerServiceImportSpec <span class="cov0" title="0">{
        serviceExport := serviceExportConfig[0]
        spec := workerv1alpha1.WorkerServiceImportSpec{
                ServiceName:      serviceExport.Spec.ServiceName,
                ServiceNamespace: serviceExport.Spec.ServiceNamespace,
                SliceName:        serviceExport.Spec.SliceName,
                Aliases:          serviceExport.Spec.Aliases,
        }
        sc := make([]string, 0)
        sde := make([]workerv1alpha1.ServiceDiscoveryEndpoint, 0)
        sdp := make([]workerv1alpha1.ServiceDiscoveryPort, 0)
        for _, config := range serviceExportConfig </span><span class="cov0" title="0">{
                sc = append(sc, config.Spec.SourceCluster)
                for _, ep := range config.Spec.ServiceDiscoveryEndpoints </span><span class="cov0" title="0">{
                        sde = append(sde, workerv1alpha1.ServiceDiscoveryEndpoint{
                                PodName: ep.PodName,
                                Cluster: config.Spec.SourceCluster,
                                NsmIp:   ep.NsmIp,
                                DnsName: ep.DnsName,
                                Port:    ep.Port,
                        })
                }</span>
        }
        <span class="cov0" title="0">for _, port := range serviceExport.Spec.ServiceDiscoveryPorts </span><span class="cov0" title="0">{
                sdp = append(sdp, workerv1alpha1.ServiceDiscoveryPort{
                        Name:            port.Name,
                        Port:            port.Port,
                        Protocol:        port.Protocol,
                        ServicePort:     port.ServicePort,
                        ServiceProtocol: port.ServiceProtocol,
                })
        }</span>
        <span class="cov0" title="0">spec.SourceClusters = sc
        spec.ServiceDiscoveryEndpoints = sde
        spec.ServiceDiscoveryPorts = sdp
        return spec</span>
}

// LookupServiceExportForService Returns a list of non-deleted ServiceExport for the service configuration
func (s *WorkerServiceImportService) LookupServiceExportForService(ctx context.Context,
        serviceExportList *controllerv1alpha1.ServiceExportConfigList,
        namespace, serviceName, serviceNamespace, sliceName string) error <span class="cov0" title="0">{
        sel := make([]controllerv1alpha1.ServiceExportConfig, 0)
        labels := map[string]string{
                "service-name":        serviceName,
                "service-namespace":   serviceNamespace,
                "original-slice-name": sliceName,
        }
        err := util.ListResources(ctx, serviceExportList, client.InNamespace(namespace), client.MatchingLabels(labels))
        for _, item := range serviceExportList.Items </span><span class="cov0" title="0">{
                if item.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        sel = append(sel, item)
                }</span>
        }
        <span class="cov0" title="0">serviceExportList.Items = sel
        return err</span>
}

// ForceReconciliation is a function to update the worker service import
func (s *WorkerServiceImportService) ForceReconciliation(ctx context.Context,
        list []workerv1alpha1.WorkerServiceImport) error <span class="cov0" title="0">{
        logger := util.CtxLogger(ctx)
        for _, serviceImport := range list </span><span class="cov0" title="0">{
                serviceImport.UID = ""
                if serviceImport.Annotations == nil </span><span class="cov0" title="0">{
                        serviceImport.Annotations = make(map[string]string)
                }</span>
                <span class="cov0" title="0">serviceImport.Annotations["updatedTimestamp"] = time.Now().String()
                err := util.UpdateResource(ctx, &amp;serviceImport)
                if err != nil </span><span class="cov0" title="0">{
                        logger.With(zap.Error(err)).Errorf("failed to update service import %s", serviceImport.Name)
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "fmt"
        "time"

        "github.com/jinzhu/copier"
        "go.uber.org/zap"
        k8sErrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"

        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"
        workerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/worker/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/events"
        "github.com/kubeslice/kubeslice-controller/metrics"
        "github.com/kubeslice/kubeslice-controller/util"
)

const workerSliceConfigNameFormat = "%s-%s"

type IWorkerSliceConfigService interface {
        ReconcileWorkerSliceConfig(ctx context.Context, req ctrl.Request) (ctrl.Result, error)
        DeleteWorkerSliceConfigByLabel(ctx context.Context, label map[string]string, namespace string) error
        ListWorkerSliceConfigs(ctx context.Context, ownerLabel map[string]string, namespace string) ([]workerv1alpha1.WorkerSliceConfig, error)
        ComputeClusterMap(clusterNames []string, workerSliceConfigs []workerv1alpha1.WorkerSliceConfig) map[string]int
        CreateMinimalWorkerSliceConfig(ctx context.Context, clusters []string, namespace string, label map[string]string, name, sliceSubnet string, clusterCidr string, sliceGwSvcTypeMap map[string]*controllerv1alpha1.SliceGatewayServiceType) (map[string]int, error)
        CreateMinimalWorkerSliceConfigForNoNetworkSlice(ctx context.Context, clusters []string, namespace string, label map[string]string, name string) error
}

// WorkerSliceConfigService implements the IWorkerSliceConfigService interface
type WorkerSliceConfigService struct {
        mf metrics.IMetricRecorder
}

// ReconcileWorkerSliceConfig is a function to reconcile the config of worker slice
func (s *WorkerSliceConfigService) ReconcileWorkerSliceConfig(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        // Step 0: Get WorkerSliceConfig resource
        logger := util.CtxLogger(ctx)
        logger.Infof("Starting Recoincilation of WorkerSliceConfig with name %s in namespace %s",
                req.Name, req.Namespace)
        workerSliceConfig := &amp;workerv1alpha1.WorkerSliceConfig{}
        found, err := util.GetResourceIfExist(ctx, req.NamespacedName, workerSliceConfig)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                logger.Infof("Worker slice config %v not found, returning from reconciler loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>

        //Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(req.Namespace)).
                WithNamespace(req.Namespace).
                WithSlice(workerSliceConfig.Labels["original-slice-name"])

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(req.Namespace)).
                WithNamespace(req.Namespace).
                WithSlice(workerSliceConfig.Labels["original-slice-name"])

        // Step 2: add Finalizers to the resource
        if workerSliceConfig.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                if !util.ContainsString(workerSliceConfig.GetFinalizers(), WorkerSliceConfigFinalizer) </span><span class="cov0" title="0">{
                        if shouldReturn, result, reconErr := util.IsReconciled(util.AddFinalizer(ctx, workerSliceConfig, WorkerSliceConfigFinalizer)); shouldReturn </span><span class="cov0" title="0">{
                                return result, reconErr
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                logger.Debug("starting delete for WorkerSliceConfig", req.NamespacedName)
                result := RemoveWorkerFinalizers(ctx, workerSliceConfig, WorkerSliceConfigFinalizer)
                if result.Requeue </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
                <span class="cov0" title="0">slice := &amp;controllerv1alpha1.SliceConfig{}
                found, err = util.GetResourceIfExist(ctx, client.ObjectKey{
                        Name:      workerSliceConfig.Spec.SliceName,
                        Namespace: req.Namespace,
                }, slice)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">if found &amp;&amp; slice.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        clusters := slice.Spec.Clusters
                        if util.IsInSlice(clusters, workerSliceConfig.Labels["worker-cluster"]) </span><span class="cov0" title="0">{
                                logger.Debug("workerSliceConfig deleted forcefully from slice", req.NamespacedName)
                                //Register an event for worker slice config deleted forcefully
                                util.RecordEvent(ctx, eventRecorder, workerSliceConfig, slice, events.EventWorkerSliceConfigDeletedForcefully)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deleted_forcefully",
                                                "event":       string(events.EventWorkerSliceConfigDeletedForcefully),
                                                "object_name": workerSliceConfig.Name,
                                                "object_kind": metricKindWorkerSliceConfig,
                                        },
                                )
                                if slice.Annotations == nil </span><span class="cov0" title="0">{
                                        slice.Annotations = make(map[string]string)
                                }</span>
                                <span class="cov0" title="0">slice.Annotations["updatedTimestamp"] = time.Now().String()
                                logger.Debug("Recreating workerSliceConfig", req.NamespacedName)
                                err = util.UpdateResource(ctx, slice)
                                if err != nil </span><span class="cov0" title="0">{
                                        //Register an event for worker slice config recreation failure
                                        util.RecordEvent(ctx, eventRecorder, workerSliceConfig, slice, events.EventWorkerSliceConfigRecreationFailed)
                                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                                map[string]string{
                                                        "action":      "recreation_failed",
                                                        "event":       string(events.EventWorkerSliceConfigRecreationFailed),
                                                        "object_name": workerSliceConfig.Name,
                                                        "object_kind": metricKindWorkerSliceConfig,
                                                },
                                        )
                                        return result, err
                                }</span>
                                //Register an event for worker slice config recreation success
                                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, workerSliceConfig, slice, events.EventWorkerSliceConfigRecreated)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "recreated",
                                                "event":       string(events.EventWorkerSliceConfigRecreated),
                                                "object_name": workerSliceConfig.Name,
                                                "object_kind": metricKindWorkerSliceConfig,
                                        },
                                )</span>
                        }
                }
                <span class="cov0" title="0">return result, nil</span>
        }

        // Step 3: get the slice config
        <span class="cov0" title="0">sliceConfig := &amp;controllerv1alpha1.SliceConfig{}
        found, err = util.GetResourceIfExist(ctx, client.ObjectKey{
                Name:      workerSliceConfig.Spec.SliceName,
                Namespace: req.Namespace,
        }, sliceConfig)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                logger.Infof("sliceConfig %v not found, returning from  reconciler loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>
        <span class="cov0" title="0">octet := workerSliceConfig.Spec.Octet
        clusterSubnetCIDR := workerSliceConfig.Spec.ClusterSubnetCIDR
        slice := s.copySpecFromSliceConfigToWorkerSlice(ctx, *sliceConfig)
        workerSliceConfig.Spec = slice.Spec

        // add missing project label to sliceConfig
        additionalLabels := util.FilterLabelsAndAnnotations(sliceConfig.Labels)
        additionalAnnotations := util.FilterLabelsAndAnnotations(sliceConfig.Annotations)
        if workerSliceConfig.Labels == nil </span><span class="cov0" title="0">{
                workerSliceConfig.Labels = make(map[string]string)
        }</span>
        // add missing labels to workerSliceConfig
        <span class="cov0" title="0">for key, value := range additionalLabels </span><span class="cov0" title="0">{
                if val, ok := workerSliceConfig.Labels[key]; !ok &amp;&amp; val != value </span><span class="cov0" title="0">{
                        workerSliceConfig.Labels[key] = value
                }</span>
        }
        <span class="cov0" title="0">if workerSliceConfig.Annotations == nil </span><span class="cov0" title="0">{
                workerSliceConfig.Annotations = make(map[string]string)
        }</span>
        <span class="cov0" title="0">for key, value := range additionalAnnotations </span><span class="cov0" title="0">{
                if val, ok := workerSliceConfig.Annotations[key]; !ok &amp;&amp; val != value </span><span class="cov0" title="0">{
                        workerSliceConfig.Annotations[key] = value
                }</span>
        }

        // if standardQos Found update the workerSliceConfig
        <span class="cov0" title="0">if sliceConfig.Spec.StandardQosProfileName != "" </span><span class="cov0" title="0">{
                qos := &amp;controllerv1alpha1.SliceQoSConfig{}
                found, err = util.GetResourceIfExist(ctx, client.ObjectKey{
                        Name:      sliceConfig.Spec.StandardQosProfileName,
                        Namespace: req.Namespace,
                }, qos)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        logger.Infof("QOS profile %v not found, returning from  reconciler loop.", sliceConfig.Spec.StandardQosProfileName)
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">workerSliceConfig.Spec.QosProfileDetails = workerv1alpha1.QOSProfile{
                        QueueType:               qos.Spec.QueueType,
                        Priority:                qos.Spec.Priority,
                        TcType:                  qos.Spec.TcType,
                        BandwidthCeilingKbps:    qos.Spec.BandwidthCeilingKbps,
                        BandwidthGuaranteedKbps: qos.Spec.BandwidthGuaranteedKbps,
                        DscpClass:               qos.Spec.DscpClass,
                }
                workerSliceConfig.Labels["standard-qos-profile"] = sliceConfig.Spec.StandardQosProfileName</span>
        } else<span class="cov0" title="0"> {
                workerSliceConfig.Labels["standard-qos-profile"] = ""
        }</span>

        // Reconcile External Gateway Configuration
        <span class="cov0" title="0">externalGatewayConfig := workerv1alpha1.ExternalGatewayConfig{}
        var externalGatewayControllersConfig controllerv1alpha1.ExternalGatewayConfig
outer:
        for _, config := range sliceConfig.Spec.ExternalGatewayConfig </span><span class="cov0" title="0">{
                for _, cluster := range config.Clusters </span><span class="cov0" title="0">{
                        if cluster == "*" </span><span class="cov0" title="0">{
                                externalGatewayControllersConfig = config
                        }</span> else<span class="cov0" title="0"> if cluster == workerSliceConfig.Labels["worker-cluster"] </span><span class="cov0" title="0">{
                                externalGatewayControllersConfig = config
                                break outer</span>
                        }
                }
        }
        <span class="cov0" title="0">err = copier.CopyWithOption(&amp;externalGatewayConfig, &amp;externalGatewayControllersConfig, copier.Option{
                DeepCopy: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.With(zap.Error(err)).Errorf("Failed to deep copy external gateway configuration")
        }</span>

        // determine Slice gateway service type
        <span class="cov0" title="0">sliceGwSvcTypeMap := getSliceGwSvcTypes(sliceConfig)
        sliceGwSvcType := defaultSliceGatewayServiceType
        sliceGwSvcProtocol := defaultSliceGatewayServiceProtocol
        cluster := workerSliceConfig.Labels["worker-cluster"]
        if val, exists := sliceGwSvcTypeMap[cluster]; exists </span><span class="cov0" title="0">{
                sliceGwSvcType = val.Type
                sliceGwSvcProtocol = val.Protocol
        }</span>
        <span class="cov0" title="0">logger.Debugf("wsc %s reconciler, sliceGwSvcType %s", workerSliceConfig.Name, sliceGwSvcType)
        logger.Debugf("slicegwsvctype map in wsc %s", sliceGwSvcTypeMap)
        logger.Debugf("wsc reconciler cluster %s, sliceGwProtocol %s", workerSliceConfig.Labels["worker-cluster"], sliceGwSvcProtocol)

        // Reconcile the Namespace Isolation Profile
        controllerIsolationProfile := sliceConfig.Spec.NamespaceIsolationProfile
        workerIsolationProfile := workerv1alpha1.NamespaceIsolationProfile{
                IsolationEnabled:      controllerIsolationProfile.IsolationEnabled,
                ApplicationNamespaces: make([]string, 0),
                AllowedNamespaces:     make([]string, 0),
        }

        for _, namespace := range controllerIsolationProfile.ApplicationNamespaces </span><span class="cov0" title="0">{
                nonDuplicateClusters := util.RemoveDuplicatesFromArray(namespace.Clusters)
                for _, cluster := range nonDuplicateClusters </span><span class="cov0" title="0">{
                        if cluster == "*" || cluster == workerSliceConfig.Labels["worker-cluster"] </span><span class="cov0" title="0">{
                                workerIsolationProfile.ApplicationNamespaces = append(workerIsolationProfile.ApplicationNamespaces, namespace.Namespace)
                        }</span>
                }
        }
        <span class="cov0" title="0">for _, namespace := range controllerIsolationProfile.AllowedNamespaces </span><span class="cov0" title="0">{
                nonDuplicateClusters := util.RemoveDuplicatesFromArray(namespace.Clusters)
                for _, cluster := range nonDuplicateClusters </span><span class="cov0" title="0">{
                        if cluster == "*" || cluster == workerSliceConfig.Labels["worker-cluster"] </span><span class="cov0" title="0">{
                                workerIsolationProfile.AllowedNamespaces = append(workerIsolationProfile.AllowedNamespaces, namespace.Namespace)
                        }</span>
                }
        }

        <span class="cov0" title="0">workerSliceConfig.Spec.ExternalGatewayConfig = externalGatewayConfig
        workerSliceConfig.Spec.SliceGatewayProvider.SliceGatewayServiceType = sliceGwSvcType
        workerSliceConfig.Spec.SliceGatewayProvider.SliceGatewayProtocol = sliceGwSvcProtocol
        workerSliceConfig.Spec.NamespaceIsolationProfile = workerIsolationProfile
        workerSliceConfig.Spec.SliceName = sliceConfig.Name
        workerSliceConfig.Spec.Octet = octet
        workerSliceConfig.Spec.ClusterSubnetCIDR = clusterSubnetCIDR
        err = util.UpdateResource(ctx, workerSliceConfig)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, err</span>
}

// CreateMinimalWorkerSliceConfig CreateWorkerSliceConfig is a function to create the worker slice configs with minimum number of fields.
// More fields are added in reconciliation loop.
func (s *WorkerSliceConfigService) CreateMinimalWorkerSliceConfig(ctx context.Context, clusters []string, namespace string, label map[string]string, name, sliceSubnet string, clusterCidr string, sliceGwSvcTypeMap map[string]*controllerv1alpha1.SliceGatewayServiceType) (map[string]int, error) <span class="cov0" title="0">{
        logger := util.CtxLogger(ctx)

        //Load Event Recorder with project name, slice name and namespace
        eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(name)

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(name)

        err := s.cleanUpSlices(ctx, label, namespace, clusters)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">workerSliceConfigs, err := s.ListWorkerSliceConfigs(ctx, label, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">clusterMap := s.ComputeClusterMap(clusters, workerSliceConfigs)
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                logger.Debugf("Cluster Object %s", cluster)
                workerSliceConfigName := fmt.Sprintf(workerSliceConfigNameFormat, name, cluster)
                existingSlice := &amp;workerv1alpha1.WorkerSliceConfig{}
                found, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                        Name:      workerSliceConfigName,
                        Namespace: namespace,
                }, existingSlice)

                if err != nil </span><span class="cov0" title="0">{
                        return clusterMap, err
                }</span>
                <span class="cov0" title="0">ipamOctet := clusterMap[cluster]
                clusterSubnetCIDR := util.GetClusterPrefixPool(sliceSubnet, ipamOctet, clusterCidr)
                // determine gw svc type
                sliceGwSvcType := defaultSliceGatewayServiceType
                sliceGwSvcProtocol := defaultSliceGatewayServiceProtocol
                if val, exists := sliceGwSvcTypeMap[cluster]; exists </span><span class="cov0" title="0">{
                        sliceGwSvcType = val.Type
                        sliceGwSvcProtocol = val.Protocol
                }</span>
                <span class="cov0" title="0">logger.Debugf("setting sliceGwSvcType in create_minwsc %s", sliceGwSvcType)
                logger.Debugf("setting sliceGwProtocol in create_minwsc %s", sliceGwSvcProtocol)

                if !found </span><span class="cov0" title="0">{
                        label["project-namespace"] = namespace
                        label["original-slice-name"] = name
                        label["worker-cluster"] = cluster
                        label["kubeslice-manager"] = "controller"

                        expectedSlice := workerv1alpha1.WorkerSliceConfig{
                                TypeMeta: metav1.TypeMeta{},
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      workerSliceConfigName,
                                        Labels:    label,
                                        Namespace: namespace,
                                },
                        }
                        expectedSlice.Spec.SliceName = name
                        expectedSlice.Spec.Octet = &amp;ipamOctet
                        expectedSlice.Spec.ClusterSubnetCIDR = clusterSubnetCIDR
                        expectedSlice.Spec.SliceSubnet = sliceSubnet
                        expectedSlice.Spec.SliceGatewayProvider.SliceGatewayServiceType = sliceGwSvcType
                        expectedSlice.Spec.SliceGatewayProvider.SliceGatewayProtocol = sliceGwSvcProtocol
                        err = util.CreateResource(ctx, &amp;expectedSlice)
                        if err != nil </span><span class="cov0" title="0">{
                                //Register an event for worker slice config creation failure
                                util.RecordEvent(ctx, eventRecorder, &amp;expectedSlice, nil, events.EventWorkerSliceConfigCreationFailed)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "creation_failed",
                                                "event":       string(events.EventWorkerSliceConfigCreationFailed),
                                                "object_name": expectedSlice.Name,
                                                "object_kind": metricKindWorkerSliceConfig,
                                        },
                                )
                                if !k8sErrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{ // ignores resource already exists error(for handling parallel calls to create same resource)
                                        logger.Debug("failed to create worker slice %s since it already exists, namespace - %s ",
                                                expectedSlice.Name, namespace)
                                        return clusterMap, err
                                }</span>
                        }
                        //Register an event for worker slice config creation success
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;expectedSlice, nil, events.EventWorkerSliceConfigCreated)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "created",
                                        "event":       string(events.EventWorkerSliceConfigCreated),
                                        "object_name": expectedSlice.Name,
                                        "object_kind": metricKindWorkerSliceConfig,
                                },
                        )</span>
                } else<span class="cov0" title="0"> {
                        existingSlice.UID = ""
                        existingSlice.Spec.Octet = &amp;ipamOctet
                        existingSlice.Spec.ClusterSubnetCIDR = clusterSubnetCIDR
                        existingSlice.Spec.SliceGatewayProvider.SliceGatewayServiceType = sliceGwSvcType
                        existingSlice.Spec.SliceGatewayProvider.SliceGatewayProtocol = sliceGwSvcProtocol
                        logger.Debug("updating slice with new octet", existingSlice)
                        if existingSlice.Annotations == nil </span><span class="cov0" title="0">{
                                existingSlice.Annotations = make(map[string]string)
                        }</span>
                        <span class="cov0" title="0">existingSlice.Annotations["updatedTimestamp"] = time.Now().String()
                        err = util.UpdateResource(ctx, existingSlice)
                        if err != nil </span><span class="cov0" title="0">{
                                //Register an event for worker slice config update failure
                                util.RecordEvent(ctx, eventRecorder, existingSlice, nil, events.EventWorkerSliceConfigUpdateFailed)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "update_failed",
                                                "event":       string(events.EventWorkerSliceConfigUpdateFailed),
                                                "object_name": existingSlice.Name,
                                                "object_kind": metricKindWorkerSliceConfig,
                                        },
                                )
                                if !k8sErrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{ // ignores resource already exists error(for handling parallel calls to create same resource)
                                        logger.Debug("failed to create worker slice %s since it already exists, namespace - %s ",
                                                workerSliceConfigName, namespace)
                                        return clusterMap, err
                                }</span>
                        }
                        //Register an event for worker slice config update success
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, existingSlice, nil, events.EventWorkerSliceConfigUpdated)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "updated",
                                        "event":       string(events.EventWorkerSliceConfigUpdated),
                                        "object_name": existingSlice.Name,
                                        "object_kind": metricKindWorkerSliceConfig,
                                },
                        )</span>
                }
        }
        <span class="cov0" title="0">return clusterMap, nil</span>
}

func (s *WorkerSliceConfigService) CreateMinimalWorkerSliceConfigForNoNetworkSlice(ctx context.Context, clusters []string, namespace string, label map[string]string, name string) error <span class="cov0" title="0">{

        logger := util.CtxLogger(ctx)

        //Load Event Recorder with project name, slice name and namespace
        eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(name)

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(name)

        err := s.cleanUpSlices(ctx, label, namespace, clusters)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, cluster := range clusters </span><span class="cov0" title="0">{
                logger.Debugf("Cluster Object %s", cluster)
                workerSliceConfigName := fmt.Sprintf(workerSliceConfigNameFormat, name, cluster)
                existingSlice := &amp;workerv1alpha1.WorkerSliceConfig{}
                found, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                        Name:      workerSliceConfigName,
                        Namespace: namespace,
                }, existingSlice)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        label["project-namespace"] = namespace
                        label["original-slice-name"] = name
                        label["worker-cluster"] = cluster
                        label["kubeslice-manager"] = "controller"

                        expectedSlice := workerv1alpha1.WorkerSliceConfig{
                                TypeMeta: metav1.TypeMeta{},
                                ObjectMeta: metav1.ObjectMeta{
                                        Name:      workerSliceConfigName,
                                        Labels:    label,
                                        Namespace: namespace,
                                },
                        }
                        expectedSlice.Spec.SliceName = name
                        err = util.CreateResource(ctx, &amp;expectedSlice)
                        if err != nil </span><span class="cov0" title="0">{
                                //Register an event for worker slice config creation failure
                                util.RecordEvent(ctx, eventRecorder, &amp;expectedSlice, nil, events.EventWorkerSliceConfigCreationFailed)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "creation_failed",
                                                "event":       string(events.EventWorkerSliceConfigCreationFailed),
                                                "object_name": expectedSlice.Name,
                                                "object_kind": metricKindWorkerSliceConfig,
                                        },
                                )
                                if !k8sErrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{ // ignores resource already exists error(for handling parallel calls to create same resource)
                                        logger.Debug("failed to create worker slice %s since it already exists, namespace - %s ",
                                                expectedSlice.Name, namespace)
                                        return err
                                }</span>
                        }
                        //Register an event for worker slice config creation success
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;expectedSlice, nil, events.EventWorkerSliceConfigCreated)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "created",
                                        "event":       string(events.EventWorkerSliceConfigCreated),
                                        "object_name": expectedSlice.Name,
                                        "object_kind": metricKindWorkerSliceConfig,
                                },
                        )</span>
                } else<span class="cov0" title="0"> {
                        existingSlice.UID = ""
                        if existingSlice.Annotations == nil </span><span class="cov0" title="0">{
                                existingSlice.Annotations = make(map[string]string)
                        }</span>
                        <span class="cov0" title="0">existingSlice.Annotations["updatedTimestamp"] = time.Now().String()
                        err = util.UpdateResource(ctx, existingSlice)
                        if err != nil </span><span class="cov0" title="0">{
                                //Register an event for worker slice config update failure
                                util.RecordEvent(ctx, eventRecorder, existingSlice, nil, events.EventWorkerSliceConfigUpdateFailed)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "update_failed",
                                                "event":       string(events.EventWorkerSliceConfigUpdateFailed),
                                                "object_name": existingSlice.Name,
                                                "object_kind": metricKindWorkerSliceConfig,
                                        },
                                )
                                if !k8sErrors.IsAlreadyExists(err) </span><span class="cov0" title="0">{ // ignores resource already exists error(for handling parallel calls to create same resource)
                                        logger.Debug("failed to create worker slice %s since it already exists, namespace - %s ",
                                                workerSliceConfigName, namespace)
                                        return err
                                }</span>
                        }
                        //Register an event for worker slice config update success
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, existingSlice, nil, events.EventWorkerSliceConfigUpdated)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "updated",
                                        "event":       string(events.EventWorkerSliceConfigUpdated),
                                        "object_name": existingSlice.Name,
                                        "object_kind": metricKindWorkerSliceConfig,
                                },
                        )</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// DeleteWorkerSliceConfigByLabel is a function to delete configs of workerslice by label
func (s *WorkerSliceConfigService) DeleteWorkerSliceConfigByLabel(ctx context.Context, label map[string]string, namespace string) error <span class="cov0" title="0">{
        slices, err := s.ListWorkerSliceConfigs(ctx, label, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        //Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(label["original-slice-name"])

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(label["original-slice-name"])

        for _, slice := range slices </span><span class="cov0" title="0">{
                err = util.DeleteResource(ctx, &amp;slice)
                if err != nil </span><span class="cov0" title="0">{
                        //Register an event for worker slice config deletion failure
                        util.RecordEvent(ctx, eventRecorder, &amp;slice, nil, events.EventWorkerSliceConfigDeletionFailed)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventWorkerSliceConfigDeletionFailed),
                                        "object_name": slice.Name,
                                        "object_kind": metricKindWorkerSliceConfig,
                                },
                        )
                        return err
                }</span>
                //Register an event for worker slice config deletion success
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;slice, nil, events.EventWorkerSliceConfigDeleted)
                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventWorkerSliceConfigDeleted),
                                "object_name": slice.Name,
                                "object_kind": metricKindWorkerSliceConfig,
                        },
                )</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ListWorkerSliceConfigs
func (s *WorkerSliceConfigService) ListWorkerSliceConfigs(ctx context.Context, ownerLabel map[string]string,
        namespace string) ([]workerv1alpha1.WorkerSliceConfig, error) <span class="cov0" title="0">{
        slices := &amp;workerv1alpha1.WorkerSliceConfigList{}
        err := util.ListResources(ctx, slices, client.MatchingLabels(ownerLabel), client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return slices.Items, nil</span>
}

// ComputeClusterMap - function assigns a numerical value to the cluster. The value will be from 1 to n, where n is the number of clusters in the slice.
func (s *WorkerSliceConfigService) ComputeClusterMap(clusterNames []string, workerSliceConfigs []workerv1alpha1.WorkerSliceConfig) map[string]int <span class="cov0" title="0">{
        clusterMapping := make(map[string]int, len(clusterNames))
        tempClusterMapping := make(map[string]string, len(clusterNames))
        usedIndexes := make(map[int]bool, 0)
        for _, WorkerSliceConfig := range workerSliceConfigs </span><span class="cov0" title="0">{
                if WorkerSliceConfig.Spec.Octet != nil </span><span class="cov0" title="0">{
                        clusterMapping[WorkerSliceConfig.Labels["worker-cluster"]] = *WorkerSliceConfig.Spec.Octet
                        tempClusterMapping[WorkerSliceConfig.Labels["worker-cluster"]] = fmt.Sprintf("%d", *WorkerSliceConfig.Spec.Octet)
                        usedIndexes[*WorkerSliceConfig.Spec.Octet] = true
                }</span> else<span class="cov0" title="0"> {
                        tempClusterMapping[WorkerSliceConfig.Labels["worker-cluster"]] = ""
                }</span>
        }
        <span class="cov0" title="0">unUsedIndexes := make([]int, 0)
        for index := 0; index &lt; len(clusterNames); index++ </span><span class="cov0" title="0">{
                if !usedIndexes[index] </span><span class="cov0" title="0">{
                        unUsedIndexes = append(unUsedIndexes, index)
                }</span>
        }

        <span class="cov0" title="0">currentIndex := 0
        for _, clusterName := range clusterNames </span><span class="cov0" title="0">{
                if tempClusterMapping[clusterName] == "" </span><span class="cov0" title="0">{
                        clusterMapping[clusterName] = unUsedIndexes[currentIndex]
                        currentIndex++
                }</span>
        }
        <span class="cov0" title="0">return clusterMapping</span>
        //gatewaynumber = no_clusters*serverClusterNumber+ clientClusterNumber
}

// cleanUpSlices is a function
func (s *WorkerSliceConfigService) cleanUpSlices(ctx context.Context, label map[string]string, namespace string, clusters []string) error <span class="cov0" title="0">{
        slices, err := s.ListWorkerSliceConfigs(ctx, label, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">clusterSet := map[string]bool{}
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                clusterSet[cluster] = true
        }</span>
        //Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(label["original-slice-name"])

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(label["original-slice-name"])

        for _, slice := range slices </span><span class="cov0" title="0">{
                clusterName := slice.Labels["worker-cluster"]
                if !clusterSet[clusterName] </span><span class="cov0" title="0">{
                        err = util.DeleteResource(ctx, &amp;slice)
                        if err != nil </span><span class="cov0" title="0">{
                                //Register an event for worker slice config deletion failure
                                util.RecordEvent(ctx, eventRecorder, &amp;slice, nil, events.EventWorkerSliceConfigDeletionFailed)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deletion_failed",
                                                "event":       string(events.EventWorkerSliceConfigDeletionFailed),
                                                "object_name": slice.Name,
                                                "object_kind": metricKindWorkerSliceConfig,
                                        },
                                )
                                return err
                        }</span>
                        //Register an event for worker slice config deletion success
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;slice, nil, events.EventWorkerSliceConfigDeleted)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deleted",
                                        "event":       string(events.EventWorkerSliceConfigDeleted),
                                        "object_name": slice.Name,
                                        "object_kind": metricKindWorkerSliceConfig,
                                },
                        )</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// copySpecFromSliceConfigToWorkerSlice is a function to copy configuration from slice to worker slice
func (s *WorkerSliceConfigService) copySpecFromSliceConfigToWorkerSlice(ctx context.Context, sliceConfig controllerv1alpha1.SliceConfig) workerv1alpha1.WorkerSliceConfig <span class="cov0" title="0">{
        slice := workerv1alpha1.WorkerSliceConfig{}
        err := copier.Copy(&amp;slice.Spec, &amp;sliceConfig.Spec)
        if err != nil </span><span class="cov0" title="0">{
                return workerv1alpha1.WorkerSliceConfig{}
        }</span>
        <span class="cov0" title="0">return slice</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        "k8s.io/apimachinery/pkg/runtime"

        workerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/worker/v1alpha1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/validation/field"
)

// ValidateWorkerSliceConfigUpdate is a function to verify the update of config of workerslice
func ValidateWorkerSliceConfigUpdate(ctx context.Context, workerSliceConfig *workerv1alpha1.WorkerSliceConfig, old runtime.Object) (admission.Warnings, error) <span class="cov0" title="0">{
        if err := preventUpdateWorkerSliceConfig(ctx, workerSliceConfig, old); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceWorker, Kind: "WorkerSliceConfig"}, workerSliceConfig.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// preventUpdateWorkerSliceConfig is a function to prevent the update of workersliceconfig
func preventUpdateWorkerSliceConfig(ctx context.Context, ss *workerv1alpha1.WorkerSliceConfig, old runtime.Object) *field.Error <span class="cov0" title="0">{
        workerSliceConfig := old.(*workerv1alpha1.WorkerSliceConfig)
        if workerSliceConfig.Spec.Octet != nil &amp;&amp; *workerSliceConfig.Spec.Octet != *ss.Spec.Octet </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("Octet"), *ss.Spec.Octet, "cannot be updated")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "github.com/kubeslice/kubeslice-controller/apis/worker/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/util"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

type IWorkerSliceGatewayRecyclerService interface {
        ListWorkerSliceGatewayRecyclers(ctx context.Context, ownerLabel map[string]string, namespace string) ([]v1alpha1.WorkerSliceGwRecycler, error)
        DeleteWorkerSliceGatewayRecyclersByLabel(ctx context.Context, label map[string]string, namespace string) error
}

// WorkerSliceGatewayRecyclerService is a schema for interfaces JobService, WorkerSliceConfigService, SecretService
type WorkerSliceGatewayRecyclerService struct{}

// DeleteWorkerSliceGatewayRecyclersByLabel is a function to delete worker slice gateway by label
func (s *WorkerSliceGatewayRecyclerService) DeleteWorkerSliceGatewayRecyclersByLabel(ctx context.Context, label map[string]string, namespace string) error <span class="cov0" title="0">{
        gateways, err := s.ListWorkerSliceGatewayRecyclers(ctx, label, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, gateway := range gateways </span><span class="cov0" title="0">{
                err = util.DeleteResource(ctx, &amp;gateway)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ListWorkerSliceGatewayRecyclers is a function to list down the established gateways
func (s *WorkerSliceGatewayRecyclerService) ListWorkerSliceGatewayRecyclers(ctx context.Context, ownerLabel map[string]string,
        namespace string) ([]v1alpha1.WorkerSliceGwRecycler, error) <span class="cov0" title="0">{
        gatewayRecyclers := &amp;v1alpha1.WorkerSliceGwRecyclerList{}
        err := util.ListResources(ctx, gatewayRecyclers, client.MatchingLabels(ownerLabel), client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return gatewayRecyclers.Items, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "errors"
        "fmt"
        "os"
        "reflect"
        "strings"
        "time"

        "github.com/kubeslice/kubeslice-controller/events"
        "github.com/kubeslice/kubeslice-controller/metrics"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/types"

        controllerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/controller/v1alpha1"

        "github.com/kubeslice/kubeslice-controller/apis/worker/v1alpha1"
        "github.com/kubeslice/kubeslice-controller/util"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
)

// gatewayName format string name of gateway
const gatewayName = "%s-%s-%s"

type IWorkerSliceGatewayService interface {
        ReconcileWorkerSliceGateways(ctx context.Context, req ctrl.Request) (ctrl.Result, error)
        CreateMinimumWorkerSliceGateways(ctx context.Context, sliceName string, clusterNames []string, namespace string,
                label map[string]string, clusterMap map[string]int, sliceSubnet string, clusterCidr string,
                sliceGwSvcTypeMap map[string]*controllerv1alpha1.SliceGatewayServiceType, gatewayPairs []util.GatewayPair) (ctrl.Result, error)
        ListWorkerSliceGateways(ctx context.Context, ownerLabel map[string]string, namespace string) ([]v1alpha1.WorkerSliceGateway, error)
        DeleteWorkerSliceGatewaysByLabel(ctx context.Context, label map[string]string, namespace string) error
        NodeIpReconciliationOfWorkerSliceGateways(ctx context.Context, cluster *controllerv1alpha1.Cluster, namespace string) error
        GenerateCerts(ctx context.Context, sliceName, namespace, gatewayProtocol string,
                serverGateway *v1alpha1.WorkerSliceGateway, clientGateway *v1alpha1.WorkerSliceGateway,
                gatewayAddresses util.WorkerSliceGatewayNetworkAddresses) error
        BuildNetworkAddresses(sliceSubnet, sourceClusterName, destinationClusterName string,
                clusterMap map[string]int, clusterCidr string) util.WorkerSliceGatewayNetworkAddresses
}

// WorkerSliceGatewayService is a schema for interfaces JobService, WorkerSliceConfigService, SecretService
type WorkerSliceGatewayService struct {
        js   IJobService
        sscs IWorkerSliceConfigService
        sc   ISecretService
        mf   metrics.IMetricRecorder
}

// WorkerSliceGatewayNetworkAddresses is a schema for WorkerSlice gateway network parameters

// ReconcileWorkerSliceGateways is a function to reconcile/restore the worker slice gateways
func (s *WorkerSliceGatewayService) ReconcileWorkerSliceGateways(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        // Step 0: Get WorkerSliceGateway resource
        logger := util.CtxLogger(ctx)
        logger.Infof("Started Recoincilation of WorkerSliceGateway %v", req.NamespacedName)
        workerSliceGateway := &amp;v1alpha1.WorkerSliceGateway{}
        found, err := util.GetResourceIfExist(ctx, req.NamespacedName, workerSliceGateway)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                logger.Infof("workerSliceGateway %v not found, returning from  reconciler loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>

        //Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(req.Namespace)).
                WithNamespace(req.Namespace).
                WithSlice(workerSliceGateway.Labels["original-slice-name"])

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(req.Namespace)).
                WithNamespace(req.Namespace).
                WithSlice(workerSliceGateway.Labels["original-slice-name"])

        //Step 1: Finalizers
        if workerSliceGateway.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                if !util.ContainsString(workerSliceGateway.GetFinalizers(), WorkerSliceGatewayFinalizer) </span><span class="cov0" title="0">{
                        if shouldReturn, result, reconErr := util.IsReconciled(util.AddFinalizer(ctx, workerSliceGateway, WorkerSliceGatewayFinalizer)); shouldReturn </span><span class="cov0" title="0">{
                                return result, reconErr
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                logger.Infof("WorkerSliceGateway %v is being deleted", req.NamespacedName)
                result := RemoveWorkerFinalizers(ctx, workerSliceGateway, WorkerSliceGatewayFinalizer)
                if result.Requeue </span><span class="cov0" title="0">{
                        return result, nil
                }</span>
                <span class="cov0" title="0">secret := corev1.Secret{}
                serviceAccountSecretNamespacedName := types.NamespacedName{
                        Namespace: req.Namespace,
                        Name:      workerSliceGateway.Name,
                }
                found, err = util.GetResourceIfExist(ctx, serviceAccountSecretNamespacedName, &amp;secret)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                        _, err := s.sc.DeleteSecret(ctx, req.Namespace, workerSliceGateway.Name)
                        if err != nil </span><span class="cov0" title="0">{
                                return result, err
                        }</span>
                }
                <span class="cov0" title="0">slice := &amp;controllerv1alpha1.SliceConfig{}
                found, err = util.GetResourceIfExist(ctx, client.ObjectKey{
                        Name:      workerSliceGateway.Spec.SliceName,
                        Namespace: req.Namespace,
                }, slice)
                if err != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>
                <span class="cov0" title="0">if found &amp;&amp; slice.ObjectMeta.DeletionTimestamp.IsZero() </span><span class="cov0" title="0">{
                        clusters := slice.Spec.Clusters
                        if util.IsInSlice(clusters, workerSliceGateway.Labels["worker-cluster"]) </span><span class="cov0" title="0">{
                                logger.Debug("SliceGateway deleted forcefully from slice, removing gateway pair and secret", req.NamespacedName)
                                //Register an event for worker slice gateway deleted forcefully
                                util.RecordEvent(ctx, eventRecorder, workerSliceGateway, slice, events.EventWorkerSliceGatewayDeletedForcefully)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deleted_forcefully",
                                                "event":       string(events.EventWorkerSliceGatewayDeletedForcefully),
                                                "object_name": workerSliceGateway.Name,
                                                "object_kind": metricKindWorkerSliceGateway,
                                        },
                                )
                                completeResourceName := fmt.Sprintf(util.LabelValue, util.GetObjectKind(slice), slice.GetName())
                                labels := util.GetOwnerLabel(completeResourceName)
                                labels["worker-cluster"] = workerSliceGateway.Labels["remote-cluster"]
                                labels["remote-cluster"] = workerSliceGateway.Labels["worker-cluster"]
                                pairWorkerSliceGateway := &amp;v1alpha1.WorkerSliceGatewayList{}
                                err = util.ListResources(ctx, pairWorkerSliceGateway, client.MatchingLabels(labels), client.InNamespace(req.Namespace))
                                if err != nil </span><span class="cov0" title="0">{
                                        return result, err
                                }</span>
                                <span class="cov0" title="0">if pairWorkerSliceGateway.Items != nil &amp;&amp; len(pairWorkerSliceGateway.Items) &gt; 0 </span><span class="cov0" title="0">{
                                        err = util.DeleteResource(ctx, &amp;pairWorkerSliceGateway.Items[0])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return result, err
                                        }</span>
                                        <span class="cov0" title="0">_, err := s.sc.DeleteSecret(ctx, req.Namespace, pairWorkerSliceGateway.Items[0].Name)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return result, err
                                        }</span>
                                }
                                <span class="cov0" title="0">if slice.Annotations == nil </span><span class="cov0" title="0">{
                                        slice.Annotations = make(map[string]string)
                                }</span>
                                <span class="cov0" title="0">slice.Annotations["updatedTimestamp"] = time.Now().String()
                                logger.Debug("Recreating sliceGateway", req.NamespacedName)
                                err = util.UpdateResource(ctx, slice)
                                if err != nil </span><span class="cov0" title="0">{
                                        //Register an event for worker slice gateway recreation failure
                                        util.RecordEvent(ctx, eventRecorder, workerSliceGateway, slice, events.EventWorkerSliceGatewayRecreationFailed)
                                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                                map[string]string{
                                                        "action":      "recreation_failed",
                                                        "event":       string(events.EventWorkerSliceGatewayRecreationFailed),
                                                        "object_name": workerSliceGateway.Name,
                                                        "object_kind": metricKindWorkerSliceGateway,
                                                },
                                        )
                                        return result, err
                                }</span>
                                //Register an event for worker slice gateway recreation success
                                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, workerSliceGateway, slice, events.EventWorkerSliceGatewayRecreated)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "recreated",
                                                "event":       string(events.EventWorkerSliceGatewayRecreated),
                                                "object_name": workerSliceGateway.Name,
                                                "object_kind": metricKindWorkerSliceGateway,
                                        },
                                )</span>
                        }
                }
                <span class="cov0" title="0">return result, nil</span>
        }
        <span class="cov0" title="0">sliceConfig := &amp;controllerv1alpha1.SliceConfig{}
        found, err = util.GetResourceIfExist(ctx, client.ObjectKey{
                Name:      workerSliceGateway.Spec.SliceName,
                Namespace: req.Namespace,
        }, sliceConfig)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                logger.Infof("sliceConfig %v not found, returning from  reconciler loop.", req.NamespacedName)
                return ctrl.Result{}, nil
        }</span>

        // determine gateway connectivity type &amp; gateway protocol
        <span class="cov0" title="0">var clusterName string
        if workerSliceGateway.Spec.GatewayHostType == serverGateway </span><span class="cov0" title="0">{
                clusterName = workerSliceGateway.Labels["worker-cluster"]
        }</span> else<span class="cov0" title="0"> {
                clusterName = workerSliceGateway.Labels["remote-cluster"]
        }</span>
        <span class="cov0" title="0">sliceGwSvcTypeMap := getSliceGwSvcTypes(sliceConfig)
        gatewayConnectivityType := defaultSliceGatewayServiceType
        gatewayProtocol := defaultSliceGatewayServiceProtocol
        if val, exists := sliceGwSvcTypeMap[clusterName]; exists </span><span class="cov0" title="0">{
                gatewayConnectivityType = val.Type
                gatewayProtocol = val.Protocol
        }</span>
        <span class="cov0" title="0">workerSliceGateway.Spec.GatewayConnectivityType = gatewayConnectivityType
        workerSliceGateway.Spec.GatewayProtocol = gatewayProtocol
        logger.Debugf("setting gwConType in reconciler %s", workerSliceGateway.Spec.GatewayConnectivityType)
        logger.Debugf("setting gwProto in reconciler %s", workerSliceGateway.Spec.GatewayProtocol)

        workerSliceGateway.Spec.GatewayType = sliceConfig.Spec.SliceGatewayProvider.SliceGatewayType
        workerSliceGateway.UID = ""
        err = util.UpdateResource(ctx, workerSliceGateway)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">err = s.reconcileNodeIPAndNodePort(ctx, workerSliceGateway, req.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, err</span>
}

// reconcileNodeIPAndNodePort is a function to reconcile NodeIp and NodePort of remoteGateway/server cluster
func (s *WorkerSliceGatewayService) reconcileNodeIPAndNodePort(ctx context.Context, localGateway *v1alpha1.WorkerSliceGateway, namespace string) error <span class="cov0" title="0">{
        remoteGateway := v1alpha1.WorkerSliceGateway{}
        found, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                Name:      localGateway.Spec.RemoteGatewayConfig.GatewayName,
                Namespace: namespace,
        }, &amp;remoteGateway)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                if !reflect.DeepEqual(localGateway.Spec.LocalGatewayConfig.NodeIps, remoteGateway.Spec.RemoteGatewayConfig.NodeIps) ||
                        !reflect.DeepEqual(localGateway.Spec.LocalGatewayConfig.NodeIp, remoteGateway.Spec.RemoteGatewayConfig.NodeIp) ||
                        localGateway.Spec.LocalGatewayConfig.NodePort != remoteGateway.Spec.RemoteGatewayConfig.NodePort ||
                        !reflect.DeepEqual(localGateway.Spec.LocalGatewayConfig.NodePorts, remoteGateway.Spec.RemoteGatewayConfig.NodePorts) ||
                        (localGateway.Spec.GatewayHostType == serverGateway &amp;&amp;
                                !reflect.DeepEqual(localGateway.Spec.LocalGatewayConfig.LoadBalancerIps, remoteGateway.Spec.RemoteGatewayConfig.LoadBalancerIps)) </span><span class="cov0" title="0">{

                        remoteGateway.Spec.RemoteGatewayConfig.NodeIp = localGateway.Spec.LocalGatewayConfig.NodeIp
                        remoteGateway.Spec.RemoteGatewayConfig.NodeIps = localGateway.Spec.LocalGatewayConfig.NodeIps
                        remoteGateway.Spec.RemoteGatewayConfig.NodePort = localGateway.Spec.LocalGatewayConfig.NodePort
                        remoteGateway.Spec.RemoteGatewayConfig.NodePorts = localGateway.Spec.LocalGatewayConfig.NodePorts
                        remoteGateway.Spec.RemoteGatewayConfig.LoadBalancerIps = localGateway.Spec.LocalGatewayConfig.LoadBalancerIps

                        err = util.UpdateResource(ctx, &amp;remoteGateway)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// DeleteWorkerSliceGatewaysByLabel is a function to delete worker slice gateway by label
func (s *WorkerSliceGatewayService) DeleteWorkerSliceGatewaysByLabel(ctx context.Context, label map[string]string, namespace string) error <span class="cov0" title="0">{
        gateways, err := s.ListWorkerSliceGateways(ctx, label, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        //Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(label["original-slice-name"])

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(label["original-slice-name"])

        for _, gateway := range gateways </span><span class="cov0" title="0">{
                err = util.DeleteResource(ctx, &amp;gateway)
                if err != nil </span><span class="cov0" title="0">{
                        //Register an event for worker slice gateway deletion failure
                        util.RecordEvent(ctx, eventRecorder, &amp;gateway, nil, events.EventWorkerSliceGatewayDeletionFailed)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deletion_failed",
                                        "event":       string(events.EventWorkerSliceGatewayDeletionFailed),
                                        "object_name": gateway.Name,
                                        "object_kind": metricKindWorkerSliceGateway,
                                },
                        )
                        return err
                }</span>
                //Register an event for worker slice gateway deletion success
                <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;gateway, nil, events.EventWorkerSliceGatewayDeleted)
                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "deleted",
                                "event":       string(events.EventWorkerSliceGatewayDeleted),
                                "object_name": gateway.Name,
                                "object_kind": metricKindWorkerSliceGateway,
                        },
                )</span>
        }
        <span class="cov0" title="0">return nil</span>
}

type CertPairRequestMap struct {
        SliceName string                      `json:"sliceName,omitempty"`
        Pairs     []IndividualCertPairRequest `json:"pairs,omitempty"`
}

// IndividualCertPairRequest Parameters for individual certificate pair generations.
type IndividualCertPairRequest struct {
        VpnFqdn string `json:"vpnFqdn,omitempty"`
        // The NSM server network.
        NsmServerNetwork string `json:"nsmServerNetwork,omitempty"`
        // The NSM client network.
        NsmClientNetwork string `json:"nsmClientNetwork,omitempty"`
        // The NSM mask.
        NsmMask string `json:"nsmMask,omitempty"`
        // VPN's IP address to client.
        VpnIpToClient string `json:"vpnIpToClient,omitempty"`
        // VPN's network IP.
        VpnNetwork string `json:"vpnNetwork,omitempty"`
        // VPN's IP mask.
        VpnMask string `json:"vpnMask,omitempty"`
        // The client gateway ID.
        ClientId string `json:"clientId,omitempty"`
        // The server gateway ID.
        ServerId string `json:"serverId,omitempty"`
}

// CreateMinimumWorkerSliceGateways is a function to create gateways with minimum specification
func (s *WorkerSliceGatewayService) CreateMinimumWorkerSliceGateways(ctx context.Context, sliceName string,
        clusterNames []string, namespace string, label map[string]string, clusterMap map[string]int,
        sliceSubnet string, clusterCidr string, sliceGwSvcTypeMap map[string]*controllerv1alpha1.SliceGatewayServiceType, gatewayPairs []util.GatewayPair) (ctrl.Result, error) <span class="cov0" title="0">{

        err := s.cleanupObsoleteGateways(ctx, namespace, label, clusterNames, clusterMap)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">if len(clusterNames) &lt; 2 </span><span class="cov0" title="0">{
                return ctrl.Result{}, nil
        }</span>

        <span class="cov0" title="0">_, err = s.createMinimumGatewaysIfNotExists(ctx, sliceName, clusterNames, namespace, label, clusterMap, sliceSubnet, clusterCidr, sliceGwSvcTypeMap, gatewayPairs)
        if err != nil </span><span class="cov0" title="0">{
                return ctrl.Result{}, err
        }</span>
        <span class="cov0" title="0">return ctrl.Result{}, nil</span>
}

// ListWorkerSliceGateways is a function to list down the established gateways
func (s *WorkerSliceGatewayService) ListWorkerSliceGateways(ctx context.Context, ownerLabel map[string]string,
        namespace string) ([]v1alpha1.WorkerSliceGateway, error) <span class="cov0" title="0">{
        gateways := &amp;v1alpha1.WorkerSliceGatewayList{}
        err := util.ListResources(ctx, gateways, client.MatchingLabels(ownerLabel), client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return gateways.Items, nil</span>
}

// cleanupObsoleteGateways is a function delete outdated gateways
func (s *WorkerSliceGatewayService) cleanupObsoleteGateways(ctx context.Context, namespace string, ownerLabel map[string]string,
        clusters []string, clusterMap map[string]int) error <span class="cov0" title="0">{

        gateways, err := s.ListWorkerSliceGateways(ctx, ownerLabel, namespace)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        //Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(ownerLabel["original-slice-name"])

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(ownerLabel["original-slice-name"])

        clusterExistMap := make(map[string]bool, len(clusters))
        for _, cluster := range clusters </span><span class="cov0" title="0">{
                clusterExistMap[cluster] = true
        }</span>

        <span class="cov0" title="0">for _, gateway := range gateways </span><span class="cov0" title="0">{
                clusterSource := gateway.Spec.LocalGatewayConfig.ClusterName
                clusterDestination := gateway.Spec.RemoteGatewayConfig.ClusterName
                gatewayExpectedNumber := s.calculateGatewayNumber(clusterMap[clusterSource], clusterMap[clusterDestination])
                if !clusterExistMap[clusterSource] || !clusterExistMap[clusterDestination] || gatewayExpectedNumber != gateway.Spec.GatewayNumber </span><span class="cov0" title="0">{
                        err = util.DeleteResource(ctx, &amp;gateway)
                        if err != nil </span><span class="cov0" title="0">{
                                //Register an event for worker slice gateway deletion failure
                                util.RecordEvent(ctx, eventRecorder, &amp;gateway, nil, events.EventWorkerSliceGatewayDeletionFailed)
                                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                        map[string]string{
                                                "action":      "deletion_failed",
                                                "event":       string(events.EventWorkerSliceGatewayDeletionFailed),
                                                "object_name": gateway.Name,
                                                "object_kind": metricKindWorkerSliceGateway,
                                        },
                                )
                                return err
                        }</span>
                        //Register an event for worker slice gateway deletion success
                        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, &amp;gateway, nil, events.EventWorkerSliceGatewayDeleted)
                        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                                map[string]string{
                                        "action":      "deleted",
                                        "event":       string(events.EventWorkerSliceGatewayDeleted),
                                        "object_name": gateway.Name,
                                        "object_kind": metricKindWorkerSliceGateway,
                                },
                        )</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// createMinimumGatewaysIfNotExists is a helper function to create the gateways between worker clusters if not exists
func (s *WorkerSliceGatewayService) createMinimumGatewaysIfNotExists(ctx context.Context, sliceName string,
        clusterNames []string, namespace string, ownerLabel map[string]string, clusterMap map[string]int,
        sliceSubnet string, clusterCidr string, sliceGwSvcTypeMap map[string]*controllerv1alpha1.SliceGatewayServiceType, gatewayPairs []util.GatewayPair) (ctrl.Result, error) <span class="cov0" title="0">{
        logger := util.CtxLogger(ctx)

        // Build cluster mapping
        clusterMapping := map[string]*controllerv1alpha1.Cluster{}
        for _, clusterName := range clusterNames </span><span class="cov0" title="0">{
                cluster := controllerv1alpha1.Cluster{}
                found, err := util.GetResourceIfExist(ctx, client.ObjectKey{Name: clusterName, Namespace: namespace}, &amp;cluster)
                if !found || err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
                <span class="cov0" title="0">clusterMapping[clusterName] = &amp;cluster</span>
        }

        <span class="cov0" title="0">logger.Infof("Creating %d gateway pairs for slice %s", len(gatewayPairs), sliceName)

        // Create gateways for each resolved pair
        for _, pair := range gatewayPairs </span><span class="cov0" title="0">{
                sourceCluster := clusterMapping[pair.Source]
                destinationCluster := clusterMapping[pair.Target]

                if sourceCluster == nil || destinationCluster == nil </span><span class="cov0" title="0">{
                        logger.Errorf("Cluster not found in mapping: source=%s, dest=%s", pair.Source, pair.Target)
                        continue</span>
                }

                <span class="cov0" title="0">gatewayNumber := s.calculateGatewayNumber(clusterMap[sourceCluster.Name], clusterMap[destinationCluster.Name])
                gatewayAddresses := s.BuildNetworkAddresses(sliceSubnet, sourceCluster.Name, destinationCluster.Name, clusterMap, clusterCidr)

                // Determine the gateway svc parameters
                sliceGwSvcType := defaultSliceGatewayServiceType
                gwSvcProtocol := defaultSliceGatewayServiceProtocol
                if val, exists := sliceGwSvcTypeMap[sourceCluster.Name]; exists </span><span class="cov0" title="0">{
                        sliceGwSvcType = val.Type
                        gwSvcProtocol = val.Protocol
                }</span>

                <span class="cov0" title="0">logger.Debugf("Creating gateway pair: %s &lt;-&gt; %s (type=%s, proto=%s)",
                        sourceCluster.Name, destinationCluster.Name, sliceGwSvcType, gwSvcProtocol)

                err := s.createMinimumGateWayPairIfNotExists(ctx, sourceCluster, destinationCluster, sliceName, namespace,
                        sliceGwSvcType, gwSvcProtocol, ownerLabel, gatewayNumber, gatewayAddresses)
                if err != nil </span><span class="cov0" title="0">{
                        return ctrl.Result{}, err
                }</span>
        }

        <span class="cov0" title="0">logger.Infof("Successfully created %d gateway pairs for slice %s", len(gatewayPairs), sliceName)
        return ctrl.Result{}, nil</span>
}

// createMinimumGateWayPairIfNotExists is a function to create the pair of gatways between 2 clusters if not exists
func (s *WorkerSliceGatewayService) createMinimumGateWayPairIfNotExists(ctx context.Context,
        sourceCluster *controllerv1alpha1.Cluster, destinationCluster *controllerv1alpha1.Cluster,
        sliceName, namespace, gatewayConnType, gatewayProtocol string, label map[string]string, gatewayNumber int,
        gatewayAddresses util.WorkerSliceGatewayNetworkAddresses) error <span class="cov0" title="0">{
        serverGatewayName := fmt.Sprintf(gatewayName, sliceName, sourceCluster.Name, destinationCluster.Name)
        clientGatewayName := fmt.Sprintf(gatewayName, sliceName, destinationCluster.Name, sourceCluster.Name)
        gateway := v1alpha1.WorkerSliceGateway{}
        found, err := util.GetResourceIfExist(ctx, client.ObjectKey{Name: serverGatewayName, Namespace: namespace}, &amp;gateway)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                found, err = util.GetResourceIfExist(ctx, client.ObjectKey{
                        Name:      clientGatewayName,
                        Namespace: namespace,
                }, &amp;gateway)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if found </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        //Load Event Recorder with project name, slice name and namespace
        <span class="cov0" title="0">eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(sliceName)

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(sliceName)

        serverGatewayObject := s.buildMinimumGateway(sourceCluster, destinationCluster, sliceName, namespace,
                serverGateway, gatewayConnType, gatewayProtocol, label, gatewayNumber,
                gatewayAddresses.ServerSubnet, gatewayAddresses.ServerVpnAddress,
                clientGatewayName, gatewayAddresses.ClientSubnet, gatewayAddresses.ClientVpnAddress, serverGatewayName)
        err = util.CreateResource(ctx, serverGatewayObject)
        if err != nil </span><span class="cov0" title="0">{
                //Register an event for worker slice gateway creation failure
                util.RecordEvent(ctx, eventRecorder, serverGatewayObject, nil, events.EventWorkerSliceGatewayCreationFailed)
                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "creation_failed",
                                "event":       string(events.EventWorkerSliceGatewayCreationFailed),
                                "object_name": serverGatewayObject.Name,
                                "object_kind": metricKindWorkerSliceGateway,
                        },
                )
                return err
        }</span>
        //Register an event for worker slice gateway creation success
        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, serverGatewayObject, nil, events.EventWorkerSliceGatewayCreated)
        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                map[string]string{
                        "action":      "created",
                        "event":       string(events.EventWorkerSliceGatewayCreated),
                        "object_name": serverGatewayObject.Name,
                        "object_kind": metricKindWorkerSliceGateway,
                },
        )
        clientGatewayObject := s.buildMinimumGateway(destinationCluster, sourceCluster, sliceName, namespace,
                clientGateway, gatewayConnType, gatewayProtocol, label, gatewayNumber,
                gatewayAddresses.ClientSubnet, gatewayAddresses.ClientVpnAddress,
                serverGatewayName, gatewayAddresses.ServerSubnet, gatewayAddresses.ServerVpnAddress, clientGatewayName)
        err = util.CreateResource(ctx, clientGatewayObject)
        if err != nil </span><span class="cov0" title="0">{
                //Register an event for worker slice gateway creation failure
                util.RecordEvent(ctx, eventRecorder, clientGatewayObject, nil, events.EventWorkerSliceGatewayCreationFailed)
                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "creation_failed",
                                "event":       string(events.EventWorkerSliceGatewayCreationFailed),
                                "object_name": clientGatewayObject.Name,
                                "object_kind": metricKindWorkerSliceGateway,
                        },
                )
                return err
        }</span>
        //Register an event for worker slice gateway creation success
        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, clientGatewayObject, nil, events.EventWorkerSliceGatewayCreated)
        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                map[string]string{
                        "action":      "created",
                        "event":       string(events.EventWorkerSliceGatewayCreated),
                        "object_name": clientGatewayObject.Name,
                        "object_kind": metricKindWorkerSliceGateway,
                },
        )

        err = s.GenerateCerts(ctx, sliceName, namespace, gatewayProtocol, serverGatewayObject, clientGatewayObject, gatewayAddresses)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// buildNetworkAddresses - function generates the object of WorkerSliceGatewayNetworkAddresses
func (s *WorkerSliceGatewayService) BuildNetworkAddresses(sliceSubnet, sourceClusterName, destinationClusterName string,
        clusterMap map[string]int, clusterCidr string) util.WorkerSliceGatewayNetworkAddresses <span class="cov0" title="0">{
        gatewayAddresses := util.WorkerSliceGatewayNetworkAddresses{}
        ipr := strings.Split(sliceSubnet, ".")
        serverSubnet := util.GetClusterPrefixPool(sliceSubnet, clusterMap[sourceClusterName], clusterCidr)
        clientSubnet := util.GetClusterPrefixPool(sliceSubnet, clusterMap[destinationClusterName], clusterCidr)
        gatewayAddresses.ServerNetwork = strings.SplitN(serverSubnet, "/", -1)[0]
        gatewayAddresses.ClientNetwork = strings.SplitN(clientSubnet, "/", -1)[0]
        gatewayAddresses.ServerSubnet = serverSubnet
        gatewayAddresses.ClientSubnet = clientSubnet
        gatewayAddresses.ServerVpnNetwork = fmt.Sprintf("%s.%s.%d.%s", ipr[0], ipr[1], 255, "0")
        gatewayAddresses.ServerVpnAddress = fmt.Sprintf("%s.%s.%d.%s", ipr[0], ipr[1], 255, "1")
        gatewayAddresses.ClientVpnAddress = fmt.Sprintf("%s.%s.%d.%s", ipr[0], ipr[1], 255, "2")
        return gatewayAddresses
}</span>

// buildMinimumGateway function returns the gateway object
func (s *WorkerSliceGatewayService) buildMinimumGateway(sourceCluster, destinationCluster *controllerv1alpha1.Cluster,
        sliceName, namespace, gatewayHostType, gatewayConnType, gatewayProtocol string, labels map[string]string, gatewayNumber int,
        gatewaySubnet, localVpnAddress, remoteGatewayName, remoteGatewaySubnet, remoteVpnAddress, localGatewayName string) *v1alpha1.WorkerSliceGateway <span class="cov0" title="0">{
        labels["worker-cluster"] = sourceCluster.Name
        labels["remote-cluster"] = destinationCluster.Name
        labels["kubeslice-manager"] = "controller"
        labels["project-namespace"] = namespace
        labels["original-slice-name"] = sliceName
        sourceClusterNodeIPs := sourceCluster.Spec.NodeIPs
        destinationClusterNodeIPs := destinationCluster.Spec.NodeIPs

        if len(sourceClusterNodeIPs) == 0 </span><span class="cov0" title="0">{
                sourceClusterNodeIPs = sourceCluster.Status.NodeIPs
        }</span>
        <span class="cov0" title="0">if len(destinationClusterNodeIPs) == 0 </span><span class="cov0" title="0">{
                destinationClusterNodeIPs = destinationCluster.Status.NodeIPs
        }</span>

        <span class="cov0" title="0">return &amp;v1alpha1.WorkerSliceGateway{
                TypeMeta: metav1.TypeMeta{},
                ObjectMeta: metav1.ObjectMeta{
                        Name:      fmt.Sprintf(gatewayName, sliceName, sourceCluster.Name, destinationCluster.Name),
                        Namespace: namespace,
                        Labels:    labels,
                },
                Spec: v1alpha1.WorkerSliceGatewaySpec{
                        SliceName: sliceName,
                        LocalGatewayConfig: v1alpha1.SliceGatewayConfig{
                                ClusterName:   sourceCluster.Name,
                                GatewayName:   localGatewayName,
                                GatewaySubnet: gatewaySubnet,
                                NodeIps:       sourceClusterNodeIPs,
                                NodeIp:        sourceCluster.Spec.NodeIP,
                                VpnIp:         localVpnAddress,
                        },
                        RemoteGatewayConfig: v1alpha1.SliceGatewayConfig{
                                ClusterName:   destinationCluster.Name,
                                GatewayName:   remoteGatewayName,
                                GatewaySubnet: remoteGatewaySubnet,
                                NodeIps:       destinationClusterNodeIPs,
                                NodeIp:        destinationCluster.Spec.NodeIP,
                                VpnIp:         remoteVpnAddress,
                        },
                        GatewayCredentials: v1alpha1.GatewayCredentials{
                                SecretName: fmt.Sprintf(gatewayName, sliceName, sourceCluster.Name, destinationCluster.Name),
                        },
                        GatewayHostType:         gatewayHostType,
                        GatewayNumber:           gatewayNumber,
                        GatewayConnectivityType: gatewayConnType,
                        GatewayProtocol:         gatewayProtocol,
                },
        }</span>
}

// generateCerts is a function to generate the certificates between serverGateway and clientGateway
func (s *WorkerSliceGatewayService) GenerateCerts(ctx context.Context, sliceName, namespace, gatewayProtocol string,
        serverGateway *v1alpha1.WorkerSliceGateway, clientGateway *v1alpha1.WorkerSliceGateway,
        gatewayAddresses util.WorkerSliceGatewayNetworkAddresses) error <span class="cov0" title="0">{
        sliceConfig := &amp;controllerv1alpha1.SliceConfig{}
        found, err := util.GetResourceIfExist(ctx, client.ObjectKey{
                Name:      sliceName,
                Namespace: namespace,
        }, sliceConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                errMsg := fmt.Sprintf("sliceConfig for %v not found in %v.", sliceName, namespace)
                return errors.New(errMsg)
        }</span>
        <span class="cov0" title="0">cpr := s.buildCertPairRequest(sliceName, serverGateway, clientGateway, gatewayAddresses)

        //Load Event Recorder with project name, slice name and namespace
        eventRecorder := util.CtxEventRecorder(ctx).
                WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(sliceName)

        // Load metrics with project name and namespace
        s.mf.WithProject(util.GetProjectName(namespace)).
                WithNamespace(namespace).
                WithSlice(sliceName)

        environment := make(map[string]string, 6)
        environment["NAMESPACE"] = namespace
        environment["GATEWAY_PROTOCOL"] = gatewayProtocol
        environment["SERVER_SLICEGATEWAY_NAME"] = serverGateway.Name
        environment["CLIENT_SLICEGATEWAY_NAME"] = clientGateway.Name
        environment["SLICE_NAME"] = sliceName
        environment["CERT_GEN_REQUESTS"], _ = util.EncodeToBase64(&amp;cpr)
        environment["GATEWAY_TYPE"] = string(sliceConfig.Spec.SliceGatewayProvider.SliceGatewayType)
        if nil == sliceConfig.Spec.VPNConfig </span><span class="cov0" title="0">{
                environment["VPN_CIPHER"] = "AES-256-CBC"
        }</span> else<span class="cov0" title="0"> {
                environment["VPN_CIPHER"] = sliceConfig.Spec.VPNConfig.Cipher
        }</span>

        <span class="cov0" title="0">jobNamespace = os.Getenv("KUBESLICE_CONTROLLER_MANAGER_NAMESPACE")
        util.CtxLogger(ctx).Info("jobNamespace", jobNamespace) //todo:remove
        _, err = s.js.CreateJob(ctx, jobNamespace, JobImage, environment)
        if err != nil </span><span class="cov0" title="0">{
                //Register an event for gateway job creation failure
                util.RecordEvent(ctx, eventRecorder, serverGateway, clientGateway, events.EventSliceGatewayJobCreationFailed)
                s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                        map[string]string{
                                "action":      "job_creation_failed",
                                "event":       string(events.EventSliceGatewayJobCreationFailed),
                                "object_name": serverGateway.Name,
                                "object_kind": metricKindWorkerSliceGateway,
                        },
                )
                return err
        }</span>
        //Register an event for gateway job creation success
        <span class="cov0" title="0">util.RecordEvent(ctx, eventRecorder, serverGateway, clientGateway, events.EventSliceGatewayJobCreated)
        s.mf.RecordCounterMetric(metrics.KubeSliceEventsCounter,
                map[string]string{
                        "action":      "job_created",
                        "event":       string(events.EventSliceGatewayJobCreated),
                        "object_name": serverGateway.Name,
                        "object_kind": metricKindWorkerSliceGateway,
                },
        )
        return nil</span>
}

// buildCertPairRequest is a function to generate the pair between server-cluster and client-cluster
func (s *WorkerSliceGatewayService) buildCertPairRequest(sliceName string,
        gateway1, gateway2 *v1alpha1.WorkerSliceGateway,
        gatewayAddresses util.WorkerSliceGatewayNetworkAddresses) CertPairRequestMap <span class="cov0" title="0">{
        clusterName := gateway1.Spec.LocalGatewayConfig.ClusterName
        serverNumber := gateway1.Spec.GatewayNumber
        serverId, clientId := gateway1.Name, gateway2.Name
        vpnFqdn := fmt.Sprintf("%s-%s-%d.vpn.aveshasystems.com", clusterName, sliceName, serverNumber)

        cpr := IndividualCertPairRequest{
                VpnFqdn:          vpnFqdn,
                NsmServerNetwork: gatewayAddresses.ServerNetwork,
                NsmClientNetwork: gatewayAddresses.ClientNetwork,
                NsmMask:          "255.255.255.0",
                VpnIpToClient:    gatewayAddresses.ClientVpnAddress,
                VpnNetwork:       gatewayAddresses.ServerVpnNetwork,
                VpnMask:          "255.255.255.0",
                ClientId:         clientId,
                ServerId:         serverId,
        }
        finalObject := CertPairRequestMap{
                SliceName: sliceName,
                Pairs:     []IndividualCertPairRequest{cpr}}

        return finalObject
}</span>

// calculateGatewayNumber is a function to return the gateway number
func (s *WorkerSliceGatewayService) calculateGatewayNumber(cluster1Ins int, cluster2Ins int) int <span class="cov0" title="0">{
        maximum, minimum := cluster1Ins, cluster2Ins
        if cluster2Ins &gt; cluster1Ins </span><span class="cov0" title="0">{
                maximum, minimum = cluster2Ins, cluster1Ins
        }</span>
        <span class="cov0" title="0">return ((maximum-1)*(maximum-2))/2 + minimum</span>
}

// NodeIpReconciliationOfWorkerSliceGateways is a function to update the NodeIP of local gateway
func (s *WorkerSliceGatewayService) NodeIpReconciliationOfWorkerSliceGateways(ctx context.Context, cluster *controllerv1alpha1.Cluster, namespace string) error <span class="cov0" title="0">{
        workerSliceGateways := &amp;v1alpha1.WorkerSliceGatewayList{}
        label := map[string]string{}
        label["worker-cluster"] = cluster.Name
        err := util.ListResources(ctx, workerSliceGateways, client.MatchingLabels(label), client.InNamespace(namespace))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for _, gateway := range workerSliceGateways.Items </span><span class="cov0" title="0">{
                if len(gateway.Spec.LocalGatewayConfig.NodeIps) == 0 </span><span class="cov0" title="0">{
                        gateway.Spec.LocalGatewayConfig.NodeIps = append(gateway.Spec.LocalGatewayConfig.NodeIps, gateway.Spec.LocalGatewayConfig.NodeIp)
                        err = util.UpdateResource(ctx, &amp;gateway)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">nodeIPs := cluster.Spec.NodeIPs
                if len(nodeIPs) == 0 </span><span class="cov0" title="0">{
                        nodeIPs = cluster.Status.NodeIPs
                }</span>
                <span class="cov0" title="0">if !reflect.DeepEqual(gateway.Spec.LocalGatewayConfig.NodeIps, nodeIPs) </span><span class="cov0" title="0">{
                        gateway.Spec.LocalGatewayConfig.NodeIps = nodeIPs
                        err = util.UpdateResource(ctx, &amp;gateway)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                // For backward compatibility.
                <span class="cov0" title="0">if !reflect.DeepEqual(gateway.Spec.LocalGatewayConfig.NodeIp, cluster.Spec.NodeIP) </span><span class="cov0" title="0">{
                        gateway.Spec.LocalGatewayConfig.NodeIp = cluster.Spec.NodeIP
                        err = util.UpdateResource(ctx, &amp;gateway)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">/*
 *         Copyright (c) 2022 Avesha, Inc. All rights reserved. # # SPDX-License-Identifier: Apache-2.0
 *
 *         Licensed under the Apache License, Version 2.0 (the "License");
 *         you may not use this file except in compliance with the License.
 *         You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 *         Unless required by applicable law or agreed to in writing, software
 *         distributed under the License is distributed on an "AS IS" BASIS,
 *         WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *         See the License for the specific language governing permissions and
 *         limitations under the License.
 */

package service

import (
        "context"
        "sigs.k8s.io/controller-runtime/pkg/webhook/admission"

        "k8s.io/apimachinery/pkg/runtime"

        workerv1alpha1 "github.com/kubeslice/kubeslice-controller/apis/worker/v1alpha1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/runtime/schema"
        "k8s.io/apimachinery/pkg/util/validation/field"
)

// ValidateWorkerSliceGatewayUpdate is function to validate the update of gateways
func ValidateWorkerSliceGatewayUpdate(ctx context.Context, workerSliceGateway *workerv1alpha1.WorkerSliceGateway, old runtime.Object) (admission.Warnings, error) <span class="cov0" title="0">{
        if err := preventUpdateWorkerSliceGateway(ctx, workerSliceGateway, old); err != nil </span><span class="cov0" title="0">{
                return nil, apierrors.NewInvalid(schema.GroupKind{Group: apiGroupKubeSliceWorker, Kind: "WorkerSliceGateway"}, workerSliceGateway.Name, field.ErrorList{err})
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// preventUpdateWorkerSliceGateway is a function to check the GatewayNumber of WorkerSliceGateway
func preventUpdateWorkerSliceGateway(workerSliceGatewayCtx context.Context, sg *workerv1alpha1.WorkerSliceGateway, old runtime.Object) *field.Error <span class="cov0" title="0">{
        workerSliceGateway := old.(*workerv1alpha1.WorkerSliceGateway)
        if workerSliceGateway.Spec.GatewayNumber != sg.Spec.GatewayNumber </span><span class="cov0" title="0">{
                return field.Invalid(field.NewPath("Spec").Child("GatewayNumber"), sg.Spec.GatewayNumber, "cannot be updated")
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
